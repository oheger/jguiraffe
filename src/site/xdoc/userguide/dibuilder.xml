<?xml version="1.0"?>
<!--

    Copyright 2006-2014 The JGUIraffe Team.

    Licensed under the Apache License, Version 2.0 (the "License")
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

-->
<!-- $Id: dibuilder.xml 207 2012-02-09 07:30:13Z oheger $ -->

<document>

 <properties>
  <title>The dependency injection builder</title>
  <author email="oheger@users.sourceforge.net">Oliver Heger</author>
 </properties>

<body>
  <section name="The dependency injection builder">
  <p>
    Following object-oriented design principles typically lead to applications
    consisting of many classes that model entities of the real world that belong
    to the problem domain of the application. During application runtime
    instances of these classes are created. Each object is responsible for a
    specific task. To implement the application's functionality the objects
    have to interact with each other in complex ways. Therefore they need
    references to their collaborators. In total this forms a complex network of
    objects in the application's memory.
  </p>
  <p>
    In its initialization phase an application has to create the network of its
    objects somehow. This is not trivial, and it is worth thinking about how
    this task can be achieved best.
  </p>
  <p>
    One possibility would be to let the objects create their helper objects
    themselves. Then the application would only need to instantiate the root
    objects in the network. All other objects would then be created
    automatically. This solution works, but it is problematic. One point is that
    the whole construction process is very inflexible. Objects and the references
    between them are hard-coded in the application's initialization logic. This
    makes it very hard to change parts of the object network. Also testing of
    single classes is hard because if a class creates all its helper objects
    directly, it is hardly possible to inject stub or mock objects for them.
    Another point is that care must be taken if the network contains shared
    references. In this case special logic must be added to ensure that the
    corresponding target objects are not instantiated multiple times.
  </p>
  <p>
    Another solution could be a lookup service: Objects that need references to
    other objects do not create these objects directly, but are passed a service
    object from which they can request references to other objects. The
    implementation of the lookup service is then responsible for the creation of
    the requested objects. An example for such a lookup service is <em>JNDI</em>.
    The lookup service solution improves the situation and solves some of the
    problems mentioned above. For instance, the lookup service can be mocked
    itself, and thus it is possible to pass mock or stub objects to classes that
    are to be tested. However, there is still a lot of boiler plate code needed
    to construct the whole network of objects. Every class that has references
    needs to interact with the lookup service.
  </p>
  <p>
    For some time another approach has become very popular: <em>dependency
    injection</em>. In a nutshell, dependency injection means that classes are
    not responsible at all to create objects they depend on or obtain the
    corresponding references somehow. Rather, they only provide means that allow
    these references to be set, e.g. through constructor parameters or through
    corresponding set methods. Further, there is some kind of description that
    defines which classes need which other helper objects. Another component,
    the dependency injection container, reads this description and creates the
    complete object graph based on this information. This involves creating all
    object instances and initializing the references to the dependent objects.
    Dependency injection greatly simplifies the construction of complex object
    networks. Neither the classes involved nor the application's initialization
    code has to take care about object creation. Instead all the logic required
    for constructing the graph of objects is implemented in the dependency
    injection container in a generic way. Classes that are part of the graph
    only have to adhere to simple conventions so that the needed references can
    be passed in (e.g. they can be Java beans and define corresponding set
    methods). This makes testing these classes in isolation very easy because a
    test class can use the same conventions for passing in mock objects.
  </p>
  <p>
    Because dependency injection has many advantages there are many
    implementations of this concept. The most popular ones are certainly
    <a href="http://www.springsource.org/">Spring</a> and
    <a href="http://code.google.com/p/google-guice/">Google Guice</a>. The <em>JGUIraffe</em>
    library also implements a lean dependency injection framework. You may ask
    why another dependency injection framework is needed if there are already
    well-known and proven implementations.
  </p>
  <p>
    Well, one point is that dependency injection is such a nice concept that it
    has been adopted by many other frameworks in different areas. For instance,
    some web application frameworks use it to connect the components
    implementing business logic together. Also the
    <a href="https://appframework.dev.java.net/">Swing application framework</a>
    uses a kind of dependency injection to pass data defined in resource
    property files to components of the UI. So integrating the concept of
    dependency injection into frameworks actually makes sense.
  </p>
  <p>
    Another reason for <em>JGUIraffe</em>'s support for dependency injection is
    that it really plays nicely together with the builder approach outlined in
    the <a href="builders.html">last section</a>. <em>JGUIraffe</em> uses XML
    builder scripts to define the graphical user interface of an application.
    These scripts can also contain definitions for objects to be created, e.g.
    controller classes or validators. The newly created objects can directly be
    connected with elements of the UI. For instance, a dialog is typically
    associated with a controller object. The controller can be defined in the
    same script as the dialog itself, and it can be passed references to UI
    components it needs to interact with. After the builder script has been
    processed all objects have been created and are correctly connected with all
    their dependent objects - no further initialization is required for the
    application. We will see how this works in practice later in this section.
  </p>

  <subsection name="Fundamental concepts and interfaces">
  <p>
    Before we come to concrete examples of using dependency injection in
    <em>JGUIraffe</em> applications some fundamental concepts have to be
    introduced. The basic idea is that objects to be created are defined in XML
    builder scripts (processed by <a href="http://commons.apache.org/Jelly">
    Commons Jelly</a> as regular builder scripts). These objects are also referred
    to as "beans" because they typically follow well-known Java beans
    conventions. After a builder script with bean definitions have been
    processed special context objects are available through which the beans can
    be queried so that instances can be obtained. We give an introduction of the
    most important interfaces involved in this process.
  </p>
  <p>
    When working with the dependency injection framework it is all about bean
    definitions: a builder script is processed, and the beans defined there are
    stored in internal data structures from where they can be accessed by the
    application. An important data structure for storing bean defininitions is
    a <code><a href="../apidocs/net/sf/jguiraffe/di/BeanStore.html">BeanStore.
    </a></code> A <code>BeanStore</code> groups a number of bean definitions
    together and provides a very basic API to access them. An application
    rarely uses a <code>BeanStore</code> directly because there are other
    classes implementing a more convenient API on top of it. However, in builder
    scripts tags can be used for creating bean stores and for assigning bean
    definitions to them. This can make sense if there is a logic grouping for
    the beans used by an application and the beans should really be separated.
    (If it is more convenient for an application to store all their beans in a
    single place, it need not worry much about bean stores). An important point
    to know about bean stores is that they form a hierarchical structure: a
    <code>BeanStore</code> can have a parent bean store. This also is related to
    the visibility of beans. A child bean store can access bean definitions in
    its parent, but not vice versa. For typical use cases this hierarchy is
    convenient. When an application starts up a root bean store is created and
    populated with bean definitions. If later another window is to be opened -
    say a dialog form -, the root bean store becomes the parent of the bean
    store created when processing the builder script for the new window. Thus it
    is possible to access the beans defined in the root store from the newly
    created window.
  </p>
  <p>
    As said before, a <code>BeanStore</code> is mainly used internally by the
    framework to organize bean definitions. The interface used by clients is
    <code><a href="../apidocs/net/sf/jguiraffe/di/BeanContext.html">BeanContext.
    </a></code> A <code>BeanContext</code> provides a bunch of methods for
    accessing beans. Internally, it is associated with a <code>BeanStore</code>.
    When it is queried for a bean it searches the <code>BeanStore</code> and its
    parents if necessary until a corresponding bean definition is found. Then
    the bean is created if required and returned. If a bean is to be newly
    created, all dependencies for this bean have to be resolved. This can cause
    the creation of many other beans, depending on the dependencies defined for
    this bean. If the bean can be reused, it is cached so that it can be directly
    returned when it is requested the next time.
  </p>
  <p>
    The following example shows how a <code>BeanContext</code> object is used
    for querying a bean with a given name:
  </p>
    <source><![CDATA[
BeanContext beanCtx = ...  // obtain the context
MyBeanClass bean = (MyBeanClass) beanCtx.getBean("myBeanName");
    ]]></source>
  <p>
    Each bean definition has a unique name, by which it can be accessed from a
    <code>BeanContext</code>. Alternatively, the bean can be specified by its
    class - provided that there is only a single bean definition using this
    class. In this case the example looks as follows:
  </p>
    <source><![CDATA[
BeanContext beanCtx = ...  // obtain the context
MyBeanClass bean = beanCtx.getBean(MyBeanClass.class);
    ]]></source>
  <p>
    Note that the type cast is no more necessary because the method uses Java's
    generics. Note further that the class passed to <code>getBean()</code> does
    not have to match exactly the class in the bean definition; rather, it can
    be a super type (including an interface). This conforms to good practice:
    the application can program against an interface which is used in the
    <code>getBean()</code> call; in the bean definition the concrete
    implementation is provided.
  </p>
  <p>
    In addition to the <code>getBean()</code> methods the
    <code>BeanContext</code> interface defines methods for listing the available
    bean definitions and for checking whether a specific bean definition exists
    in the context. Most methods come in two variants: One variant takes a
    <code>BeanStore</code> object as argument, and the other does not. The method
    without the <code>BeanStore</code> argument operates on the default bean
    store set for this <code>BeanContext</code>. The other variant accesses the
    specified <code>BeanStore</code>. (Because a <code>BeanContext</code>
    mainly implements additional logic on top of a <code>BeanStore</code> it
    can operate on an arbitrary <code>BeanStore</code> instance.)
  </p>
  <p>
    Now where we have discussed how a <code>BeanContext</code> object can be
    used to query beans, you certainly want to know how a
    <code>BeanContext</code> can be created and initialized. Setting up a
    <code>BeanContext</code> requires a <em>builder</em> which can process a
    bean definition file. There are two options:
    <ul>
    <li>A specific <em>bean builder</em> can be used that is only able to
    process bean definition files. This is slightly more efficient than the
    other option, but the API is a bit more involved, and you are actually
    limited to a sub set of tags related to the dependency injection framework.</li>
    <li>Alternatively the regular builder described in the section
    <a href="builders.html">Introducing builders</a> is also capable to process
    bean definitions. This is convenient because this way beans can be defined
    together with the UI of the application.</li>
    </ul>
    We will shortly provide more details about these two options. Because using
    the standard builder is more powerful and convenient than invoking the
    specific bean builder the first option is rarely used. Nevertheless it makes
    sense to discuss bean builders, too, because the interfaces used here are
    also of importance in the second approach.
  </p>
  <p>
    In order to invoke a bean builder, the following steps have to be performed:
    <ol>
    <li>A <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/BeanBuilderFactory.html">
    BeanBuilderFactory</a></code> has to be obtained from the central
    <code><a href="../apidocs/net/sf/jguiraffe/gui/app/Application.html">
    Application</a></code> object.</li>
    <li>Using the factory a new
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/BeanBuilder.html">
    BeanBuilder</a></code> instance can be created.</li>
    <li>The <code>BeanBuilder</code> class defines a <code>build()</code> method
    which processes a Jelly script with bean definitions. It returns a
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/BeanBuilderResult.html">
    BeanBuilderResult</a></code> object with the results of the builder
    operation.</li>
    <li>The <code>BeanBuilderResult</code> object allows access to all
    <code>BeanStore</code> objects created while the builder script was
    processed. From the information stored in this object a <code>BeanContext</code>
    can be created.</li>
    </ol>
    In source code these steps look as follow:
  </p>
    <source><![CDATA[
BeanBuilderFactory factory = application.getBeanBuilderFactory();

try
{
    BeanBuilder builder = factory.getBeanBuilder();
    Locator beanDefs = ... // locator to the script to be processed
    BeanBuilderResult result = builder.build(beanDefs, null, null);
    BeanContext beanContext = new DefaultBeanContext(result.getBeanStore(null));
}
catch(BuilderException bex)
{
    // exception handling
}
    ]]></source>
  <p>
    Obtaining the <code>BeanBuilderFactory</code> and the <code>BeanBuilder</code>
    from the factory should be clear. Then a
    <code><a href="../apidocs/net/sf/jguiraffe/locators/Locator.html">Locator
    </a></code> object is created that points to the bean definition file to be
    processed. This object is passed to the builder's <code>build()</code>
    method as first argument. For the other arguments <b>null</b> is passed,
    which means that default values are used. The second argument is of type
    <code><a href="../apidocs/net/sf/jguiraffe/di/MutableBeanStore.html">
    MutableBeanStore</a></code>. If here an object is provided, all bean
    definitions parsed are added to this store. Otherwise, a new
    <code>BeanStore</code> is created. The third parameter of the
    <code>build()</code> method is a
    <code><a href="../apidocs/net/sf/jguiraffe/di/ClassLoaderProvider.html">
    ClassLoaderProvider</a></code> object. We come back to this class later in
    the section with advanced topics. For now it is sufficient to know that
    <b>null</b> can be passed for a default provider.
  </p>
  <p>
    <code>build()</code> returns a
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/BeanBuilderResult.html">
    BeanBuilderResult</a></code> object. This object can be queried for all
    <code>BeanStore</code> objects created during the builder operation. As
    mentioned earlier, bean definitions can be organized in multiple bean
    stores. Each bean store has a unique name. The bean store with the name
    <b>null</b> is the root bean store, i.e. the top element in the hierarchical
    structure of bean stores. The example script obtains this root bean store
    and passes it to a newly created
    <code><a href="../apidocs/net/sf/jguiraffe/di/impl/DefaultBeanContext.html">
    DefaultBeanContext</a></code> object. <code>DefaultBeanContext</code> is the
    default implementation of the <code>BeanContext</code> interface. Note that
    both the <code>BeanBuilderFactory</code> and the <code>BeanBuilder</code>
    can throw a
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/BuilderException.html">
    BuilderException</a></code> if something goes wrong. So this exception has
    to be handled.
  </p>
  <p>
    The <code>BeanBuilder</code> API is pretty basic and thus it is harder to
    use. The other builders provided by the <em>JGUIraffe</em> library which
    are responsible for the creation of UI elements are implemented on top of
    the bean builder. They hide much of the complexity of the bean builder API.
    The key here is the
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/BuilderData.html">
    BuilderData</a></code> object that has to be passed to the builder: After
    the builder operation completes it contains some fully initialized objects
    allowing access to bean stores and bean definitions created while processing
    the builder script. This includes
    <ul>
    <li>the <code>BeanBuilderResult</code> object which provides access to all
    <code>BeanStore</code> objects, and</li>
    <li>a <code>BeanContext</code> object associated with the root bean store.</li>
    </ul>
    So the code for calling the builder and obtaining the <code>BeanContext</code>
    becomes much simpler:
  </p>
    <source><![CDATA[
Builder builder = application.getApplicationContext().newBuilder();
ApplicationBuilderData builderData = application
        .getApplicationContext().initBuilderData();
try
{
    Locator locator = ClassPathLocator.getInstance("mybeans.jelly");
    builder.build(locator, builderData);
    BeanContext beanContext = builderData.getBuilderContext();
}
catch(BuilderException bex)
{
    // exception handling
}
    ]]></source>
  <p>
    This is pretty similar to the example code introduced in the section
    <a href="builders.html#Invoking_a_builder">Invoking a builder</a>. The
    <code>BuilderContext</code> can be obtained directly from the
    <code>BuilderData</code> object. Again, a <code>BuilderException</code> has
    to be handled. In the next section we deal with Jelly scripts that contain
    bean definitions and discuss the different ways of defining beans.
  </p>
  </subsection>

  <subsection name="Scripts with bean definitions">
  <p>
    Scripts that are used to define beans must be complient with
    <a href="http://commons.apache.org/jelly">Commons Jelly</a> which is used to
    interpret them. Therefore they have to be valid XML documents.
  </p>
  <p>
    <strong><a name="Structure_of_scripts">Structure of bean definition scripts</a>
    </strong>
  </p>
  <p>
    The following code fragment shows the fundamental structure of such a
    builder script:
  </p>
    <source><![CDATA[
<?xml version="1.0" encoding="ISO-8859-1"?>
<j:jelly xmlns:j="jelly:core" xmlns:di="diBuilder">

  <!-- Beans to be stored in the root store.-->
  <di:bean name="rootBean" beanClass="net.sf.jguiraffe.di.ReflectionTestClass"/>
  ...
  <!-- A bean store definition with nested beans.-->
  <di:store name="beanStore1">
    <di:bean name="store1Bean" beanClass="..."/>
    ...
  </di:store>
  ...
  <!-- Another bean store definition.-->
  <di:store name="beanStore2" parentName="beanStore1">
  ...
  </di:store>
</j:jelly>
    ]]></source>
  <p>
    The document starts with a typical XML declaration that also defines the
    encoding (the encoding is optional). Then the root element
    <code>&lt;j:jelly&gt;</code>with the namespace declarations follows. Two
    namespace prefixes are defined:
    <ul>
      <li><em>j</em> for core Jelly tags. This means that all standard tags
      available in Jelly can be used in the script.</li>
      <li><em>di</em> for tags of the <em>JGUIraffe</em> dependency injection
      tag library (<em>di</em> stands for dependency injection). So all tags
      starting with the prefix <em>di</em> are expected to be part of the
      dependency injection tag library.</li>
    </ul>
    When using other builders, e.g. for creating form elements or windows,
    further namespace declarations can be added.
  </p>
  <p>
    Below the root element beans can be defined using <code>&lt;di:bean&gt;</code>
    tags. If not specified otherwise, these bean definitions are added to the
    root <code>BeanStore</code>. The root bean store is either passed to the
    builder's <code>build()</code> method or it is created automatically.
  </p>
  <p>
    With the <code>&lt;di:store&gt;</code> tag additional bean stores can be
    created. The beans that should be stored in these stores can be defined by
    nested <code>&lt;di:bean&gt;</code> tags. Alternatively the
    <code>&lt;di:bean&gt;</code> tag supports the <code>store</code> attribute
    that can be used to specify the name of the target bean store. Because bean
    stores can form a hierarchical structure the <code>&lt;di:store&gt;</code>
    tag supports a <code>parentName</code> attribute; here the name of the parent
    store can be provided. If this attribute is undefined, the new bean store
    becomes a child of the root bean store.
  </p>
  <p>
    <strong><a name="Simple_beans">Simple bean definitions</a></strong>
  </p>
  <p>
    The example script in the previous section already showed the declaration of
    a simple bean:
  </p>
    <source><![CDATA[
<di:bean name="rootBean" beanClass="net.sf.jguiraffe.di.ReflectionTestClass"/>
    ]]></source>
  <p>
    A bean must have a unique name. This is the name that is also passed to a
    <code>BeanContext</code> when querying the bean. In the most simple form the
    class of the bean is specified using its fully qualified name. If this form
    of a bean declaration is used, the class must have a default constructor.
    This constructor is invoked to create the bean instance. By the way, this
    example and most of the following ones use the
    <code>ReflectionTestClass</code> class to demonstrate the various ways of
    defining beans. The source code of this class can be found below:
  </p>
    <source><![CDATA[
package net.sf.jguiraffe.di;

public class ReflectionTestClass
{
    /** A test member field. */
    private String stringProp;

    /** Another test member field. */
    private int intProp;

    /** A property storing arbitrary data.*/
    private Object data;

    /**
     * Creates a new instance of <code>ReflectionTestClass</code>. Default ctor.
     */
    public ReflectionTestClass()
    {
        this(null, 0);
    }

    /**
     * Creates a new instance of <code>ReflectionTestClass</code> and initializes
     * the properties.
     *
     * @param s the string property
     * @param i the int property
     */
    public ReflectionTestClass(String s, int i)
    {
        this(i);
        stringProp = s;
    }

    /**
     * Creates a new instance of <code>TestClass</code> and initializes
     * the string property.
     *
     * @param s the string property
     */
    public ReflectionTestClass(String s)
    {
        this(s, 0);
    }

    public String getStringProp()
    {
        return stringProp;
    }

    public void setStringProp(String stringProp)
    {
        this.stringProp = stringProp;
    }

    public int getIntProp()
    {
        return intProp;
    }

    public void setIntProp(int intProp)
    {
        this.intProp = intProp;
    }

    public Object getData()
    {
        return data;
    }

    public void setData(Object data)
    {
        this.data = data;
    }

    /**
     * Initializes the properties of this instance.
     *
     * @param s the string property
     * @param i the int property
     * @return the old value of the string property
     */
    public String initialize(String s, int i)
    {
        String result = getStringProp();
        setStringProp(s);
        setIntProp(i);
        return result;
    }

    /**
     * A static factory method for testing static method invocations.
     *
     * @param s the string property
     * @param i the int property
     * @return the newly created instance
     */
    public static ReflectionTestClass getInstance(String s, int i)
    {
        return new ReflectionTestClass(s, i);
    }
}
    ]]></source>
  <p>
    Well, this class does not do anything meaningful, but there are many ways to
    construct new instances, including various constructors and a static factory
    method. These will be used by the examples following in this section.
  </p>
  <p>
    <a name="Singletons"/><strong>Singleton and non-singleton beans</strong>
  </p>
  <p>
    A <em>singleton</em> is a class from which only a single instance exists
    during runtime of an application. The singleton pattern is often used to
    hold central information that must be accessible from any parts of an
    application. If implemented by hand, typically static instance fields and
    methods are used to ensure the singleton property.
  </p>
  <p>
    Because the dependency injection framework controls when an instance of a
    bean is created it is easy to make specific beans a singleton. The framework
    only has to cache the instance after its creation and return it again if it
    is queried later on. Actually this is the default behavior for bean
    definitions. Whether a bean is a singleton or not is controlled by the
    boolean <code>singleton</code> attribute of the <code>&lt;bean&gt;</code>
    tag whose default value is <b>true</b>:
  </p>
    <source><![CDATA[
<!-- A singleton bean -->
<di:bean name="singletonBean" beanClass="net.sf.jguiraffe.di.ReflectionTestClass"/>

<!-- Not a singleton bean -->
<di:bean name="nonSingletonBean" singleton="false"
  beanClass="net.sf.jguiraffe.di.ReflectionTestClass"/>
    ]]></source>
  <p>
    In this example the first bean is a singleton while the other is not. If
    this script is processed by a builder, the following assertians are true:
  </p>
    <source><![CDATA[
ReflectionTestClass bean1 =
  (ReflectionTestClass) beanContext.getBean("singletonBean");
assert bean1 == beanContext.getBean("singletonBean");

ReflectionTestClass bean2 =
  (ReflectionTestClass) beanContext.getBean("nonSingletonBean");
assert bean2 != beanContext.getBean("nonSingletonBean");
    ]]></source>
  <p>
    So every time a non-singleton bean definition is accessed, a new instance of
    this bean is created.
  </p>
  <p>
    <a name="Constants"/><strong>Constant values</strong>
  </p>
  <p>
    The <code>&lt;di:bean&gt;</code> tag allows defining beans that are assigned
    constant values. These beans are created immediately when the script is
    processed by the builder. They are always singletons. This is typically
    used for primitive values. The following example fragment shows some
    constant definitions:
  </p>
    <source><![CDATA[
<di:bean name="intConst" value="42" valueClass="java.lang.Integer"/>
<di:bean name="strConst" value="Test"/>
    ]]></source>
  <p>
    Here a <code>java.lang.Integer</code> and a <code>java.lang.String</code>
    bean are defined. The <code>value</code> attribute of the
    <code>&lt;di:bean&gt;</code> tag is responsible for assigning a value. With
    the <code>valueClass</code> attribute the data type of the value can be
    specified. It is String per default; so in case of the integer value it must
    be provided in order to perform the correct type conversion.
  </p>
  <p>
    <a name="Constructors"/><strong>Invoking a constructor</strong>
  </p>
  <p>
    So far beans were created only by calling their default constructor. Of
    course, it is possible to invoke other constructors as well. This is done
    using a nested <code>&lt;di:constructor&gt;</code> tag. In the next
    example the constructor of <code>ReflectionTestClass</code> is invoked that
    expects the values of the string and the integer property:
  </p>
    <source><![CDATA[
<di:bean name="constructor"
  beanClassName="net.sf.jguiraffe.di.ReflectionTestClass">
  <di:constructor>
    <di:param parameterClass="java.lang.String" value="test string"/>
    <di:param value="42"/>
  </di:constructor>
</di:bean>
    ]]></source>
  <p>
    The <code>&lt;di:constructor&gt;</code> tag can have an arbitrary number of
    nested <code>&lt;di:param&gt;</code> tags representing the parameters of the
    constructor to be invoked. The <code>value</code> attribute of the
    <code>&lt;di:param&gt;</code> tag specifies the value to be passed. With
    the optional <code>parameterClass</code> attribute the data type of the
    parameter can be specified. This is normally not necessary because the
    type can be inferred by the parameters of the constructor. However, if there
    are multiple constructors with similar parameter types it may be required
    to use the attribute to avoid ambiguities. If values need to be converted to
    other types, the <code>valueClass</code> attribute can be provided.
    More information about parameters with different data types can be found in
    the sub section <a href="#matching_and_conversions">Parameter matching and
    data type conversions</a> later in this chapter.
  </p>
  <p>
    <a name="Static_factory"/><strong>Invoking a static factory method</strong>
  </p>
  <p>
    What if the bean to be created does not define a constructor, but it uses a
    static factory method? The <code>ReflectionTestClass</code> class used in
    the tests has a static <code>getInstance()</code> method that can also be
    invoked to create new instances. In the builder script the
    <code>&lt;di:factory&gt;</code> tag in collaboration with the
    <code>&lt;di:methodInvocation&gt;</code> tag is used to achieve this:
  </p>
    <source><![CDATA[
<di:bean name="staticFactory"
  beanClass="net.sf.jguiraffe.di.ReflectionTestClass">
  <di:factory>
    <di:methodInvocation method="getInstance"
      targetClass="net.sf.jguiraffe.di.ReflectionTestClass">
      <di:param value="test String"/>
      <di:param value="42"/>
    </di:methodInvocation>
  </di:factory>
</di:bean>
    ]]></source>
  <p>
    With the <code>&lt;di:methodInvocation&gt;</code> tag (which is implemented
    by the <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/di/tags/MethodInvocationTag.html">
    MethodInvocationTag</a></code> class) the method to be invoked is specified.
    Parameters are provided as nested <code>&lt;di:param&gt;</code> tags. In this
    case we invoke a static method on the <code>ReflectionTestClass</code> class
    - as defined by the <code>targetClass</code> attribute. The
    <code>&lt;di:factory&gt;</code> tag also allows invoking methods on other
    beans. This way non-static factory methods can be used, too. More information
    can be found in the documentation of the
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/di/tags/FactoryTag.html">
    FactoryTag</a></code> class.
  </p>
  <p>
    <a name="Setting_properties"/><strong>Setting properties</strong>
  </p>
  <p>
    If a bean class fully adheres to the Java Beans specification, it has a
    standard constructor and get and set methods for its properties. To create
    and initialize such a bean first the standard constructor must be called,
    then the properties can be set. We have already seen how to invoke the
    standard constructor of a class. With nested <code>&lt;di:setProperty&gt;</code>
    tags properties of the newly created bean can be set.
  </p>
    <source><![CDATA[
<di:bean name="propertiesBean"
  beanClass="net.sf.jguiraffe.di.ReflectionTestClass">
  <di:setProperty property="intProp" value="42"/>
  <di:setProperty property="stringProp" value="This is a test."/>
</di:bean>
    ]]></source>
  <p>
    The attributes of the <code>&lt;di:setProperty&gt;</code> tag are very
    similar to the <code>&lt;di:param&gt;</code> tag. A full description of all
    supported features can be found in the documentation of the
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/di/tags/SetPropertyTag.html">
    SetPropertyTag</a></code> class. The property names passed to the
    <code>property</code> attribute conform to the Java Beans specification: A
    property named <em>foo</em> requires the existence of a public method named
    <em>setFoo()</em> in the corresponding class.
  </p>
  <p>
    <a name="Dependencies"/><strong>Dependencies to other beans</strong>
  </p>
  <p>
    At the beginning of this chapter it was stated that the major advantage of
    the dependency injection approach is that dependencies to other objects are
    automatically provided when beans are created. So far we have not dealt with
    dependencies yet.
  </p>
  <p>
    References to other beans can be specified in both constructor arguments or
    when setting properties. Actually the <code>&lt;di:setProperty&gt;</code>
    and the <code>&lt;di:param&gt;</code> tags work very similar in the way their
    data can be specified. The following options are supported:
    <ul>
    <li>Constant values can be specified using the <code>value</code> attribute
    (plus an optional <code>valueClass</code> or <code>valueClassName</code>
    attribute). We have seen this before.</li>
    <li>With the <code>refName</code> attribute the reference to another bean
    can be specified. Here the name of the bean has to be provided. A bean with
    this name must exist in the same bean store or in one of its parents.</li>
    <li>Alternatively to the name of the dependent bean its class can be
    specified to the <code>refClass</code> attribute. This is analogous to the
    <code>getBean()</code> methods of the <code>BeanContext</code> class which
    allow requesting a bean by name or by its class.</li>
    <li>It is also possible to place a nested <code>&lt;di:bean&gt;</code> tag
    in the body of a <code>&lt;di:setProperty&gt;</code> or
    <code>&lt;di:param&gt;</code> tag. Then this bean becomes the data of the
    nesting tag.</li>
    </ul>
  </p>
  <p>
    We provide some examples for these features. In the first example we use
    the <code>refName</code> attribute to refer to other beans in the script.
    In the subsection <a href="#Constants">Constant values</a> a string and an
    integer constant have been defined. Now we reference these beans:
  </p>
    <source><![CDATA[
<di:bean name="constantDependencies"
  beanClass="net.sf.jguiraffe.di.ReflectionTestClass">
  <di:constructor>
    <di:param refName="strConst"/>
  </di:constructor>
  <di:setProperty property="intProp" refName="intConst"/>
</di:bean>
    ]]></source>
  <p>
    As can be seen, it is possible to mix the invocation of constructors with
    the setting of properties. Here we call the constructor that expects a
    string parameter and pass the constant string bean. Then we set the integer
    property and pass the constant integer bean.
  </p>
  <p>
    In the next example an instance of <code>ReflectionTestClass</code> is
    defined, and its <code>data</code> property is assigned another instance
    which is defined in place (the <code>data</code> property is of type
    <code>java.lang.Object</code>, so it accepts properties of all types).
  </p>
    <source><![CDATA[
<di:bean name="inplaceBean" beanClass="net.sf.jguiraffe.di.ReflectionTestClass">
  <di:setProperty property="data">
    <di:bean beanClass="net.sf.jguiraffe.di.ReflectionTestClass">
      <di:constructor>
        <di:param refName="strConst"/>
        <di:param refName="intConst"/>
      </di:constructor>
    </di:bean>
  </di:setProperty>
</di:bean>
    ]]></source>
  <p>
    In this case the <code>&lt;di:setProperty&gt;</code> tag has no attribute
    defining any value to be set. Instead, the value is specified by the
    <code>&lt;di:bean&gt;</code> tag in the body of the tag. Here another
    <code>ReflectionTestClass</code> instance is defined and initialized. Note
    that this nested <code>&lt;di:bean&gt;</code> tag does not have a
    <code>name</code> attribute; it is an anonymous bean declaration that is
    only used in this specific place. What is demonstrated here for the
    <code>&lt;di:setProperty&gt;</code> tag works exactly the same for the
    <code>&lt;di:param&gt;</code> tag. Thus references to other beans can be
    passed to constructors or other methods as well.
  </p>
  <p>
    A related question is how to specify a <b>null</b> value. For instance,
    <code>ReflectionTestClass</code> has a constructor that expects a string and
    an integer parameter. How can this constructor be invoked passing in
    <b>null</b> for the string? This can be achieved using the
    <code>&lt;di:null&gt;</code> tag:
  </p>
    <source><![CDATA[
<di:bean name="nullParam" beanClass="net.sf.jguiraffe.di.ReflectionTestClass">
  <di:constructor>
    <di:param><di:null/></di:param>
    <di:param value="42"/>
  </di:constructor>
</di:bean>
    ]]></source>
  <p>
    <a name="Collections"/><strong>Collections</strong>
  </p>
  <p>
    Some beans have properties or constructor arguments that require a
    collection. The dependency injection tag library provides several tags for
    creating various types of collections. Here is an example of how a list can
    be created and passed as value to a property:
  </p>
    <source><![CDATA[
<di:bean name="list" beanClassName="net.sf.jguiraffe.di.ReflectionTestClass">
  <di:setProperty property="data">
    <di:list elementClassName="java.lang.Integer">
      <di:element value="1"/>
      <di:element value="2"/>
      <di:element value="1000" valueClassName="java.lang.Long"/>
    </di:list>
  </di:setProperty>
</di:bean>
    ]]></source>
  <p>
    The <code>&lt;di:list&gt;</code> tag (implemented by the
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/di/tags/ListTag.html">
    ListTag</a></code> class) creates the list. With the optional attributes
    <code>elementClass</code> or <code>elementClassName</code> the class of the
    single list elements can be specified. <code>&lt;di:element&gt;</code> tags
    in the body of the <code>&lt;di:list&gt;</code> tag define the list elements.
    They inherit the class of the elements, so that the string values in this
    example are automatically converted to integer values. The last
    <code>&lt;di:element&gt;</code> tag overrides this class using the
    <code>valueClassName</code> attribute - it produces a <code>Long</code> value.
  </p>
  <p>
    The <code>&lt;di:element&gt;</code> tag provides multiple ways to define the
    element to be added to the list. Full documentation is available at the
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/di/tags/ElementTag.html">
    ElementTag</a></code> class which implements this tag. Actually the tag
    supports the same options as the <code>&lt;di:setProperty&gt;</code> or the
    <code>&lt;di:param&gt;</code> tags. For instance, list elements can be defined
    as references to other beans, or by nested anonymous bean definitions. The
    following example shows some of these possibilities:
  </p>
    <source><![CDATA[
<di:bean name="listDependency" beanClassName="net.sf.jguiraffe.di.ReflectionTestClass">
  <di:setProperty property="data">
    <di:list>
      <di:element/>
      <di:element refName="intConst"/>
      <di:element>
        <di:bean beanClass="net.sf.jguiraffe.di.ReflectionTestClass"/>
      </di:element>
    </di:list>
  </di:setProperty>
</di:bean>
    ]]></source>
  <p>
    Here the first <code>&lt;di:element&gt;</code> tag is empty. It produces a
    <b>null</b> element that is added to the list. The second tag refers to the
    bean with the name <em>intConst</em>. The third one evaluates the nested
    bean declaration and creates another instance of the
    <code>ReflectionTestClass</code> class. If a <code>java.util.Set</code> is
    needed rather than a <code>java.util.List</code>, the declaration looks
    very similar: the <code>&lt;di:list&gt;</code> tag has to be replaced by
    the <code>&lt;di:set&gt;</code> tag:
  </p>
    <source><![CDATA[
<di:bean name="set" beanClassName="net.sf.jguiraffe.di.ReflectionTestClass">
  <di:setProperty property="data">
    <di:set elementClassName="java.lang.Integer">
      <di:element value="1"/>
      <di:element value="2"/>
      <di:element value="1000" valueClassName="java.lang.Long"/>
    </di:set>
  </di:setProperty>
</di:bean>
    ]]></source>
  <p>
    This example works analoguously to the first example for lists, just that a
    <code>java.util.HashSet</code> is created and populated by the
    <code>&lt;di:element&gt;</code> tags. The <code>&lt;di:set&gt;</code> tag
    supports an additional <code>ordered</code> attribute of type boolean. If
    set to <b>true</b>, the order of the elements added to the set is kept -
    in this case the tag creates a <code>java.util.LinkedHashSet</code> object
    rather than a <code>java.util.HashSet</code> instance:
  </p>
    <source><![CDATA[
<di:bean name="set" beanClassName="net.sf.jguiraffe.di.ReflectionTestClass">
  <di:setProperty property="data">
    <di:set elementClassName="java.lang.Integer" ordered="true">
      <di:element value="1"/>
      <di:element value="2"/>
      <di:element value="1000" valueClassName="java.lang.Long"/>
    </di:set>
  </di:setProperty>
</di:bean>
    ]]></source>
  <p>
    The definition of a map looks pretty similar. The <code>&lt;di:map&gt;</code>
    tag is used (implemented by the
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/di/tags/MapTag.html">
    MapTag</a></code> class) which supports optional attributes for specifying
    the class of the map's keys and values. Instead of the
    <code>&lt;di:element&gt;</code> tag the <code>&lt;di:entry&gt;</code> tag is
    used to define a key-value-pair to be added to the map:
  </p>
    <source><![CDATA[
<di:bean name="map" beanClassName="net.sf.jguiraffe.di.ReflectionTestClass">
  <di:setProperty property="data">
    <di:map keyClass="java.lang.String" valueClass="java.lang.Integer">
      <di:entry key="key1" value="1"/>
      <di:entry key="key2" value="2"/>
      <di:entry key="key3" value="1000" valueClass="java.lang.Long"/>
    </di:map>
  </di:setProperty>
 </di:bean>
    ]]></source>
  <p>
    This example creates a map with strings as keys and numbers as values. The
    default value class is <code>java.lang.Integer</code>, the last
    <code>&lt;di:entry&gt;</code> tag however produces a <code>java.lang.Long</code>
    object. <code>&lt;di:entry&gt;</code> can be used analogously to
    <code>&lt;di:element&gt;</code> to define complex values, e.g. by
    referencing other beans or by defining beans in the tag's body. Refer to the
    documentation for the
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/di/tags/EntryTag.html">
    EntryTag</a></code> class for a full list of all supported attributes. But
    what if the key of the entry is a complex object? In this case the
    <code>&lt;di:entryKey&gt;</code> tag can be used. It also supports all
    options of defining complex objects which then become the key of the entry.
    The following example demonstrates this. It creates a map with an entry
    whose key is a list and whose value is a set:
  </p>
    <source><![CDATA[
<di:bean name="mapcomplex" beanClassName="net.sf.jguiraffe.di.ReflectionTestClass">
  <di:setProperty property="data">
    <di:map ordered="true">
      <di:entry>
        <di:entryKey>
          <di:list elementClassName="java.lang.Integer">
            <di:element value="1"/>
            <di:element value="2"/>
            <di:element value="1000" valueClassName="java.lang.Long"/>
          </di:list>
        </di:entryKey>
        <di:set elementClassName="java.lang.Integer" ordered="true">
          <di:element value="1"/>
          <di:element value="2"/>
          <di:element value="1000" valueClassName="java.lang.Long"/>
        </di:set>
      </di:entry>
    </di:map>
  </di:setProperty>
</di:bean>
    ]]></source>
  <p>
    As is true for the  <code>&lt;di:set&gt;</code> tag, <code>&lt;di:map&gt;</code>
    supports the <code>ordered</code> attribute. If set to <b>true</b>, a
    <code>java.util.LinkedHashMap</code> is created which keeps track of the
    order in which entries have been added.
  </p>
  <p>
    Finally, there is a special tag for defining <code>java.util.Properties</code>
    objects. Properties objects are similar to maps, but both keys and values
    are strings. The definition of a <code>Properties</code> object is almost
    identical to the definition of a map: only the <code>&lt;di:map&gt;</code>
    tag has to be replaced by the <code>&lt;di:properties&gt;</code> tag:
  </p>
    <source><![CDATA[
<di:bean name="properties" beanClassName="net.sf.jguiraffe.di.ReflectionTestClass">
  <di:setProperty property="data">
    <di:properties>
      <di:entry key="db.usr" value="scott"/>
      <di:entry key="db.pwd" value="tiger"/>
      <di:entry key="db.src" value="defaultDS"/>
    </di:properties>
  </di:setProperty>
</di:bean>
    ]]></source>
  <p>
    <a name="Complex_string_values"/><strong>Complex string values</strong>
  </p>
  <p>
    When string values have to be passed to constructors or properties, so far
    we have used the <code>value</code> attribute of the <code>&lt;param&gt;</code>
    or <code>&lt;setProperty&gt;</code> tag for this purpose. This works fine
    for simple strings, but fails if the strings are longer and should span
    multiple lines. In this case the <code>&lt;value&gt;</code> tag (implemented
    by the <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/di/tags/ValueTag.html">
    ValueTag</a></code> class) can be used. <code>&lt;value&gt;</code> tag
    obtains the string value from its body which can become arbitrary complex.
    It is recommended to put the body in a <em>CDATA</em> section so that
    special characters can be used without quoting. The following example passes
    a string as constructor parameter that spans multiple lines:
  </p>
    <source>
&lt;di:bean name=&quot;valueTest&quot; beanClass=&quot;net.sf.jguiraffe.di.ReflectionTestClass&quot;&gt;
  &lt;di:constructor&gt;
    &lt;di:param&gt;
      &lt;di:value&gt;&lt;![CDATA[Line 1
Line 2
Line 3]]&gt;&lt;/di:value&gt;
      &lt;/di:param&gt;
    &lt;/di:constructor&gt;
  &lt;/di:bean&gt;
    </source>
  <p>
    <a name="Complex_initializations"/><strong>Complex initializations</strong>
  </p>
  <p>
    We have now discussed the most frequently used methods of defining beans
    using the tags of the dependency injection library. With these tags it
    should be possible to realize most of the use cases related to the creation
    of objects. For complex scenarios, for which these tags are not sufficient,
    there are some so-called <em>invocation</em> tags that allow invoking
    arbitrary methods on objects. If these tags are used, temporary objects can
    be created and stored in a local context that is valid during the processing
    of the nesting <code>&lt;di:bean&gt;</code> tag. Other tags, like
    <code>&lt;di:setProperty&gt;</code> or <code>&lt;di:param&gt;</code> can
    access these temporary objects. We provide an example that creates and
    initializes a <code>ReflectionTestClass</code> instance in a complicated way:
  </p>
    <source><![CDATA[
<di:bean name="initializer" singleton="false"
  beanClass="net.sf.jguiraffe.di.ReflectionTestClass">
  <di:constructorInvocation targetClassName="java.lang.StringBuilder"
    result="buf"/>
  <di:methodInvocation method="append" source="buf">
    <di:param parameterClass="java.lang.String" refName="strConst"/>
  </di:methodInvocation>
  <di:methodInvocation method="append" source="buf">
    <di:param parameterClass="java.lang.String" refName="strConst"/>
  </di:methodInvocation>
  <di:methodInvocation method="toString" source="buf" result="s"/>
  <di:setProperty property="stringProp" var="s"/>

  <di:methodInvocation method="valueOf" targetClass="java.math.BigInteger"
    static="true" result="i1">
    <di:param refName="intConst"/>
  </di:methodInvocation>
  <di:constructorInvocation targetClass="java.math.BigInteger" result="i2">
    <di:param value="2"/>
  </di:constructorInvocation>
  <di:methodInvocation method="multiply" source="i1" result="product">
    <di:param var="i2"/>
  </di:methodInvocation>
  <di:methodInvocation method="intValue" source="product" result="i"/>
  <di:setProperty property="intProp" var="i"/>
</di:bean>
    ]]></source>
  <p>
    What happens here? A set of <code>&lt;di:constructorInvocation&gt;</code>
    and <code>&lt;di:methodInvocation&gt;</code> tags is used for creating and
    manipulating some temporary objects which are eventually passed to properties
    of the bean created by the whole fragment. Note the special attributes of
    these tags:
    <ul>
      <li><code>source</code> defines the name of the temporary object on which
      a method is to be invoked.</li>
      <li><code>result</code> specifies the name under which the result of a
      method invocation is stored in the temporary context. With other words,
      this creates a kind of variable.</li>
    </ul>
    The example fragment uses the <code>&lt;di:constructorInvocation&gt;</code>
    tag to create a new instance of <code>java.lang.StringBuilder</code> and
    stores it as a temporary object under the name <em>buf</em>. Then, using the
    <code>&lt;di:methodInvocation&gt;</code> tag, the <code>append()</code>
    method is invoked twice on this object passing in the bean with the name
    <em>strConst</em>. After that the content of the <code>StringBuilder</code>
    is transformed into a string by calling the <code>toString()</code> method
    and stored under the name <em>s</em>.
  </p>
  <p>
    The next series of invocations creates two instances of
    <code>java.math.BigInteger</code>, one by invoking the static
    <code>valueOf()</code> method and one by calling a constructor. Then the
    product of these objects is created by invoking the <code>multiply()</code>
    method and stored under the name <em>product</em>. Finally the product is
    transformed into an integer object by invoking the <code>intValue()</code>
    method on it. <code>&lt;di:setProperty&gt;</code> tags are used to pass the
    results of these operations to properties of the newly created bean.
  </p>
  <p>
    Well, this is certainly complex stuff, and we do not encourage such a
    programming style. It is obvious that such scripts are hard to understand
    and maintain. However, if you are forced to deal with legacy code, you might
    have no other option than performing complex method invocations in builder
    scripts. The last example shows that you can do so using the dependency
    injection tag library. For a full documentation of the invocation tags
    refer to the classes
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/di/tags/ConstructorInvocationTag.html">
    ConstructorInvocationTag</a></code> and
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/di/tags/MethodInvocationTag.html">
    MethodInvocationTag</a></code>.
  </p>
  <p>
    <a name="Builder_classes"/><strong>Builder classes</strong>
  </p>
  <p>
    If a class supports a bunch of configuration options which should be set at
    construction time, you may end up with a large number of different
    constructors: each constructor expects a specific set of configuration
    options while the remaining ones are set to default values. This allows a
    client to concentrate on the options of interest ignoring any others.
  </p>
  <p>
    In such a scenario, a <em>builder approach</em> (not to be confused with the
    <em>JGUIraffe</em> builder scripts!) can be beneficial. Rather than providing
    many constructors, the class in question provides a specific builder class.
    The builder is instantiated and populated with the required options. Often
    this can be done through a fluent API which simplifies the usage of the
    builder for clients. Eventuelly, the builder creates an instance of its
    associated class based on the properties set so far. Typically, the class
    only provides a private constructor so that the builder is the only
    possibility to create instances.
  </p>
  <p>
    An example of a class which provides a builder is
    <code>BasicThreadFactory</code> from the
    <a href="http://commons.apache.org/lang">Apache Commons Lang</a> project.
    The builder allows setting options like a naming pattern, a priority, or
    the daemon flag for the threads to be created by the factory. The following
    code fragment shows how this looks like in practice:
  </p>
    <source><![CDATA[
 BasicThreadFactory factory = new BasicThreadFactory.Builder()
     .namingPattern("factory_thread-%d")
     .daemon(true)
     .build();
     ]]></source>
  <p>
    While builders can be used elegantly from Java code, they are problematic
    for dependency injection frameworks. First an object of a different class
    than the actual bean class has to be created, then methods have to be called
    on it, and finally the result of the <code>build()</code> method must be
    used as the resulting bean. With the features introduced in the previous
    section you know how objects can be created and manipulated within complex
    builder scripts. The only missing piece is that you somehow have to tell the
    framework to use the result of a method invocation as resulting bean. This
    can be achieved by using the <em>resultVar</em> attribute of the
    <code>&lt;di:bean&gt;</code> tag. It tells the tag that it does not have to
    create a bean on its own, but use an object from a local variable of the
    initializer script instead. Below is an example which corresponds to the
    Java code presented above:
  </p>
    <source><![CDATA[
<di:bean name="threadFactory" resultVar="factory"
  beanClass="java.util.concurrent.ThreadFactory">
  <di:constructorInvocation result="builder"
    targetClassName="org.apache.commons.lang3.concurrent.BasicThreadFactory$Builder"/>
  <di:methodInvocation method="namingPattern" source="builder">
    <di:param value="factory_thread-%d"/>
  </di:methodInvocation>
  <di:methodInvocation method="daemon" source="builder">
    <di:param value="true"/>
  </di:methodInvocation>
  <di:methodInvocation method="build" source="builder" result="factory">
  </di:methodInvocation>
</di:bean>
     ]]></source>
  <p>
    Here a new instance of the nested <code>Builder</code> class is created
    using a <code>&lt;di:constructorInvocation&gt;</code> tag and stored in a
    local variable named <em>builder</em> (using the <code>result</code>
    attribute). Then on this object multiple methods are invoked. The last
    method call is to the <code>build()</code> method, and its result is stored
    in the <em>factory</em> variable. Note that this name is also used in the
    <code>resultVar</code> attribute of the <code>&lt;di:bean&gt;</code> tag;
    this establishes the connection to the tag's managed bean. Note also that
    on the embedding <code>&lt;di:bean&gt;</code> tag the <code>beanClass</code>
    attribute is defined. Defining the class of the resulting bean at this place
    is not strictly necessary for the correct creation of the bean. However, it
    allows the tag to correctly answer queries about the class of its managed
    bean, even if the bean has not yet been created. If the attribute was
    ommitted, querying the <code>BeanContext</code> for a bean of this class
    would fail. Therefore, the bean class should always be specified if the
    <code>resultVar</code> attribute is used.
  </p>
  <p>
    <a name="Factory_beans"/><strong>Factory beans</strong>
  </p>
  <p>
    Another use case for complex initialization scripts are <em>factory
    beans</em>: In cases when the creation of an object requires complex logic,
    it makes sense to extract this logic in a specific factory class. In order
    to create an instance of the original class, a reference to the factory
    object has to be obtained, and a specific creation method has to be invoked
    on it.
  </p>
  <p>
    The <em>factory beans</em> use case is similar to the problem with
    <a href="#Builder_classes">Builder classes</a>, but while a builder instance
    was created and stored in a variable local to the initialization script, we
    now have to reference another bean declared in the builder script. For this
    purpose, the dependency injection tag library provides the
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/di/tags/InvocationTargetTag.html">
    InvocationTargetTag</a></code> tag. The tag can appear in the body of a
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/di/tags/MethodInvocationTag.html">
    MethodInvocationTag</a></code> and references the target bean of the method
    invocation. It supports the possible dependencies as described in the
    section <a href="#Dependencies">Dependencies to other beans</a>. Below is
    an example which invokes the method <code>create()</code> on a bean with
    the name <em>factoryBean</em>:
  </p>
    <source><![CDATA[
<di:bean name="factoryBeanInvocation" resultVar="result">
  <di:methodInvocation method="create" result="result">
    <di:param value="someParameterValue"/>
    <di:invocationTarget refName="factoryBean"/>
  </di:methodInvocation>
</di:bean>
     ]]></source>
  <p>
    The <code>&lt;di:bean&gt;</code> tag again has the <code>resultVar</code>
    attribute to point to the local variable in which the result of the method
    invocation is stored. As you can see, it is possible to pass parameters to
    the method of the factory bean in the usual way.
  </p>
  </subsection>

  <subsection name="Advanced topics">
  <p>
    With the tags introduced so far complex bean definitions can be realized. In
    this section we discuss some edge cases of dependency management and provide
    some information about enhanced functionality which can be useful in special
    use cases.
  </p>
  <p>
    <a name="Cyclic_dependencies"/><strong>Cyclic dependencies</strong>
  </p>
  <p>
    When a bean is defined using the tags of the dependency injection framework
    all its dependencies can be declared. When this bean is requested from a
    <code>BeanContext</code> the dependent beans are resolved and are also
    created. If these beans declare additional dependencies, this can lead to a
    chain of beans being created. Problems can occur if cyclic dependencies
    occur. In the most simple case the cycle consists only of two beans
    referencing each other as shown in the following picture:
  </p>
  <img src="../images/userguide/CyclicDependency.png" alt="Cyclic dependency"/>
  <p>
    Here bean A has a dependency to bean B and vice versa. In more complex
    scenarios the cycle can span multiple beans, e.g. bean A depends on bean B
    which depends on bean C which again depends on bean A. Whether this causes a
    problem or not depends on the way the dependencies are passed.
    Consider the following bean declarations:
  </p>
    <source><![CDATA[
<!-- Cyclic dependencies! Does not work! -->
<di:bean name="beanA" beanClassName="net.sf.jguiraffe.test.BeanA">
  <di:constructor>
    <di:param refName="beanB"/>
  </di:constructor>
</di:bean>

<di:bean name="beanB" beanClassName="net.sf.jguiraffe.test.BeanB">
  <di:constructor>
    <di:param refName="beanA"/>
  </di:constructor>
</di:bean>
    ]]></source>
  <p>
    Here it is tried to pass the beans to each other using the constructors. In
    this scenario it is impossible to find a working order in which the beans
    can be created: for the creation of bean A bean B must be available and vice
    versa. Because of this the framework gives up and throws an exception.
  </p>
  <p>
    To work around this problem a valid order has to be found in which the beans
    can be created thus breaking the cycle. This can be achieved if one of the
    beans is not passed as constructor argument, but as a property as in the
    following example:
  </p>
    <source><![CDATA[
<!-- Cyclic dependencies! This works. -->
<di:bean name="beanA" beanClassName="net.sf.jguiraffe.test.BeanA">
  <di:constructor>
    <di:param refName="beanB"/>
  </di:constructor>
</di:bean>

<di:bean name="beanB" beanClassName="net.sf.jguiraffe.test.BeanB">
  <di:setProperty property="breference" refName="beanA"/>
</di:bean>
    ]]></source>
  <p>
    The framework is able to separate the creation of beans from their
    initialization. In this case it detects that there is still a cyclic
    dependency between the beans A and B. For the creation of bean A bean B is
    required. But bean B can be created without any dependencies (through its
    default constructor). So the framework creates bean B first, but defers its
    initialization (the set property operation). Then bean A can be created; it
    is passed the (so far not completely initialized) reference to bean B.
    Finally, the initialization of bean B can be completed because now bean A is
    available.
  </p>
  <p>
    So the framework is usually smart enough to find a working creation order of
    dependent beans if possible. However, in this case the beans must be aware
    that the references passed to them may be only partly initialized. Only after
    the whole graph of beans has been created initialization is complete. This
    also works if the cycle contains more than two dependent beans.
  </p>
  <p>
    <a name="Singleton_nonsingleton_dependencies"/><strong>Dependencies between singleton and non-singleton beans</strong>
  </p>
  <p>
    If singleton beans have dependencies to non-singleton beans or vice versa,
    it may not always be obvious when and how many instances of the beans
    invloved are created. This sub section discusses some scenarios. We start
    with some simple cases. First imagine a singleton bean that references a
    non-singleton bean (<em>Note:</em> in this diagram and the following ones
    singleton beans are marked with a small &quot;S&quot; icon):
  </p>
  <img src="../images/userguide/SingletonNonSingleton.png"
    alt="Singleton bean references non-singleton"/>
  <p>
    When the singleton bean <em>A</em> is accessed the first time, it is created
    and initialized. In this process also a new instance of the non-singleton
    bean <em>B</em> is created and passed to the new <em>A</em> instance. Because
    <em>A</em> is a singleton, the instance is then cached and directly returned
    if bean <em>A</em> is requested again. Thus the reference to bean <em>B</em>
    remains constant, and only a single instance of this bean is created (at
    least as bean <em>A</em> is concerned).
  </p>
  <p>
    Next let us have a look at the opposite scenario: a non-singleton bean has
    a dependency to a singleton bean:
  </p>
  <img src="../images/userguide/NonSingletonSingleton.png"
    alt="Non-singleton bean references singleton"/>
  <p>
    Now each access to bean <em>B</em> creates a new instance. Because bean
    <em>A</em> is a singleton, only a single instance of this bean is created.
    So all the different instances of bean <em>B</em> have the same reference
    to bean <em>A</em>.
  </p>
  <p>
    So far there was no big surprise. Things become more complicate when
    multiple bean declarations are involved. Have a look at the following
    figure:
  </p>
  <img src="../images/userguide/NonSingletonMultiDep.png"
    alt="Multiple dependencies"/>
  <p>
    When bean <em>A</em> is created the dependent beans <em>B</em> and <em>C</em>
    must be created, too. Both are non-singletons. Bean <em>C</em> also has a
    dependency to bean <em>B</em>. So how many instances of bean <em>B</em> are
    created? The answer is: only one, i.e. bean <em>A</em> and bean <em>C</em>
    share the same reference to bean <em>B</em>. When a bean is requested from
    a <code>BeanContext</code> all steps necessary to create this bean and all
    of its dependencies run in a kind of transaction. During this transaction
    only one instance of non-singleton beans is created. So if a non-singleton
    bean is referenced by multiple beans that are involved in a transaction, all
    these beans are initialized with the same reference.
  </p>
  <p>
    <a name="Bean_creation_listeners"/><strong>Bean creation listeners</strong>
  </p>
  <p>
    The <code><a href="../apidocs/net/sf/jguiraffe/di/BeanContext.html">BeanContext
    </a></code> interface defines methods for adding and removing an object of
    type <code><a href="../apidocs/net/sf/jguiraffe/di/BeanCreationListener.html">
    BeanCreationListener</a></code>. A <code>BeanCreationListener</code> is
    notified whenever a bean is created. Note that this does not mean for every
    request of a bean, but only if a new instance of this bean is actually created,
    the listener is triggered. For a singleton bean the listener is invoked only
    once; for non-singleton beans it is called each time an instance is
    requested.
  </p>
  <p>
    When a bean is created the <code>beanCreated()</code> method of the listener
    is called. This method is passed a
    <code><a href="../apidocs/net/sf/jguiraffe/di/BeanCreationEvent.html">
    BeanCreationEvent</a></code> object that contains information about the
    newly created bean. This includes of course the new instance of the bean,
    but also some internal helper objects involved in the bean creation
    process (refer to the Javadocs for more information).
  </p>
  <p>
    So what is the purpose of a <code>BeanCreationListener</code>? Such listeners
    come in handy if a bean needs information which is not available at
    configuration time, but only at application runtime. In this case a
    <code>BeanCreationListener</code> can intercept the bean creation process
    and provide the additional information. At the time the listener is called
    the bean has already been fully initialized according to its configuration.
    The listener only has to add the missing initialization.
  </p>
  <p>
    As a concrete example consider a bean that needs to call a service for which
    user credentials are required, e.g. a web service or a database connection.
    For security reasons you do not want to store these credentials in a
    configuration file. One solution is to ask the user for the credentials and
    then use a <code>BeanCreationListener</code> to pass this data to the
    service bean when it is created.
  </p>
  <p>
    As was said before, a <code>BeanCreationListener</code> can be added manually
    to a <code>BeanContext</code> by calling the <code>addBeanCreationListener()</code>
    method. If a standard builder is used (rather than a
    <code>BeanBuilder</code>), listeners can also be added to the
    <code><a href="../apidocs/net/sf/jguiraffe/gui/app/ApplicationBuilderData.html">
    ApplicationBuilderData</a></code> object obtained from the
    <code>ApplicationContext</code> before it is passed to the builder. This has
    the advantage that the listeners are immediately active; they are then also
    triggered for beans created during the builder operation.
  </p>
  <p>
    <a name="Class_loader_issues"/><strong>Class loader issues</strong>
  </p>
  <p>
    Many tags of the dependency injection tag library have attributes which
    expect classes or class names. For instance, the <code>&lt;di:bean&gt;</code>
    tag has the <code>beanClass</code> attribute for specifying the class of the
    bean to be created; the <code>&lt;di:param&gt;</code> tag supports setting
    the parameter class; tags that allow setting a value also offer a means to
    define the value class.
  </p>
  <p>
    What was not explained so far is the fact that all these attributes come in
    multiple variants. The most basic variant ends of the name &quot;Class&quot;,
    e.g. <code>beanClass</code>, <code>valueClass</code>, or
    <code>targetClass</code>. These attributes work internally by using standard
    means provided by Jelly to load the corresponding <code>Class</code>
    object. This is appropriate for many desktop applications, but may fail in
    certain environments with multiple class loaders involved, e.g. in an OSGi
    container.
  </p>
  <p>
    Therefore affected tag handler classes provide an alternative way to define
    classes. In addition to the attributes ending on &quot;Class&quot;, there
    are corresponding attributes with the suffixes &quot;ClassName&quot;, and
    &quot;ClassLoader&quot;, e.g. <code>beanClassName</code> and
    <code>beanClassLoader</code>. The &quot;ClassName&quot; attribute gets passed
    the fully-qualified name of the desired Java class. This looks exactly the
    same as for the &quot;Class&quot; attribute, but internally a different
    mechanism is used to resolve the class name: Instead of using a default
    class loader, the class loader to be used can be specified by the
    &quot;ClassLoader&quot; attribute. This works as follows:
  </p>
  <p>
    When calling the builder a
    <code><a href="../apidocs/net/sf/jguiraffe/di/ClassLoaderProvider.html">
    ClassLoaderProvider</a></code> object can be specified. If the bean builder
    is used, the <code>ClassLoaderProvider</code> is passed as an argument to
    the <code>build()</code> method. Otherwise, it is obtained from the parent
    <code>BeanContext</code>, which is a property of the
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/BuilderData.html">
    BuilderData</a></code> object. The <code>ClassLoaderProvider</code> interface
    defines a method that returns a class loader for a given symbolic name. If
    the &quot;ClassName&quot; attribute is used, the tags check whether the
    &quot;ClassLoader&quot; attribute is specified, too. In this case, the class
    is not resolved using the default class loader, but the
    <code>ClassLoaderProvider</code> is asked for a class loader with the
    symbolic name provided by the &quot;ClassLoader&quot; attribute. So it is
    possible to define an arbitrary class loader for resolving a class name. The
    following example shows how this mechanism is used in practice to obtain the
    class of a bean to be created from a specific class loader:
  </p>
    <source><![CDATA[
<di:bean name="myBean" beanClassName="com.mypackage.MyBeanClass"
  beanClassLoader="specialClassLoader">
</di:bean>
    ]]></source>
  <p>
    In this example the class loader registered for the name
    <em>specialClassLoader</em> is used to load the class
    <code>com.mypackage.MyBeanClass</code>. For this to work the class loader
    with the name <em>specialClassLoader</em> must be known to the
    <code>ClassLoaderProvider</code>. The <code>ClassLoaderProvider</code>
    interface has a <code>registerClassLoader()</code> method which can be used
    to register class loaders under symbolic names. A good place to register
    application-specific class loaders is the <code>initClassLoaderProvider()</code>
    method of the central
    <code><a href="../apidocs/net/sf/jguiraffe/gui/app/Application.html">Application
    </a></code> class. This method is automatically called during application
    startup. It is passed the default <code>ClassLoaderProvider</code> which is
    used by all builder operations (unless an application overrides this default).
  </p>
  <p>
    If an application has very specific requirements for loading classes, it can
    implement its own <code>ClassLoaderProvider</code>. In this case it may make
    sense to extend the default implementation,
    <code><a href="../apidocs/net/sf/jguiraffe/di/impl/DefaultClassLoaderProvider.html">
    DefaultClassLoaderProvider</a></code>. All class loader providers should
    support a special class loader with the symbolic name <em>CONTEXT</em>: if
    this name is passed, the context class loader for the current thread should
    be returned. This reserved name can also be used in tags to select the
    context class loader for resolving a class:
  </p>
    <source><![CDATA[
<di:bean name="myBean" beanClassName="com.mypackage.MyBeanClass"
  beanClassLoader="CONTEXT">
</di:bean>
    ]]></source>
  <p>
    The <code>ClassLoaderProvider</code> interface also provides a means to set
    a default class loader name. The class loader registered with this name is
    always used if the &quot;ClassLoader&quot; attribute is missing. This can be
    useful if most of the classes should be loaded by a specific class loader. To
    enable this feature, the best way is again to override the
    <code>initClassLoaderProvider()</code> method of <code>Application</code>.
    Here the <code>setDefaultClassLoaderName()</code> method of the
    <code>ClassLoaderProvider</code> object has to be called. The method expects
    a string parameter representing the name of the class loader to be used as
    default class loader. A class loader with this name must have been
    registered unless it is the reserved name <em>CONTEXT</em> referring to the
    context class loader. For some applications it may be indeed a good
    strategy to set the context class loader as default class loader.
  </p>
  <p>
    As a general recommendation, for applications that work with multiple class
    loaders it is a good approach to avoid the &quot;Class&quot; attributes and
    use the &quot;ClassName&quot; attributes instead. The
    <code>ClassLoaderProvider</code> should be configured so that the
    <code>defaultClassLoaderName</code> property is set to the name of the
    class loader which is used most frequently. Then the &quot;ClassLoader&quot;
    attributes can be omitted in most cases because the default class loader is
    selected automatically. For classes to be resolved by a different class
    loader &quot;ClassLoader&quot; attributes have to be specified accordingly.
  </p>
  <p>
    <a name="Releasing_resources"/><strong>Releasing resources</strong>
  </p>
  <p>
    After a successful builder operation the application can access the
    resulting <code>BeanContext</code> and query beans. This causes beans to be
    created and - if singleton beans are involved - cached by the context. Some
    beans may acquire resources when they are created. If they are no longer
    used, these resources should be released. For instance, a bean representing
    a database connection should close this connection if it is no more needed.
  </p>
  <p>
    The <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/BeanBuilder.html">
    BeanBuilder</a></code> interface defines a <code>release()</code> method
    which can be called with a
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/BeanBuilderResult.html">
    BeanBuilderResult</a></code> object when beans produced by the corresponding
    builder operation can be freed. This ensures that all cached beans are
    released.
  </p>
  <p>
    In order to actually release resources occupied by beans, a <em>shutdown
    handler</em> can be defined in the bean declaration. A shutdown handler is
    defined using the <code>&lt;di:shutdown&gt;</code> tag. In the body of this
    tag arbitrary method invocation tags can be placed that are executed on
    shutdown (i.e. when the <code>BeanBuilderResult</code> is released). The
    following code fragment shows an example:
  </p>
    <source><![CDATA[
<di:bean name="shutdownMeth" beanClass="net.sf.jguiraffe.di.ReflectionTestClass">
  <di:shutdown>
    <di:methodInvocation method="shutdown"/>
  </di:shutdown>
</di:bean>
    ]]></source>
  <p>
    Actually, the body of a <code>&lt;di:shutdown&gt;</code> tag can become
    pretty complex. All tags can be placed here that can also be used to
    initialize a bean. Refer to the section
    <a href="#Complex_initializations">Complex initializations</a> for more
    examples. This includes tags for setting properties. The next example
    defines a shutdown handler which resets some properties of the bean when it
    is invoked:
  </p>
    <source><![CDATA[
<di:bean name="shutdown" beanClass="net.sf.jguiraffe.di.ReflectionTestClass">
  <di:setProperty property="intProp" refName="intConst"/>
  <di:setProperty property="stringProp" refName="strConst"/>
  <di:shutdown>
    <di:setProperty property="intProp" value="0" valueClass="java.lang.Integer"/>
    <di:setProperty property="stringProp"><di:null/></di:setProperty>
  </di:shutdown>
</di:bean>
    ]]></source>
  <p>
    As was already stated under <a href="#Complex_initializations">Complex
    initializations</a>, this feature should not be overused. Invoking a single
    shutdown method is fine, but writing complex shutdown scripts makes it hard
    to understand what happens at shutdown. Note that shutdown handlers are only
    supported for singleton beans. This is because only singleton beans are
    under the control of the dependency injection framework. From non-singleton
    beans an arbitrary number of instances can be created, and the framework has
    no chance to know when these instances are no longer needed.
  </p>
  <p>
    We have explained how the results of a builder operation can be released.
    But when should the builder's <code>release()</code> method be called? If
    the bean builder is used directly, the developer is always responsible to
    call the <code>release()</code> method at the correct point of time. The
    advanced UI builders in contrast offer a convenience mechanism:
  </p>
  <p>
    If the builder script defines a window, the framework can automatically
    register a specialized window event listener at this window. This listener
    will call the <code>release()</code> method when the window is closed. This
    mechanism assumes that all beans and resources are connected to the
    window object - which is typically the case in <em>JGUIraffe</em>
    applications; a builder script typically defines a window and its controls
    plus the beans needed by these graphical elements. As soon as the window
    becomes unavailable, all associated resources can be released. Whether the
    framework should register this special window listener or not is determined
    by the <code>isAutoRelease()</code> property of the
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/BuilderData.html">
    BuilderData</a></code> object passed to the builder. It is set to
    <b>true</b> per default.
  </p>
  <p>
    <a name="matching_and_conversions"/>
    <strong>Parameter matching and data type conversions</strong>
  </p>
  <p>
    Throughout this chapter there have been lots of examples of bean
    declarations using constructors, set property operations, or method calls
    for initializing data fields of the objects to be constructed. To
    recapitulate, here is a typical code fragment defining a bean by calling its
    constructor:
  </p>
    <source><![CDATA[
<di:bean name="constructor"
  beanClassName="net.sf.jguiraffe.di.ReflectionTestClass">
  <di:constructor>
    <di:param parameterClass="java.lang.String" value="test string"/>
    <di:param value="42"/>
  </di:constructor>
</di:bean>
    ]]></source>
  <p>
    This code snippet is pretty simple, but it raises some questions which have
    not yet been addressed:
    <ul>
      <li>The second constructor parameter is of type <code>int</code>. How
      does the framework know this?</li>
      <li>What if there are multiple constructors with similar parameter lists?
      How is the correct one identified?</li>
    </ul>
  </p>
  <p>
    These questions are closely related as we will see soon. To answer them we
    have to explain the algorithm used by the dependency injection framework to
    determine the constructor to call (the same algorithm is also applied to
    method invocations, so everything we say about constructors can be
    transferred to method invocations as well).
  </p>
  <p>
    When a bean declaration contains a constructor invocation the framework
    tries to be clever to find the desired constructor. It iterates over all
    constructors provided by the target class and searches for a unique match.
    This works well if all constructors have a different number of parameters or
    some constructors can be sorted out based on the passed in arguments (for
    instance, passing a <b>null</b> value for a primitive parameter is not
    allowed). If at the end of the iteration only a single candidate is found,
    everything is fine.
  </p>
  <p>
    However, if there are multiple constructors with similar parameter lists, it
    might not be possible to find a unique match. For instance, if the following
    additional constructor was added to the <code>ReflectionTestClass</code>
    class:
  </p>
    <source><![CDATA[
public ReflectionTestClass(Object obj, int i)
{
    this(i);
    data = obj;
}
    ]]></source>
  <p>
    the arguments <em>test string</em> and <em>42</em> could be passed to
    both of them. Actually, in this case the framework is not able to process
    the bean declaration and throws an exception. There are two options to solve
    this problem:
    <ul>
      <li>The <code>&lt;di:param&gt;</code> tag provides the
      <code>parameterClass</code> attribute. It tells the framework that this
      parameter is of the specified type. In this example, we could add a
      <code>parameterClass</code> attribute to the first
      <code>&lt;di:param&gt;</code> tag and set it to
      <code>java.lang.String</code>. This is sufficient to uniquely identify the
      desired constructor because there is only one constructor with two
      arguments whose first argument is of type String.</li>
      <li>Alternatively, there is also a <code>valueClass</code> attribute. This
      attribute instructs the framework to directly convert the specified value
      to the given type. This also influences the search for a matching
      constructor because if no unique match is found, the framework checks the
      types of the arguments; from these types it may be able to exclude some of
      the constructors.</li>
    </ul>
  </p>
  <p>
    If everything works fine, there is only a single matching constructor. From
    the parameter list of this constructor the framework can detect the types of
    the expected arguments and compare them with the types of the passed in
    parameters. Because bean declarations are written in XML all parameters are
    initially strings. Using the <code>valueClass</code> attribute a conversion
    can be explicitly requested, so that the corresponding parameter already has
    the desired data type. For all other parameters the framework tries an
    implicit conversion to the data type specified by the constructor parameter.
    So here is the magic which automatically transforms the string <em>42</em>
    to an integer.
  </p>
  <p>
    <em>As a side note: When should I use </em>parameterClass<em> and when
    </em>valueClass<em>?</em>
    In most cases, <code>parameterClass</code> is the option of choice. The goal is
    to give the framework a hint, which constructor to select. This is best
    achieved by providing enough <code>parameterClass</code> attributes so that
    a single constructor can be identified. You do not have to specify the type
    for all parameters, you only have to provide sufficient information that one
    constructor can be uniquely identified. The <code>valueClass</code>
    attribute is useful in cases where the actual parameter should be of a
    different (but of course compatible) type than the declared parameter. An
    example could be that the parameter type is an interface or an abstract base
    class. Then, with the <code>valueClass</code> attribute a concrete
    implementation class can be specified.
  </p>
  <p>
    As was already stated, constructors were used as an example only. The same
    rules apply for method invocations and property set operations. For instance,
    if there is a bean declaration like the following one:
  </p>
    <source><![CDATA[
<di:bean name="property"
  beanClassName="net.sf.jguiraffe.di.ReflectionTestClass">
  <di:setProperty property="intProp" value="42"/>
</di:bean>
    ]]></source>
  <p>
    the framework can detect the correct data type of the property and perform a
    type conversion as necessary. For method invocations the situation is often
    easier than for constructors because in most cases there is only a single
    method with a given name. Hence, there is no problem with finding the
    correct method to invoke. Only if there are overloaded methods, ambiguities
    might occur which have to be resolved by specifying
    <code>parameterClass</code> attributes as necessary.
  </p>
  <p>
    So in a nutshell, the following rules apply for matching constructors,
    methods, or properties:
    <ul>
      <li>The framework tries to find a unique match based on the number and
      types of the passed in arguments.</li>
      <li>If there are ambiguities, e.g. caused by constructors or overloaded
      methods with similar parameter types, the developer has to provide
      hints to the framework in form of <code>parameterClass</code> attributes
      to ensure that only a single match is found.</li>
      <li>Before the operation is actually executed the parameters are checked
      for compatibility with the declared parameters and are converted if
      necessary.
      </li>
    </ul>
  </p>
  <p>
    This algorithm is usually clever enough to find the correct constructor or
    method to be invoked so that the developer does not have to care. Only if
    exceptions are thrown because no unique match can be found,
    <code>parameterClass</code> attributes have to be added to resolve
    ambiguities. In the next sub section we will see which data type conversions
    are supported.
  </p>
  <p>
    <a name="type_converters"/><strong>Data type converters</strong>
  </p>
  <p>
    In the previous sub section it was stated that data type conversions of
    constructor or method arguments or properties are automatically performed as
    necessary. Of course, data type conversion is a complicated topic, and the
    framework is not able to perform arbitrary conversions. In the following we
    explain the basics and limitations of the data type converter subsystem.
  </p>
  <p>
    Behind the scenes the <a href="http://commons.apache.org/beanutils">Commons
    BeanUtils</a> library is used for type conversions. <em>BeanUtils</em>
    provides some utility classes dealing with conversion issues and a number of
    default converters that can handle standard Java data types like primitives
    or date and time. These default converters are active per default and are
    applied to the values specified in bean declarations. Therefore beans
    defining only properties of basic types should work out of the box.
  </p>
  <p>
    The dependency injection framework adds a few extensions to the
    default converters provided by the <em>BeanUtils</em> library:
    <ul>
      <li>There is a generic converter that can deal with <b>enum</b> classes.
      If the property of a bean is of an <b>enum</b> type, you just have to
      write the name of the corresponding constant in the bean declaration. This
      is best explained using an example. Consider the following declaration of
      an <b>enum</b> class:
    <source><![CDATA[
public enum Mode
{
    DEVELOPMENT, TEST, PRODUCTION, CRITICAL
}
    ]]></source>
      Now our standard test class for reflection operations is given a property
      of this <b>enum</b> class:
    <source><![CDATA[
private Mode mode;

public Mode getMode()
{
    return mode;
}

public void setMode(Mode mode)
{
    this.mode = mode;
}
    ]]></source>
      A bean declaration setting this property simply looks as follows:
    <source><![CDATA[
<di:bean name="enumProperty"
  beanClassName="net.sf.jguiraffe.di.ReflectionTestClass">
  <di:setProperty property="mode" value="PRODUCTION"/>
</di:bean>
    ]]></source>
      </li>
      <li>
        For some UI-related helper classes or other framework classes provided
        by the <em>JGUIraffe</em> library special converters are available. We
        will mention them in later chapters when we come to these classes.
      </li>
    </ul>
  </p>
  <p>
    Data type converters in <em>Commons BeanUtils</em> must implement the
    <code>org.apache.commons.beanutils.Converter</code> interface. This
    interfaces defines only a single method:
  </p>
    <source><![CDATA[
Object convert(Class type, Object value);
    ]]></source>
  <p>
    <code>convert()</code> is passed the desired target class and the object to
    be converted. It can perform arbitrary work to convert the given object to
    an instance of the target class. If this is not possible, a
    <code>ConversionException</code> can be thrown. In most cases the passed in
    object will be a String because it stems from the XML bean declaration. So
    writing a custom data type converter is no rocket science. You may also have
    a look at examples in the <em>JGUIraffe</em> source code, for instance,
    there is the
    <code><a href="../apidocs/net/sf/jguiraffe/di/EnumConverter.html">EnumConverter
    </a></code> class.
  </p>
  <p>
    Before a custom type converter can be used it has to be registered first.
    For this purpose the <em>dependency injection framework</em> provides a
    thin layer around the <em>Commons BeanUtils</em> API. There are two classes
    that have to be dealt with:
    <ul>
      <li><code><a href="../apidocs/net/sf/jguiraffe/di/ConversionHelper.html">
      ConversionHelper</a></code> provides functionality directly related to
      type conversions. It also manages the data type converters which are
      currently active. Therefore an instance of this class has to be used to
      register new converters. It defines the following registration methods:
      <ul>
        <li><code>void registerConverter(Converter converter, Class&lt;?&gt;
        targetClass)</code> registers a converter for the specified target
        class only.</li>
        <li><code>void registerBaseClassConverter(Converter converter,
        Class&lt;?&gt; targetClass)</code> registers a converter for the given
        class and all of its subclasses. This is useful if a converter can
        handle whole class hierarchies as is true for the
        <code>EnumConverter</code> already mentioned.</li>
      </ul>
      When working with base class converters the order in which they are
      registered is important: The converters are searched in their reversed
      registration order, and the first one that can deal with the current class
      is selected. So if there is a converter for the base class A and one for
      the class B, and B is derived from A, the converter for A must be
      registered first, otherwise the converter for A would also be used for B
      objects. The reversed order might be counter-intuitive at first, but it
      allows applications to override default converters that have already been
      added by the framework.</li>
      <li>An instance of the
      <code><a href="../apidocs/net/sf/jguiraffe/di/InvocationHelper.html">
      InvocationHelper</a></code> class is active during the builder operation.
      It provides functionality for invoking constructors or methods through
      reflection; for instance, it implements the method matching algorithm
      described in the previous sub section. It also manages a
      <code>ConversionHelper</code> object which is used for converting
      properties or parameters.</li>
    </ul>
  </p>
  <p>
    In order to add a custom type converter to a builder operation an instance
    of <code>ConversionHelper</code> has to be created, and the converter has to
    be registered there. Then an instance of <code>InvocationHelper</code> has
    to be created with the <code>ConversionHelper</code> object. The
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/BeanBuilder.html">
    BeanBuilder</a></code> interface defines an overloaded variant of the
    <code>build()</code> method which can be passed an
    <code>InvocationHelper</code> object. The builder then uses this object for
    method invocations and all data type conversions. So the custom converter
    that has been registered at the <code>ConversionHelper</code> object
    managed by the <code>InvocationHelper</code> becomes active (all standard
    converters are automatically registered when a new
    <code>ConversionHelper</code> instance is created, so they are active per
    default). The following code fragment shows all steps required to register
    an instance of the <code>MyConverter</code> class for the class
    <code>MyData</code>:
  </p>
    <source><![CDATA[
// Prepare and register the converter
MyConverter converter = new MyConverter();
ConversionHelper convHelper = new ConversionHelper();
convHelper.registerConverter(converter, MyData.class);

// Create an InvocationHelper with the ConversionHelper
InvocationHelper invHelper = new InvocationHelper(convHelper);

// Call the builder
BeanBuilderFactory factory = application.getBeanBuilderFactory();
try
{
    BeanBuilder builder = factory.getBeanBuilder();
    Locator beanDefs = ... // locator to the script to be processed
    BeanBuilderResult result = builder.build(beanDefs, null, null, invHelper);
    BeanContext beanContext = new DefaultBeanContext(result.getBeanStore(null));
}
catch(BuilderException bex)
{
    // exception handling
}
    ]]></source>
  <p>
    Note that the <code>InvocationHelper</code> object is passed as last argument
    to the <code>build()</code> method of the builder. This approach works, but
    it is a bit inconvenient. The developer has to create multiple objects and
    perform the registration manually. In a later chapter we will see how
    custom data type converters can be declared in a builder script. They are
    then registered automatically.
  </p>
  <p>
    <a name="standard_beans"/><strong>Application standard beans</strong>
  </p>
  <p>
    <em>JGUIraffe</em> internally makes use of its own concepts and also employs
    the dependency injection framework to configure some of its central services.
    There is a bean definition file named <em>defaultbeans.jelly</em> which is
    shipped with the framework. Each <em>JGUIraffe</em> application reads this
    file at startup.
  </p>
  <p>
    <em>defaultbeans.jelly</em> defines a number of important beans that are
    used by <em>JGUIraffe</em> applications. Naming convention is that these
    beans start with the reserved prefix <em>jguiraffe.</em>. We give a short
    overview over the content of this file in the following. Note that some of
    the classes involved are discussed in later chapters, so there may be some
    forward references.
  </p>
  <table>
  <tr>
    <th>Bean name/group</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>jguiraffe.resourceLoader</td>
    <td>This is the resource loader, i.e. the object which actually accesses
    resources. Refer to the chapter <a href="resources.html">Resources</a> for
    more details.</td>
  </tr>
  <tr>
    <td>jguiraffe.resourceManager</td>
    <td>The bean representing the resource manager. The resource manager provides
    access to localized texts. The bean is configured with the resource loader
    bean already mentioned.</td>
  </tr>
  <tr>
    <td>jguiraffe.messageOutput</td>
    <td>A bean implementing the
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/utils/MessageOutput.html">
    MessageOutput</a></code> interface. It is used to produce message boxes in
    a way independent on a specific UI toolkit.</td>
  </tr>
  <tr>
    <td>Validation beans</td>
    <td>A group of standard beans is related to the validation of input fields
    in forms. They are referenced and used by <a href="formcontroller.html">form
    controllers</a> to implement functionality related to validation and to give
    the user feedback about validation results.
    <dl>
      <dt>jguiraffe.validationMessageHandler</dt>
      <dd>The handler for validation messages. This object controls the warning
      or error messages produced by validators. Refer to the chapter
      <a href="validators.html">Transformers and Validators</a> for more
      details.</dd>
      <dt>jguiraffe.validationMessageFormat</dt>
      <dd>This is the formatter for validation error messages. It is used by
      form controllers to generate a message for all invalid input fields in the
      form.</dd>
      <dt>jguiraffe.formValidationTrigger</dt>
      <dd>This bean controls when input validation is performed, e.g. when the
      user leaves an input field or at every keyboard event.</dd>
      <dt>jguiraffe.fieldMarker</dt>
      <dd>This bean is responsible for highlighting input fields which contain
      invalid data. The default implementation declared in
      <em>defaultbeans.jelly</em> changes the color of input fields to indicate
      the validation status. The colors used for this purpose are also declared
      as beans in the file. Their names start with the prefix
      <em>jguiraffe.fieldMarker.</em> followed by a term describing the status
      this color is associated with, e.g. <em>jguiraffe.fieldMarker.invalidBg</em>
      for the background color of an invalid field or
      <em>jguiraffe.fieldMarker.notVisitedInvalidFg</em> for the foreground
      color of a field with invalid data which has not yet been visited.</dd>
    </dl>
    </td>
  </tr>
  <tr>
    <td>jguiraffe.classLoaderProvider</td>
    <td>Defines the <em>class loader provider</em> bean. Refer to the sub section
    <a href="dibuilder.html#Class_loader_issues">Class loader issues</a> for
    more details.</td>
  </tr>
  <tr>
    <td>jguiraffe.bindingStrategy</td>
    <td>This bean defines the <a href="forms.html#The_binding_strategy">binding
    strategy</a> used by forms to store their data in their model. Per default
    a strategy is defined which uses plain old Java beans as model objects.</td>
  </tr>
  <tr>
    <td>jguiraffe.guiSynchronizer</td>
    <td>Here a bean is declared which controls access to UI elements. Most UI
    toolkits allow access to graphical elements only in a special thread, the
    <em>event dispatch thread</em>. The GUI synchronizer is an abstraction over
    this concept. It must be compatible with the UI toolkit used by the
    application. The implementation declared in the <em>defaultbeans.jelly</em>
    file is compatible with Swing.</td>
  </tr>
  <tr>
    <td>jguiraffe.commandQueue</td>
    <td>Defines the concrete implementation of the command queue used by the
    application. Refer to the chapter <a href="commands.html">Commands</a> for
    more information.</td>
  </tr>
  <tr>
    <td>jguiraffe.applicationContext</td>
    <td>The bean implementing the
    <code><a href="../apidocs/net/sf/jguiraffe/gui/app/ApplicationContext.html">
    ApplicationContext</a></code> interface. This declaration is a bit more
    complex because it contains a bunch of references to helper objects
    associated with the context.</td>
  </tr>
  <tr>
    <td>Builder beans</td>
    <td>The builder for generating UIs, which is discussed in the chapter
    <a href="formbuilder.html">Building user interfaces</a> and the following
    ones, is completely specified using standard beans. Each time a reference
    to the builder is requested, the main builder bean is obtained from the
    current <code>BeanContext</code> (and because this is not a singleton bean,
    a new instance is created). Multiple helper beans are involved:
    <dl>
      <dt>jguiraffe.componentManager</dt>
      <dd>This bean is responsible for the actual creation of UI elements. It
      must be compatible with the UI toolkit used by the application. The bean
      configured in <em>defaultbeans.jelly</em> uses Swing.</dd>
      <dt>jguiraffe.actionManager</dt>
      <dd>This bean is responsible for the actual creation of actions, menus,
      and tool bars as described in the chapter <a href="actionbuilder.html">
      Events and actions</a>. It is used in an analogous way as the bean
      <em>jguiraffe.componentManager</em>.</dd>
      <dt>jguiraffe.windowManager</dt>
      <dd>This bean is responsible for the actual creation of windows as
      described in the chapter <a href="windowbuilder.html">Building windows</a>.
      It is used in an analogous way as the bean
      <em>jguiraffe.componentManager</em>.</dd>
      <dt>jguiraffe.builder</dt>
      <dd>This bean represents the actual builder, i.e. an implementation of the
      <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/Builder.html">Builder
      </a></code> interface. The declaration specifies the concrete
      implementation class and initializes the required references to helper
      objects. A number of standard <a href="dibuilder.html#type_converters">data
      type converters</a> is configured, too.</dd>
    </dl>
    </td>
  </tr>
  </table>
  <p>
    It is possible to override some of the standard beans. This can be done by
    defining custom bean definition files and referencing them in the
    configuration file of the application. The sub section
    <a href="application.html#Hooks">Hooks</a> describes how this is done. If a
    custom bean definition file contains a bean with the same name as one of
    the standard beans, it replaces this standard bean. This also works for
    beans that are referenced by other standard beans. Therefore specific
    service classes used by an application can be customized.
  </p>
  </subsection>
  </section>
</body>

</document>