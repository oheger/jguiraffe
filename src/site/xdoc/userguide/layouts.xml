<?xml version="1.0"?>
<!--

    Copyright 2006-2022 The JGUIraffe Team.

    Licensed under the Apache License, Version 2.0 (the "License")
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

-->
<!-- $Id: layouts.xml 205 2012-01-29 18:29:57Z oheger $ -->

<document>

 <properties>
  <title>Layouts</title>
  <author email="oheger@apache.org">Oliver Heger</author>
 </properties>

<body>
  <section name="Layouts">
  <p>
    The development of user interfaces in Java typically involves dealing with
    <em>layout managers</em>. This means that components cannot easily be
    positioned using absolute coordinates and sizes, but the layout manager is
    responsible for placing the components on the screen based on constraints
    the developer has defined. While this approach is very flexible and enables
    a Java application to cope with different platforms, it certainly does not
    simplify the creation of a good-looking and ergonomic GUI.
  </p>
  <p>
    From the beginning, the Java development kit offered a number of layout
    managers. Most of them are pretty simple and do not support the creation of
    a sophisticated user interface out of the box. The idea was to nest multiple
    panels with different layout managers to achieve more complex layouts. This
    works to a certain degree, but if the UI becomes more complex, the required
    code for building the panels and nesting them properly also grows more and
    more complex; and if you want to rearrange something later, you are in a
    maintenance nightmare! In addition to these simple layout managers, the
    <code>java.awt</code> package provides the <code>GridBagLayout</code>
    class, which in principle allows arbitrary complex UIs. However, this
    layout manager is very hard to understand - this is probably the reason why
    it never becomes pretty popular.
  </p>
  <p>
    With the <code><a href="../apidocs/net/sf/jguiraffe/gui/layout/PercentLayout.html">
    PercentLayout</a></code> layout manager the <em>JGUIraffe</em> library tries
    to find a compromise: a layout that should not be too difficult to grasp,
    but that is powerful enough for complex user interfaces. <code>PercentLayout</code>
    is similar to the popular <code>FormLayout</code> of
    <a href="http://www.jgoodies.com/freeware/forms/">jGoodies</a>. It provides
    the basic layout functionality implemented within <em>JGUIraffe</em>. On top
    of this class there are a couple of other layout managers for special
    purposes or frequent use cases. In the following sections the basics of
    <code>PercentLayout</code> are covered. Then we discuss the other layout
    managers shipped with <em>JGUIraffe</em> and present a usage example.
  </p>

  <subsection name="Basics of PercentLayout">
  <p>
    Similar to jGoodies' <code>FormLayout</code> <code>PercentLayout</code>
    organizes the UI in a tabular structure. The available space is grouped in
    columns and rows. Each cell in this table has certain properties that
    determine its size in both the X- and the Y-direction. Each cell can also
    host a component (e.g. a label, a checkbox, or a text field). Then its
    properties also define the component's size and alignment. For a better
    understanding take a look at the following figure:
  </p>
  <img src="../images/userguide/Layout.png" alt="Basic layout schema"/>
  <p>
    This picture shows a layout consisting of 9 columns and 9 rows. The
    structure of the layout is pretty regular: It contains labels and text
    input fields. In most cases the labels are contained in the columns with
    the indices 1 and 5, the input fields are located in the columns 3 and 7.
    So, from the user's point of view, a UI results consisting of two columns
    with input elements. <code>PercentLayout</code> is well suited for such
    regular layouts as it allows defining the properties for the columns and
    rows globally. Line 5 is somewhat special: it contains a larger text
    area spanning multiple columns, and it is also higher than the other rows.
    This demonstrates that single components can be treated in a specific way.
    Now, which properties are available for defining a cell in the layout?
  </p>
  <p>
    When defining a column or a row the following properties can be set (note
    that these properties are independent for the cell's width and height; so,
    for instance, a different alignment can be set for the width than for the
    height):
    <ul>
      <li>The <em>cell size</em>: This property determines how the preferred
      size of the cell is calculated. The size can either be derived from a
      component that is stored in this cell or it can be set to a fix value.
      The following values are possible:
      <ul>
        <li><em>PREFERRED</em>: The size of the cell is determined by the
        preferred size of the component stored in this cell.</li>
        <li><em>MINIMUM</em>: The size of the cell is determined by the minimum
        size of the component stored in this cell.</li>
        <li><em>NONE</em>: The size of the cell does not depend on a component
        stored in this cell.</li>
      </ul>
      For instance, column 1 in the example layout shown above has its width set
      to <em>PREFERRED</em>. This means that the preferred width of all label
      components is calculated. The total width of the column is the maximum of
      the widths of the single cells in this column. The columns 0, 2, 4, 6, and
      8 do not contain components. They are used to define spacing between the
      components. Therefore their size is set to <em>NONE</em>, and they define
      a minimum size (see below, and also refer to the notes about shrinking at
      the end of this sub section).</li>
      <li>A <em>minimum size</em>: Sometimes it makes sense to state that a cell
      must have at least a given size. This is especially useful for columns or
      rows acting as separators between GUI elements, e.g. the rows 0, 2, 4, or
      the columns 4, 6, 8 in the example figure. For this use case the <em>cell
      size</em> can be set to <em>NONE</em>, and the minimum size is set to the
      desired value. Another use case are components whose size is dependent on
      their content. For instance, a combo box that does not contain any entries
      or a text area with no text may be displayed very small per default. In
      this case the <em>cell size</em> can be set to <em>PREFERRED</em>, and
      additionally a <em>minimum size</em> can be specified. This means that
      the actual size of the cell is determined by the size of the component
      contained in it, but a certain minimum size is guaranteed.</li>
      <li>A <em>weight factor</em>: By evaluating the <em>cell size</em> and
      the <em>minimum size</em> properties the layout manager can determine a
      preferred layout size. This size will be set initially for the container.
      The <em>weight factor</em> determines how additional space should be
      handled that becomes available, i.e. if the user enlarges the window, how
      should this space be distributed between the cells of the layout?
      <code>PercentLayout</code> evaluates all <em>weight factors</em> and assigns
      additional space to cells with a <em>weight factor</em> &gt; 0 in
      proportion to these factors. In principle, arbitrary integer numbers can
      be used as <em>weight factors</em>. However, it is recommended to use
      numbers that sum up to 100. Then the <em>weight factor</em> can be
      interpreted as percentage rate of the additional space that is allocated
      to a cell. To make this clearer, take another look at the figure with the
      example layout. If the user enlarges the window, it makes sense that the
      columns containing text fields (i.e. the columns 3 and 7) grow
      accordingly. So we can set the <em>weight factors</em> of these columns
      to 50. Or maybe the text fields in column 7 are more important than the
      ones in column 3? Then we could set the <em>weight factor</em> of column
      7 to 67 and the one of column 3 to 33. This means that 67% of additional
      space is assigned to column 7, while only 33% is allocated to column 3
      (provided that all other <em>weight factors</em> are set to 0). By the
      way: The interpretation of the <em>weight factors</em> as percentage rate
      is the reason for the name <code>PercentLayout</code>.</li>
      <li>A <em>cell alignment</em>: After the size of a cell has been
      determined the next question is how to position the component in this
      cell. This is controlled by the <em>cell alignment</em> property. It can
      take the following values:
      <ul>
        <li><em>FULL</em>: The component takes the full space of its cell. This
        makes sense for instance for columns with text fields. Here the text
        field should fill the whole width of its cell.</li>
        <li><em>START</em>: This alignment means that the component in this
        cell keeps its preferred size. It is positioned at the left (for
        horizontal alignment) or top (for vertical alignment) margin of the cell.
        If the cell is larger than the component, there is unused space at the
        right or bottom of the cell. A use case for this alignment are columns
        with labels: They can be aligned to the left of their cell. The following
        image shows an example:<br/>
        <img src="../images/userguide/LayoutDemoLeftAlign.png"
          alt="Layout with left alignment"/>
        </li>
        <li><em>END</em>: The <em>END</em> alignment is very similar to
        <em>START</em>, with the difference that the component is positioned to
        the right or the bottom of the cell; unused space is at the left or the
        top. Again columns with labels are a good usage example for this
        alignment if the labels should be right-aligned. Have a look at the
        following image for an example:<br/>
        <img src="../images/userguide/LayoutDemoRightAlign.png"
          alt="Layout with right alignment"/>
        </li>
        <li><em>CENTER</em>: The <em>CENTER</em> alignment also keeps the size
        of the component, but it is positioned in the middle of the cell. Unused
        space is distributed to equal parts at the left and right (or the top
        and the bottom respective) of the cell. <em>CENTER</em> is often a
        suitable alignment for rows containing single line text fields: Even if
        the row grows higher, there is no point in enlarging the height of the
        text fields as only a single line of text can be entered. Therefore the
        component should keep its size, but it can be placed at the center of
        the row.</li>
      </ul>
      </li>
    </ul>
  </p>
  <p>
    In addition to the properties described so far, there is another aspect that
    influences the size of a cell: the so-called <em>cell groups</em>. A cell
    group combines multiple columns or rows with each other and ensures that
    they all have the same width or height. A use case for cell groups are
    columns with labels. In the example layout shown at the beginning of this
    section there are two columns with labels: column 1 and column 5. Per
    default the sizes of these columns would depend on the widths of the labels
    contained in them. So if column 1 contained only labels with short texts
    and column 5 contained labels with longer texts, the columns would have
    different widths. To avoid this a cell group can be defined that combines
    columns 1 and 5. This guarantees that these columns have the same width,
    i.e. the maximum width of both columns. The result certainly looks much
    better than a layout with different column sizes.
  </p>
  <p>
    When defining a layout, often the <em>preferred size</em> of the components
    involved is used to determine the size of the layout. When the associated
    container is initially created the percent layout uses this information to
    calculate the container's size. This should result in an ideal appearance.
    We have already explained what happens if additional space becomes
    available: it is distributed over the layout's cells based on their weight
    factors. But what happens if the container becomes smaller?
  </p>
  <p>
    The percent layout manager provides a boolean flag that determines its
    behavior in this case: <code>canShrink</code>. If this flag is set to <b>false</b>
    (the default value is <b>true</b>), the cells cannot become smaller than the
    size calculated based on the preferred sizes. If the user decreases the
    container's size more and more, parts of the UI are cut. This is shown in
    the following figure. As can be seen, parts of the lower right become
    invisible as the window becomes too small.
  </p>
  <p>
    <img src="../images/userguide/LayoutNoShrink.png"
          alt="Layout that cannot shrink"/>
  </p>
  <p>
    Note: There does not seem to be a reliable way in Swing to enforce a minimum
    size of a window. Even if all components involved have a minimum size set,
    the window can be dragged smaller - with the effect that parts of the UI
    become invisible as demonstrated by the figure. For dialog windows that do
    not benefit from additional size (e.g. because only small input fields for
    numbers or dates are contained) it may be a good solution to disable sizing
    at all. However, if the dialog contains text areas, tables, or other
    scrollable elements, you do not want to do this.
  </p>
  <p>
    If the <code>canShrink</code> attribute of a percent layout is set to
    <b>true</b>, the layout manager's behavior when calculating the cell sizes
    depends on the space currently available. If there is enough space, the
    calculation is performed as described above. If the space shrinks below this
    threshold, the layout manager acts as if the cell sizes of all cells had
    been set to <em>minimum</em> rather than <em>preferred</em>. This
    means that this time the minimum size of all components involved is queried.
    For components whose minimum size is equal to their preferred size, or for
    cells whose size has already been <em>minimum</em>, there is no difference.
    But other components and cells may be able to shrink. After determining the
    minimum sizes the layout manager checks whether the layout now fits in the
    space available or if even more space is available. In this case, the
    remaining space is again distributed over the cells with a weight factor.
    This approach allows the layout to shrink in a graceful way. As an
    example consider the following simple window that only contains a text area.
    It has a border layout, and the text area is added to the center.
  </p>
  <p>
    <img src="../images/userguide/LayoutShrink1.png"
          alt="Shrinable layout with preferred size"/>
  </p>
  <p>
    Because the text area has set the number of columns and rows to be displayed
    it has a preferred size. After opening the window this size is used. The
    figure shows the window in its preferred size. Now the window's size is
    reduced. Because the layout can shrink, the text area component becomes
    smaller, too, which is indicated by the scroll bars.
  </p>
  <p>
    <img src="../images/userguide/LayoutShrink2.png"
          alt="Shrinable layout with smaller size"/>
  </p>
  <p>
    When working with layouts that can shrink be careful with the components
    involved: All components with a preferred size larger than the minimum size
    should be added to cells with a non-null weight factor. Otherwise, the size
    of these components may suddenly jump from preffered to minimum when the
    user drags the window to become smaller. This is probably confusing.
  </p>
  </subsection>

  <subsection name="Helper classes">
  <p>
    After the concepts of the <code>PercentLayout</code> manager have been
    discussed it is time to have a closer look at the implementation classes.
    At first there are some helper classes that need to be introduced.
  </p>
  <p>
    <strong>NumberWithUnit</strong>
  </p>
  <p>
    When dealing with GUI programming the default unit for specifying sizes or
    gaps is typically <em>pixels</em>. This is pretty natural, however, the
    results of this approach may strongly depend on the users' screen
    resolution. This means that a layout may look good on one screen, while it
    is too small or too big on another one. To address this problem the
    <code>PercentLayout</code> layout manager supports multiple units for sizes
    or gaps.
  </p>
  <p>
    All numeric values required for a layout definition are specified as
    instances of the <code><a href="../apidocs/net/sf/jguiraffe/gui/layout/NumberWithUnit.html">
    NumberWithUnit</a></code> class. As the name implies, this class stores a
    numeric value (as a floating point number) and an associated unit. It
    defines methods for converting this value into pixels, which is required for
    internal layout calculations. The supported units are defined by the
    <code><a href="../apidocs/net/sf/jguiraffe/gui/layout/Unit.html">Unit</a></code>
    enumeration class. These are the following:
    <ul>
      <li><em>Pixels:</em> Of course, pixels are supported.</li>
      <li><em>Inches:</em> It is possible to define numbers as inches. In this
      case the screen resolution (in dots per inch) is used for converting
      these values to pixels. This guarantees that the resulting layouts have
      the same sizes on different screen resolutions.</li>
      <li><em>Centimeters:</em> Like inches, but for the ones who prefer the
      metric system.</li>
      <li><em>Dialog units:</em> A <em>dialog unit</em> is a unit whose exact
      size depends on the font of the container it is used in. A horizontal
      dialog unit equals the fourth part of the container's font's average
      character width; a vertical dialog unit equals the eighth part of the
      character height. The advantage of this unit is that layouts can
      automatically adapt to certain system settings. For instance, if the
      user has enabled large fonts on his operation system, the layouts will
      resize correspondingly.</li>
    </ul>
  </p>
  <p>
    To create an instance of <code>NumberWithUnit</code> a <b>double</b> for the
    actual value and a constant of the <code>Unit</code> enumaration class have
    to be passed to the constructor. There is also a convenience constructor
    for pixels, which expects an <b>int</b>. Finally, there is a constructor
    that takes a string and parses it to a number with a unit. The string must
    start with a floating point number, followed by optional whitespace and the
    short name of the unit. Examples for valid strings are <code>10cm, 10 IN,
    10  Dlu, 10px</code>.
  </p>
  <p>
    <strong>CellConstraints</strong>
  </p>
  <p>
    The <code><a href="../apidocs/net/sf/jguiraffe/gui/layout/CellConstraints.html">
    CellConstraints</a></code> class is used for defining the properties of a
    cell (a column or a row) in the layout. An instance stores exactly the
    properties that have been discused in the last section: the cell size
    (provided as an instance of the
    <code><a href="../apidocs/net/sf/jguiraffe/gui/layout/CellSize.html">
    CellSize</a></code> enumeration class), the minimum size of the cell, the
    cell alignment (provided as an instance of the
    <code><a href="../apidocs/net/sf/jguiraffe/gui/layout/CellAlignment.html">
    CellAlignment</a></code> enumeration class), and a weight factor.
  </p>
  <p>
    Instances of <code>CellConstraints</code> are not created directly, but a
    <em>builder</em> is used for this purpose. This makes the creation of
    instances pretty convenient as only the properties have to be defined that
    are needed. The following code fragment shows how the builder is used:
    <source><![CDATA[
// First create the builder
CellConstraints.Builder builder = new CellConstraints.Builder();

// Now create instances
CellConstraints cc = builder.withCellSize(CellSize.MINIMUM)
                            .withCellAlignment(CellAlignment.CENTER)
                            .withWeight(50)
                            .create();
    ]]></source>
  </p>
  <p>
    Basically the several <code>with()</code> methods of the builder are called
    to define the desired properties. With a call of the <code>create()</code>
    method the <code>CellConstraints</code> instance is actually created.
  </p>
  <p>
    Instead of setting the properties of a <code>CellConstraints</code> instance
    step by step, an instance can also be defined using a <em>specification
    string</em>. This is a string that defines all possible properties in a
    compact form. The syntax is as follows:
  </p>
  <p>
    <code>&lt;cell alignment&gt;/&lt;cell size&gt;(&lt;minimum size&gt;)/&lt;weight&gt;</code>
  </p>
  <p>
    The alignment, the cell size, and the weight factor can be defined separated
    by slash (&quot;/&quot;) characters. The alignment and the weight factor
    are optional, only the cell size must be defined. The strings are not case
    sensitive. The following strings are all valid specification strings:
    <dl>
      <dt>start/preferred</dt>
      <dd>Cell alignment is set to <em>START</em>, cell size is set to
      <em>PREFERRED</em>.</dd>
      <dt>FULL/PREFERRED(1in)/50</dt>
      <dd>Cell alignment is set to <em>FULL</em>, cell size is the
      <em>PREFERRED</em> size with a minimum size of 1 inch (as can be seen, it
      is possible to define a unit for the minimum size), the weight factor is
      set to 50.</dd>
      <dt>preferred</dt>
      <dd>Only the cell size is set to <em>PREFERRED</em>.</dd>
      <dt>3dlu</dt>
      <dd>Only a minimum size is set to 3 dialog units. This implies a cell size
      of <em>NONE</em>.</dd>
    </dl>
    The builder for <code>CellConstraints</code> has a <code>fromString()</code>
    method that returns an instance for a valid specification string. For more
    options of <code><a href="../apidocs/net/sf/jguiraffe/gui/layout/CellConstraints.html">
    CellConstraints</a></code> have a look at the Javadocs of this class.
  </p>
  <p>
    <strong>PercentData</strong>
  </p>
  <p>
    After a layout has been created and configured the components to be managed
    have to be added. More complex layout managers require constraints objects
    that exactly specify how a specific component should be handled. For
    instance, the well-known <code>BorderLayout</code> layout manager from the
    <code>java.awt</code> package needs a name of a cell, in which the component
    is to be added (e.g. <em>NORTH</em> or <em>CENTER</em>), as constraints. The
    <code>java.awt.GridBagLayout</code> layout manager uses the
    <code>GridBagConstraints</code> class for this purpose.
    <code>PercentLayout</code> also defines its own class for layout constraints:
    <code><a href="../apidocs/net/sf/jguiraffe/gui/layout/PercentData.html">
    PercentData</a></code>.
  </p>
  <p>
    A <code>PercentData</code> object has the following properties:
    <ul>
      <li>The position of the cell in the tabular-structured layout of the cell
      in which the component should be placed. This is the 0-based column and
      row index. This information is mandatory.</li>
      <li>Per default a component is added to exactly one cell. In some
      situations, e.g. for longer text fields or text areas or for header lines,
      it makes sense that a component spans multiple columns or rows.
      <code>PercentData</code> allows defining the number of cells spanned by
      the component in X and Y direction.</li>
      <li>If a component spans multiple columns or rows, it is not a priori
      clear, to which column or row the size of the component should be counted
      when calculating the minimum column or row size. In this case a so-called
      target column and row can be defined. These properties specify the
      column and/or row to which the component logically belongs. If these
      properties are not set, the size of this component is not taken into
      account when determining the minimum or preferred sizes for the layout's
      columns and rows.</li>
      <li>Per default the cell constraints defined for the current cell are
      applied for the component. <code>PercentLayout</code> supports setting
      special <code>CellConstraints</code> objects for both the column and the
      row, which override the default settings. Using this feature special
      properties can be set for specific components.</li>
    </ul>
  </p>
  <p>
    To create new <code>PercentData</code> objects an analogous approach is used
    as for <code>CellConstraints</code>: There is a <code>Builder</code> class
    which allows setting of properties in a convenient way. A typical sequence
    for creating <code>PercentData</code> objects using the builder could look
    as follows:
    <source><![CDATA[
// First create the builder
PercentData.Builder b = new PercentData.Builder();

// Now create instances
PercentData pd1 = b.xy(1, 2).create();
PercentData pd2 = b.xy(1, 3).spanX(2).withColumnConstraints(columnConstr).create();
    ]]></source>
  </p>
  <p>
    The <code>Builder</code> class defines a bunch of methods that correspond to
    the properties supported by <code>PercentData</code>. The methods
    <code>withColumnConstraints()</code>, <code>withRowConstraints()</code>,
    <code>withTargetColumn()</code>, and <code>withTargetRow()</code> should
    be self-explanatory. With the <code>xy()</code> method the indices of the
    column and the row the component is to be placed in are specified. The
    number of columns or rows spanned by the component can be set either
    separately using the <code>spanX()</code> and <code>spanY()</code> methods
    or in a single operation using the <code>span()</code> method. Often a
    <code>PercentData</code> object will only be initialized with the column and
    row indices - these are the only mandatory properties. For this special use
    case the <code>Builder</code> class defines the convenience method
    <code>pos()</code>. <code>pos()</code> sets the indices and creates the new
    instance immideately. So the <code>create()</code> method need not be called.
  </p>
  <p>
    <strong>CellGroup</strong>
  </p>
  <p>
    The concept of <em>cell groups</em> has already been introduced. Cell groups
    allow the definition of columns or rows that should always have the same
    width or height. The corresponding API of <code>PercentLayout</code> makes
    use of the <code><a href="../apidocs/net/sf/jguiraffe/gui/layout/CellGroup.html">
    CellGroup</a></code> class.
  </p>
  <p>
    <code>CellGroup</code> is a pretty simple class. It basically manages a
    number of (0-based) indices for the columns or rows that belong to the
    group. Typically cell groups do not have too many elements. Therefore there
    are convenience constructors that accept 2, 3, and 4 indices - this should
    cover the most frequent use cases. If this is not enough, there is the
    static <code>fromArray()</code> method, which reads the indices of the
    group from an arbitrary array.
  </p>
  <p>
    The static <code>fromString()</code> method allows initializing a
    <code>CellGroup</code> from a string representation. Valid strings contain
    the numeric indices separated by various supported separater characters,
    for instance:
    <ul>
      <li><code>1,3,4</code></li>
      <li><code>4 3 1</code></li>
      <li><code>1, 2;3 / 4</code></li>
    </ul>
    As can be seen, many different separator characters are possible which can
    also be mixed. Later in the examples section we will present a code fragment
    that demonstrates how <code>CellGroup</code> objects are created and passed
    to a <code>PercentLayout</code> object.
  </p>
  </subsection>

  <subsection name="Platform-independent layouts">
  <p>
    The implementation of the <code>PercentLayout</code> manager is somewhat
    special because it does not implement a platform-specific layout manager
    interface. For instance, when working with Swing all layout managers must
    implement the <code>java.awt.LayoutManager2</code> interface. The
    implementation classes of <code>PercentLayout</code> do not do this.
    Rather, they implement only the layout algorithm in a way that is independent
    on a concrete GUI library. For accessing platform-specific functionality
    (e.g. setting or obtaining the size of a component) an adapter is used. The
    functionality of this adapter is defined by the
    <code><a href="../apidocs/net/sf/jguiraffe/gui/layout/PercentLayoutPlatformAdapter.html">
    PercentLayoutPlatformAdapter</a></code> interface.
  </p>
  <p>
    The advantage of this approach is that the <code>PercentLayout</code>
    manager can easily be ported to different UI libraries. The base classes
    can remain unchanged; only a specialized adapter has to be written. For
    Swing there is already a fully functional adapter implementation:
    <code><a href="../apidocs/net/sf/jguiraffe/gui/platform/swing/layout/SwingPercentLayoutAdapter.html">
    SwingPercentLayoutAdapter</a></code>. <code>SwingPercentLayoutAdapter</code>
    also implements the <code>java.awt.LayoutManager2</code> interface. When an
    instance is constructed it is passed the <code>PercentLayout</code> object
    it is associated with. Then it can be installed as a regular Swing layout
    manager, for instance:
    <source><![CDATA[
JPanel panel = new JPanel();
PercentLayoutBase percentLayout = ...
SwingPercentLayoutAdapter adapter = new SwingPercentLayoutAdapter(percentLayout);
panel.setLayout(adapter);
    ]]></source>
  </p>
  </subsection>

  <subsection name="The PercentLayout class">
  <p>
    The layout functionality discussed so far is implemented by the
    <code><a href="../apidocs/net/sf/jguiraffe/gui/layout/PercentLayout.html">
    PercentLayout</a></code> class. To install a layout of this type an instance
    of <code>PercentLayout</code> has to be created and configured. Then a
    platform-specific adapter has to be associated with it as shown in the code
    fragment above.
  </p>
  <p>
    <code>PercentLayout</code> provides three different constructors:
    <ul>
      <li>One constructor expects two collections with
      <code><a href="../apidocs/net/sf/jguiraffe/gui/layout/CellConstraints.html">
      CellConstraints</a></code> objects. These collections define the
      properties of the columns and the rows of the layout. The resulting layout
      has as many columns and rows as these collections contain elements.</li>
      <li>There is another constructor that accepts two strings. It has the
      same meaning, but the <code>CellConstraints</code> objects defining the
      layout's columns and rows are specified as strings conforming to the
      format already discussed in this document. The first string contains an
      arbitrary number of <code>CellConstraints</code> specification strings for
      the columns of the layout separated by &quot;,&quot; characters, the
      second string is analogous, but it defines the constraints for the layout's
      rows. This is a pretty compact way of defining the layout:
    <source><![CDATA[
PercentLayout layout = new PercentLayout(
    "3dlu, end/preferred, 3dlu, full/preferred(1in)/50, 7dlu, end/preferred, "
        + "3dlu, full/preferred(1in)/50, 3dlu",
    "3dlu, preferred, 3dlu, preferred, 3dlu, preferred, 7dlu, preferred, "
        + 3dlu, preferred, 3dlu, full/preferred(1in)/100, 3dlu");
    ]]></source>
      However, the variant with the collections is slightly more efficient as
      there is no need of string parsing.</li>
      <li>Finally there is a constructor that only takes two integer values
      representing the dimensions of the layout (i.e. the number of columns
      and rows). This constructor leaves the constraints undefined. They can be
      specified later using the methods <code>setColumnConstraints()</code> and
      <code>setRowConstraints()</code> which allow assigning a contraints object
      to a single column or row. This constructor is mainly intended to be used
      by sub classes.</li>
    </ul>
  </p>
  <p>
    After an instance of <code>PercentLayout</code> was created further
    configuration can be performed:
    <ul>
      <li>As was already pointed out, single <code>CellConstraints</code>
      objects for columns or rows can be set using the
      <code>setColumnConstraints()</code> and <code>setRowConstraints()</code>
      methods.</li>
      <li><code>CellGroup</code> objects (see above) can be added using the
      <code>addColumnGroup()</code> and <code>addRowGroup()</code> methods.
      This determines the columns or rows which should have the same size.</li>
    </ul>
  </p>
  <p>
    After the configuration of the <code>PercentLayout</code> object, and with
    the <code>PercentLayoutPlatformAdapter</code> in place the layout can be
    used as any regular layout manager instance. This means that components can
    be added to a container using <code>PercentData</code> objects as layout
    constraints. We will show this later in the examples section.
  </p>
  </subsection>

  <subsection name="BorderLayout">
  <p>
    <code><a href="../apidocs/net/sf/jguiraffe/gui/layout/PercentLayout.html">
    PercentLayout</a></code> is the most generic and powerful layout
    implementation shipped with the <em>JGUIraffe</em> library. There are a
    couple of other layout manager implementations on top of
    <code>PercentLayout</code> for special use cases. One of these is
    <code><a href="../apidocs/net/sf/jguiraffe/gui/layout/BorderLayout.html">
    BorderLayout</a></code>
  </p>
  <p>
    <code>BorderLayout</code> is very similar to the layout manager with the
    same name from the standard <code>java.awt</code> package. (More information
    about <code>java.awt.BorderLayout</code> can be found for instance in the
    <a href="http://java.sun.com/docs/books/tutorial/uiswing/layout/border.html">
    Swing Tutorial</a>.) It provides some additional functionality, e.g. the
    definition of margins and gaps between the components it manages. And, it is
    also written in a platform-independent way; so it can easily be ported to
    other GUI libraries which do not support this type of layout out of the box.
  </p>
  <p>
    Using <code>BorderLayout</code> is simple. After creating a
    <code>BorderLayout</code> instance (which does not require any parameters)
    some configuration properties can be set using the following methods:
    <ul>
      <li>setLeftMargin() allows defining the left margin of the
      container. This is space on the left that remains unused.</li>
      <li>setTopMargin() allows defining the top margin of the
      container. This is space on the top that remains unused.</li>
      <li>setRightMargin() allows defining the right margin of the
      container. This is space on the right that remains unused.</li>
      <li>setBottomMargin() allows defining the bottom margin of the
      container. This is space on the bottom that remains unused.</li>
      <li>setNorthGap() defines the gap between the <em>north</em>
      component and the center.</li>
      <li>setWestGap() defines the gap between the <em>west</em>
      component and the center.</li>
      <li>setEastGap() defines the gap between the <em>east</em>
      component and the center.</li>
      <li>setSouthGap() defines the gap between the <em>south</em>
      component and the center.</li>
    </ul>
    All these methods expect a
    <code><a href="../apidocs/net/sf/jguiraffe/gui/layout/NumberWithUnit.html">
    NumberWithUnit</a></code> object. So the margins and gaps can be specified
    in any of the supported units. The default is 0 for all margins and gaps
    (which conforms to the behavior of the classic <code>java.awt.BorderLayout</code>).
  </p>
  <p>
    <code>BorderLayout</code> also needs a <code>PercentLayoutPlatformAdpater</code>
    instance. If this adapter has been installed, components can be added to the
    associated container in the usual way using the <code>CENTER, NORTH, WEST,
    EAST</code> or <code>SOUTH</code> constants of <code>BorderLayout</code> as
    constraints. These constraints define, in which of the managed cells the
    component is to be placed. We will see <code>BorderLayout</code> in action
    in the examples section.
  </p>
  </subsection>

  <subsection name="ButtonLayout">
  <p>
    Dialog boxes often have a bar with buttons at their botton defining the
    actions the user can invoke, e.g. <em>Save</em>, <em>Cancel</em>, or
    <em>Help</em>. Given the frequency of this use case, it is surprisingly
    difficult to create a corresponding layout using Java board means. A bunch
    of code is required to ensure that the buttons in the button bar are properly
    aligned and all have the same width. The
    <code><a href="../apidocs/net/sf/jguiraffe/gui/layout/ButtonLayout.html">
    ButtonLayout</a></code> class is focused on this use case.
  </p>
  <p>
    A <code>ButtonLayout</code> object can be instantiated using its default
    constructor. Then the following properties can be configured:
    <ul>
      <li>The margins around the button bar. These are defined using the
      methods <code>setLeftMargin()</code>, <code>setTopMargin()</code>,
      <code>setRightMargin()</code>, and <code>setBottomMargin()</code>. Again,
      the <code>NumberWithUnit</code> class is used for defining the margins.</li>
      <li>The width of the gaps between the buttons using the
      <code>setGap()</code> method. The gap is also specified using a
      <code>NumberWithUnit</code> object.</li>
      <li>The alignment of the button bar. Here a constant of the
      <code>ButtonLayout.Alignment</code> enumeration class can be passed to the
      <code>setAlignment()</code> method. The alignment determines whether the
      buttons should be aligned to the left, the right, or the center of the
      whole dialog.</li>
    </ul>
  </p>
  <p>
    As for the other layout classes covered so far a
    <code>PercentLayoutPlatformAdapter</code> is required to embed the layout
    into a specific GUI platform. Then buttons can be created and added to the
    container representing the button bar without passing additional
    constraints objects. They will be automatically added to the layout and
    placed accordingly. This is shown in detail in the examples section.
  </p>
  </subsection>

  <subsection name="A complete example">
  <p>
    In this section a dialog box using the layout classes discussed in this
    document is developed. We only focus on the code required to construct the
    UI; no additional functionality (e.g. for the handling of button clicks) is
    added. As GUI library we will set on Swing. The following figure shows the
    final dialog box:
  </p>
  <img src="../images/userguide/ExampleLayout.png" alt="Example layout"/>
  <p>
    The example layout contains two (logic) columns with labels and input fields
    in the upper part. All labels have the same length. This is also true for
    the input fields. In the lower part there are longer input fields. Their
    labels, however, are aligned with the first labels of the upper part. There
    are also headings with a larger width.
  </p>
  <p>
    As a general implementation strategy we will use a <code>BorderLayout</code>
    that divides the dialog box in a section with the actual input fields
    (this is a panel which is added to the <em>CENTER</em>) and a section with
    the buttons (another panel in the <em>SOUTH</em>). All components in the
    <em>CENTER</em> area can be arranged using a single <code>PercentLayout</code>
    object. For the buttons of course <code>ButtonLayout</code> is the
    appropriate choice. The following code shows how the <code>BorderLayout</code>
    is created and installed at the content pane of the dialog box:
  </p>
    <source><![CDATA[
// The layout of the content pane
BorderLayout borderLayout = new BorderLayout();
getContentPane().setLayout(new SwingPercentLayoutAdapter(borderLayout));
    ]]></source>
  <p>
    As the <code>BorderLayout</code> needs no special configuration, this code
    is very simple. We could have also set some of the margins, but in this
    example we use a properly setup <code>PercentLayout</code> to define the
    margins of the dialog box.
  </p>
  <p>
    The main area of the dialog box that contains all labels and input elements
    is realized using <code>PercentLayout</code>. When working with
    <code>PercentLayout</code> at first the UI has to be devided into columns
    and rows; then the properties for these columns and rows have to be defined.
    For our example layout we use 9 columns for the following elements:
    <ul>
      <li>The first column defines the left margin of the dialog box. Note that
      margins and gaps are realized by additional columns and rows. Such cells
      typically only have a minimum width set.</li>
      <li>The next column contains the labels for the input fields on the left
      side. Its width is determined by the labels; the labels are aligned to
      the right.</li>
      <li>The next column defines the space between the labels and their input
      fields. Again only its minimum size will be specified.</li>
      <li>The fourth column contains the input fields on the left side. Again
      the width of this column in determined by the components it contains, but
      this time we also specify a minimum width to ensure that the text fields
      do not become too small. The input fields should cover the whole space of
      the cell. If the user enlarges the dialog box, the additional space should
      be added to same parts to the two columns with input fields. So a weight
      factor of 50 has to be set.</li>
      <li>Now a divider column follows that defines the space between the left
      and the right components. It has again only a minimum size, but it is
      slightly bigger than than the margins and the spaces between labels and
      input fields.</li>
      <li>The remaining columns repeat the settings for the components on the
      right side. So the sixth column contains the next labels.</li>
      <li>The next columns defines the space between the right labels and the
      right input fields.</li>
      <li>It follows the column for the right input fields. Here the weight
      factor is again set to 50. This means that the columns with input fields
      grow by the same amount if additional space becomes available.</li>
      <li>Finally there is a column for the right margin.</li>
    </ul>
  </p>
  <p>
    The constraints for the layout's rows are less complicated because there are
    only two types of rows: rows containing components (labels and/or input
    fields) whose height is derived from their content and rows with a minimum
    height serving as separators between the other rows. All rows with an even
    row index (starting at 0) are separator rows. An exception is the row
    containing the text area. Here also a minimum height is defined so that the
    text area has a certain initial size. Additionally we specify that additional
    space in the Y direction should be fully consumed by this row because the
    text area is the only component in this dialog for which growing in the
    height makes sense. This is achieved by setting the weight factor of this
    row to 100. To actually create the layout we use string representations for
    the constraints we thought about in the last paragraphs. This looks as
    follows:
  </p>
    <source><![CDATA[
// setup the main panel and its layout
JPanel pnlMain = new JPanel();
PercentLayout layout = new PercentLayout(
    "3dlu, end/preferred, 3dlu, full/preferred(1in)/50, 7dlu, end/preferred, "
        + "3dlu, full/preferred(1in)/50, 3dlu",
    "3dlu, preferred, 3dlu, preferred, 3dlu, preferred, 7dlu, preferred, "
        + 3dlu, preferred, 3dlu, full/preferred(1in)/100, 3dlu");
    ]]></source>
  <p>
    The first string parameter of the constructor defines all columns, the second
    one defines the rows. As units for margins and spaces we use dialog units.
    The meaning of the single definition strings should be clear after reading
    the section about cell constraints. With this constructor all constraints of
    the layout are specified. What remains is the requirement that some columns
    should have the same width: the columns with the labels and the columns with
    the text fields. To achieve this some <code>CellGroup</code> objects are
    added to the layot.
  </p>
    <source><![CDATA[
layout.addColumnGroup(new CellGroup(1, 5));
layout.addColumnGroup(new CellGroup(3, 7));
pnlMain.setLayout(new SwingPercentLayoutAdapter(layout));
    ]]></source>
  <p>
    These lines add two <code>CellGroup</code> objects for columns. One for the
    columns with the labels and one for the columns with the text fields. The
    last line installs the layout in the panel by making use of a Swing-specific
    layout adapter.
  </p>
  <p>
    Now it is time for adding components to the layout. First some builder
    objects for creating helper objects are setup. Then the first header
    line is defined:
  </p>
    <source><![CDATA[
// Builder for creating constraints objects
CellConstraints.Builder cb = layout.getConstraintsBuilder();
PercentData.Builder pcb = new PercentData.Builder();

// Fill a header line
pnlMain.add(
        new JLabel("General information"),
        pcb.xy(1, 1).spanX(7).withColumnConstraints(cb.defaultColumn().create())
           .create());
    ]]></source>
  <p>
    Each <code>PercentLayout</code> object has its own builder for
    <code>CellConstraints</code> objects. This builder can also be used by
    client code. We do this here. The builder for <code>PercentData</code>
    instances has to be created manually.
  </p>
  <p>
    The header line consists of a single label. What makes this line special is
    the fact that the label spans multiple columns - the X span in the
    <code>PercentData</code> object is set to 7. We also use a specific
    <code>CellConstraints</code> object. The default constraints for column 1
    state that components should be right-aligned. The label acting as header is
    left-aligned. Now the two rows with labels and text fields are constructed:
  </p>
    <source><![CDATA[
// Fill the first data line
pnlMain.add(new JLabel("Name:"), pcb.pos(1, 3));
pnlMain.add(new JTextField(), pcb.pos(3, 3));
pnlMain.add(new JLabel("Firstname:"), pcb.pos(5, 3));
pnlMain.add(new JTextField(), pcb.pos(7, 3));

// Fill the second data line
pnlMain.add(new JLabel("Street:"), pcb.pos(1, 5));
pnlMain.add(new JTextField(), pcb.pos(3, 5));
pnlMain.add(new JLabel("City:"), pcb.pos(5, 5));
pnlMain.add(new JTextField(), pcb.pos(7, 5));
    ]]></source>
  <p>
    This is pretty straight-forward: The Swing components for the labels and
    text fields are created and placed into the layout. The <code>PercentData</code>
    objects used as constraints only define the position in the tabular layout.
    Because no other properties need to be set the <code>pos()</code>
    convenience method of the <code>PercentData.Builder</code> class can be
    used for this purpose.
  </p>
  <p>
    The lower half of the dialog box is a bit more irregular. There is again a
    header line which is analogous to the first one. In the following lines the
    input fields span multiple columns. The line with the text area is heigher
    than the other rows. Let's have a look at the code:
  </p>
    <source><![CDATA[
// Fill another header line
pnlMain.add(
        new JLabel("Specifics"),
        pcb.xy(1, 7).spanX(7).withColumnConstraints(cb.defaultColumn().create())
           .create());

// Fill third data line
pnlMain.add(new JLabel("Email:"), pcb.pos(1, 9));
pnlMain.add(new JTextField(), pcb.xy(3, 9).spanX(5).create());

// Fill fourth data line
pnlMain
        .add(
                new JLabel("Remarks:"),
                pcb.xy(1, 11).withRowConstraints(
                    cb.withCellAlignment(CellAlignment.START)
                      .withCellSize(CellSize.PREFERRED)
                      .create())
                   .create());
pnlMain.add(new JScrollPane(new JTextArea()),
        pcb.xy(3, 11).spanX(5).create());
    ]]></source>
  <p>
    The header line and the line with the first text field contain nothing new.
    They define an X span so they cover multiple columns. The row with the text
    area is a bit more complicated. First, when the layout was constructed a
    minimum height was defined for this row by specifying the following
    constraints string: <code>full/preferred(1in)/100</code>. This means that
    this row has a height of at least 1 inch, which guarantees an appropriate
    size of the text area. Therefore when adding the text area no special
    constraints have to be provided except for the column span. For the label
    however, we have to override the global row constraints. Here the alignment
    is set to <em>CENTER</em>, which would cause the label to be centered
    relative to the text area. This would look strange; so we set the alignment
    in the row constraints to <em>START</em>. This causes the label to be
    top-aligned. Now the main area of the layout with all input components is
    complete. What is missing is the button bar:
  </p>
    <source><![CDATA[
// The button bar
JPanel pnlButtons = new JPanel();
ButtonLayout buttonLayout = new ButtonLayout();
buttonLayout.setGap(new NumberWithUnit(4, Unit.DLU));
buttonLayout.setLeftMargin(new NumberWithUnit(3, Unit.DLU));
buttonLayout.setRightMargin(new NumberWithUnit(3, Unit.DLU));
pnlButtons.setLayout(new SwingPercentLayoutAdapter(buttonLayout));
pnlButtons.add(new JButton("OK"));
pnlButtons.add(new JButton("Cancel"));
pnlButtons.add(new JButton("Help"));
    ]]></source>
  <p>
    For the button bar a new panel is created. The layout manager is set to a
    <code>ButtonLayout</code> instance (using a <code>SwingPercentLayoutAdapter</code>
    as mediator). Some properties of the <code>ButtonLayout</code> are set,
    then the buttons are added. That's all. Finally the panels for the main
    area and the button bar have to be added to the dialog's content pane. It
    has to be ensured that the appropriate cells of the <code>BorderLyout</code>
    are used:
  </p>
    <source><![CDATA[
getContentPane().add(pnlMain, BorderLayout.CENTER);
getContentPane().add(pnlButtons, BorderLayout.SOUTH);
    ]]></source>
  <p>
    This was all the code for constructing the UI. For a better overview the
    whole code of the demo application is presented below. The code lines we
    just discussed can be found in the <code>init()</code> method.
  </p>
    <source><![CDATA[
package net.sf.jguiraffe.examples.gui.layout;

import java.awt.EventQueue;

import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTextArea;
import javax.swing.JTextField;

import net.sf.jguiraffe.gui.layout.BorderLayout;
import net.sf.jguiraffe.gui.layout.ButtonLayout;
import net.sf.jguiraffe.gui.layout.CellAlignment;
import net.sf.jguiraffe.gui.layout.CellConstraints;
import net.sf.jguiraffe.gui.layout.CellGroup;
import net.sf.jguiraffe.gui.layout.CellSize;
import net.sf.jguiraffe.gui.layout.NumberWithUnit;
import net.sf.jguiraffe.gui.layout.PercentData;
import net.sf.jguiraffe.gui.layout.PercentLayout;
import net.sf.jguiraffe.gui.layout.Unit;
import net.sf.jguiraffe.gui.platform.swing.layout.SwingPercentLayoutAdapter;

/**
 * An example of using PercentLayout with Swing.
 */
@SuppressWarnings("serial")
public class SwingPercentLayoutExample extends JFrame
{

    public SwingPercentLayoutExample()
    {
        super();
        init();
        pack();
    }

    /**
     * Constructs the GUI of this frame.
     */
    protected void init()
    {
        // init frame
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        setTitle("PercentLayout demo");

        // The layout of the content pane
        BorderLayout borderLayout = new BorderLayout();
        getContentPane().setLayout(new SwingPercentLayoutAdapter(borderLayout));

        // setup the main panel and its layout
        JPanel pnlMain = new JPanel();
        PercentLayout layout = new PercentLayout(
                "3dlu, end/preferred, 3dlu, full/preferred(1in)/50, 7dlu, "
                + "end/preferred, 3dlu, full/preferred(1in)/50, 3dlu",
                "3dlu, preferred, 3dlu, preferred, 3dlu, preferred, 7dlu, "
                + "preferred, 3dlu, preferred, 3dlu, full/preferred(1in)/100, 3dlu");
        layout.addColumnGroup(new CellGroup(1, 5));
        layout.addColumnGroup(new CellGroup(3, 7));
        pnlMain.setLayout(new SwingPercentLayoutAdapter(layout));

        // Builder for creating constraints objects
        CellConstraints.Builder cb = layout.getConstraintsBuilder();
        PercentData.Builder pcb = new PercentData.Builder();

        // Fill a header line
        pnlMain.add(new JLabel("General information"), pcb.xy(1, 1).spanX(7)
                .withColumnConstraints(cb.defaultColumn().create()).create());

        // Fill the first data line
        pnlMain.add(new JLabel("Name:"), pcb.pos(1, 3));
        pnlMain.add(new JTextField(), pcb.pos(3, 3));
        pnlMain.add(new JLabel("Firstname:"), pcb.pos(5, 3));
        pnlMain.add(new JTextField(), pcb.pos(7, 3));

        // Fill the second data line
        pnlMain.add(new JLabel("Street:"), pcb.pos(1, 5));
        pnlMain.add(new JTextField(), pcb.pos(3, 5));
        pnlMain.add(new JLabel("City:"), pcb.pos(5, 5));
        pnlMain.add(new JTextField(), pcb.pos(7, 5));

        // Fill another header line
        pnlMain.add(new JLabel("Specifics"), pcb.xy(1, 7).spanX(7)
                .withColumnConstraints(cb.defaultColumn().create()).create());

        // Fill third data line
        pnlMain.add(new JLabel("Email:"), pcb.pos(1, 9));
        pnlMain.add(new JTextField(), pcb.xy(3, 9).spanX(5).create());

        // Fill fourth data line
        pnlMain.add(new JLabel("Remarks:"), pcb.xy(1, 11).withRowConstraints(
                cb.withCellAlignment(CellAlignment.START).withCellSize(
                        CellSize.PREFERRED).create()).create());
        pnlMain.add(new JScrollPane(new JTextArea()), pcb.xy(3, 11).spanX(5)
                .create());

        // The button bar
        JPanel pnlButtons = new JPanel();
        ButtonLayout buttonLayout = new ButtonLayout();
        buttonLayout.setGap(new NumberWithUnit(4, Unit.DLU));
        buttonLayout.setLeftMargin(new NumberWithUnit(3, Unit.DLU));
        buttonLayout.setRightMargin(new NumberWithUnit(3, Unit.DLU));
        pnlButtons.setLayout(new SwingPercentLayoutAdapter(buttonLayout));
        pnlButtons.add(new JButton("OK"));
        pnlButtons.add(new JButton("Cancel"));
        pnlButtons.add(new JButton("Help"));

        getContentPane().add(pnlMain, BorderLayout.CENTER);
        getContentPane().add(pnlButtons, BorderLayout.SOUTH);
    }

    public static void main(String[] args)
    {
        final SwingPercentLayoutExample exFrame = new SwingPercentLayoutExample();
        EventQueue.invokeLater(new Runnable()
        {
            public void run()
            {
                exFrame.setVisible(true);
            }
        });
    }
}
    ]]></source>
  </subsection>
  </section>
</body>

</document>