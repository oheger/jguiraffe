<!DOCTYPE html>
<!--
 | Generated by Apache Maven Doxia Site Renderer 1.9.2 from src/site/xdoc/userguide/actionbuilder.xml at 2021-07-28

 | Rendered using Apache Maven Default Skin
-->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="generator" content="Apache Maven Doxia Site Renderer 1.9.2" />
    <meta name="author" content="Oliver Heger" />
    <title>JGUIraffe &#x2013; Events and actions</title>
    <link rel="stylesheet" href="../css/maven-base.css" />
    <link rel="stylesheet" href="../css/maven-theme.css" />
    <link rel="stylesheet" href="../css/site.css" />
    <link rel="stylesheet" href="../css/print.css" media="print" />
  </head>
  <body class="composite">
    <div id="banner">
<a href=".././" id="bannerLeft"><img src="../images/giraffe.jpg"  alt="JGUIraffe"/></a>      <div class="clear">
        <hr/>
      </div>
    </div>
    <div id="breadcrumbs">
      <div class="xleft">
        <span id="publishDate">Last Published: 2021-07-28</span>
          &#xA0;| <span id="projectVersion">Version: 1.4-SNAPSHOT</span>
      </div>
      <div class="xright"><a href=".././" title="GitHub project">GitHub project</a>      </div>
      <div class="clear">
        <hr/>
      </div>
    </div>
    <div id="leftColumn">
      <div id="navcolumn">
       <h5>JGuiraffe</h5>
    <ul>
     <li class="none"><a href="../index.html" title="Home">Home</a></li>
     <li class="none"><a href="../introduction.html" title="Introduction">Introduction</a></li>
     <li class="none"><a href="../overview.html" title="Overview">Overview</a></li>
     <li class="none"><a href="../userguide/user_guide.html" title="User's Guide">User's Guide</a></li>
     <li class="none"><a href="../apidocs/index.html" title="Javadoc (latest)">Javadoc (latest)</a></li>
     <li class="none"><a href="../jguiraffe-parent/jguiraffe-examples/index.html" title="JGUIraffe Examples">JGUIraffe Examples</a></li>
     <li class="none"><a href="../building.html" title="Building from Source">Building from Source</a></li>
     <li class="none"><a href="../jguiraffe-parent/jguiraffe/changes-report.html" title="Changes Report">Changes Report</a></li>
    </ul>
       <h5>Modules</h5>
    <ul>
     <li class="none"><a href="../jguiraffe-parent/jguiraffe/index.html" title="JGUIraffe Core">JGUIraffe Core</a></li>
     <li class="none"><a href="../jguiraffe-parent/jguiraffe-swing/index.html" title="JGUIraffe Swing integration">JGUIraffe Swing integration</a></li>
     <li class="none"><a href="../jguiraffe-parent/jguiraffe-java-fx/index.html" title="JGUIraffe JavaFX integration">JGUIraffe JavaFX integration</a></li>
    </ul>
      <a href="http://maven.apache.org/" title="Built by Maven" class="poweredBy">
        <img class="poweredBy" alt="Built by Maven" src="../images/logos/maven-feather.png" />
      </a>
      </div>
    </div>
    <div id="bodyColumn">
      <div id="contentBox">


 
  <section>
<h2><a name="Events_and_actions"></a>Events and actions</h2>
  
<p>
    In the previous chapter about the component builder tag library we explained
    how different types of UI controls can be constructed and combined to
    graphical user interfaces. Now it is time to fill these user interfaces with
    functionality. Many applications require that manipulations on controls can
    be tracked so that they can react accordingly. Examples of such manipulations
    are a button that is pressed, a change in the selection of a list box, or
    text being entered into a text field. The UI logic of an application often
    demands that such manipulations affect other parts of the UI. Maybe the
    enabled state of some controls depends on the data entered into other
    controls, or detail views have to change so that they display the data of
    a selected table element.
  </p>
  
<p>
    In this chapter we discuss how these use cases are addressed by the
    <i>JGUIraffe</i> library. One key component in this area is another Jelly
    tag library that provides tags for registering listeners at components and
    for defining actions to be executed in reaction of changes on controls: the
    <i>action builder tag library</i>. Using this tag library it is also
    possible to define menus and tool bars that can be associated with windows.
    We will discuss these topics in the following sub sections.
  </p>

  <section>
<h3><a name="Basics_of_the_event_system"></a>Basics of the event system</h3>
  
<p>
    Most UI toolkits for Java use the classic <i>observer pattern</i> for
    dealing with manipulations on UI components: In order to be notified about
    such manipluations, client code has to implement specific listener
    interfaces and to register itself at the components of interest. Whenever a
    certain change in the status of a monitored component occurs, all registered
    listeners are called. Typically the methods of the listener interface
    expect a specific parameter object that contains information about the
    manipulation. These parameter objects are often called <i>events</i>, and
    the listeners registered at UI components are called <i>event listeners</i>.
  </p>
  
<p>
    Toolkits like Swing and SWT follow this approach. They define a multitude of
    event listener interfaces and corresponding event objects to allow an
    application to keep track of the several UI components it is comprised of.
    <i>JGUIraffe</i> also uses the concept of event listeners, but in contrast
    to the toolkits mentioned above, only a very limited number of events is
    supported. The philosophy is to abstract from low-level events; rather,
    only a few logic event types are defined. To make this clearer have a look
    at the many different event types Swing uses to indicate that a component
    has been changed in some way: a change of a text component is treated
    differently than a change of the selection of a list, a tree, or a table.
    For all these kinds of changes there are different event listener interfaces
    and event objects. <i>JGUIraffe</i> uses a single logic change event for
    all these components. This simplifies programming and should be sufficient
    in most cases. Typically the many different event listener interfaces do not
    provide any additional value because it is still required to query the
    affected component to find out the details about the change.
  </p>
  
<p>
    Here is an overview over the fundamental event types supported by the
    <i>JGUIraffe</i> library for graphical input elements (there are a
    couple of other event types related to special controls and windows which
    will be covered later).
  </p>
  
<p>
    </p>
<table class="bodyTable" border="1">
    
<tr class="a">
      
<th>Listener interface</th>
      
<th>Event object</th>
      
<th>Description</th>
    </tr>
    
<tr class="b">
      
<td valign="top">
      <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/event/FormActionListener.html">
      FormActionListener</a></code>
      </td>
      
<td valign="top">
      <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/event/FormActionEvent.html">
      FormActionEvent</a></code>
      </td>
      
<td>
      An action event typically means that the user wants the application to do
      something. Events of this type are issued for instance by buttons or menu
      items. In reaction of the event the listener has to initiate the operation
      that corresponds to the UI element that fired the event.
      </td>
    </tr>
    
<tr class="a">
      
<td valign="top">
      <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/event/FormChangeListener.html">
      FormChangeListener</a></code>
      </td>
      
<td valign="top">
      <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/event/FormChangeEvent.html">
      FormChangeEvent</a></code>
      </td>
      
<td>
      Change events have already been mentioned above. They are fired for all
      kinds of changes on different component types. Typically an application
      only has to be notified that <i>something</i> has changed. The exact
      nature of the change can then be determined by inspecting the affected
      component. One use case for change events is the implementation of dynamic
      UIs that change according to user actions. As an example consider a
      directory browser application: When the user selects another directory,
      the table showing the content of the current directory has to be refreshed.
      </td>
    </tr>
    
<tr class="b">
      
<td valign="top">
      <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/event/FormFocusListener.html">
      FormFocusListener</a></code>
      </td>
      
<td valign="top">
      <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/event/FormFocusEvent.html">
      FormFocusEvent</a></code>
      </td>
      
<td>
      Events of this type are fired when the user changes the keyboard focus
      from one component to another. This means that the user's interaction with
      one component has finished (and maybe a new interaction with another
      component starts). Focus events provide a good opportunity for validating
      the data the user has entered.
      </td>
    </tr>
    
<tr class="a">
      
<td valign="top">
      <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/event/FormMouseListener.html">
      FormMouseListener</a></code>
      </td>
      
<td valign="top">
      <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/event/FormMouseEvent.html">
      FormMouseEvent</a></code>
      </td>
      
<td>
      With this event type an application can react on mouse clicks or several
      other mouse gestures.
      </td>
    </tr>
    </table>
  
  
<p>
    While action and change events are more abstract and high-level events,
    focus and mouse events are more on a technical layer. They are needed to
    implement specific functionality around UI components. For instance, it is
    not necessary to register a mouse listener at a button component to find
    out whether the button is pressed by the user. The action event is used for
    this purpose. However, mouse listeners are required if an application wants
    to react on a double-click.
  </p>
  
<p>
    All event classes shown in the table above are derived from the base class
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/event/FormEvent.html">
    FormEvent</a></code>. From this base class they inherit some properties which
    are very useful during event processing:
    </p>
<ul>
    
<li>The name of the component that is affected by the event.</li>
    
<li>The <code><a href="../apidocs/net/sf/jguiraffe/gui/forms/ComponentHandler.html">
    ComponentHandler</a></code> of this component. Through this object access to
    the component is possible. For instance, its current data can be inspected.
    </li>
    
<li>The source of the event. This is the original event object fired by the
    underlying UI toolkit. <i>JGUIraffe</i> catches this event and wraps it
    into one of its event classes. Through this property it is available to an
    application.</li>
    </ul>
  
  
<p>
    So in order to retrieve events from UI components an application has to
    implement the corresponding event listener interfaces. But how does it
    register event listeners at the desired components? For this purpose
    <i>JGUIraffe</i> provides the
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/event/FormEventManager.html">
    FormEventManager</a></code> class. The current instance of
    this class can be obtained from the
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/components/ComponentBuilderData.html">
    ComponentBuilderData</a></code> object which holds central information about
    the builder operation currently in progress. (Refer to the section
    <a href="formbuilder.html#Fundamental_classes_and_interfaces">Fundamental
    classes and interfaces</a> for more information about this class and its
    role.) A reference to the <code>ComponentBuilderData</code> object is
    available to all form controllers automatically; other components can be injected a
    reference by means of the <a href="dibuilder.html">dependency injection
    builder</a>.
  </p>
  
<p>
    <code>FormEventManager</code> provides methods that allow registering and
    unregistering event listeners of all supported types for specific or all
    components of the current form. For instance, there are two overloaded
    variants of the <code>addActionListener()</code> method: one expects the
    name of a component and a <code>FormActionListener</code> object, the
    other one only takes a <code>FormActionListener</code> parameter. The former
    method registers the given action listener only at the specified component.
    The latter one registers the listener at all components that support action
    listeners. This is an extension to the functionality provided by most of the
    typical UI frameworks where only the registration at single components is
    supported. With this feature it is very easy to register &quot;global&quot;
    event listeners which allow a very generic event processing.
    <i>JGUIraffe</i> itself uses this feature for instance to implement a
    generic validation listener that is triggered whenever a component loses
    focus.
  </p>
  
<p>
    As an example we show how a change listener can be added to a checkbox
    component named <i>cbxFilter</i>. We assume that the
    <code>ComponentBuilderData</code> is already available in the variable
    <code>builderData</code>. Then the code for looking up the event manager and
    registering the listener would look as follows:
  </p>
    
<div class="source">
<pre>
FormEventManager eventManager = builderData.getEventManager();
eventManager.addChangeListener(&quot;cbxFilter&quot;, new FormChangeListener() {
    ...
});
    </pre></div>
  
<p>
    The major part of the components supported by <i>JGUIraffe</i> only
    deals with standard events (action, change, focus, and mouse). However,
    there are some exceptions. For instance, the
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/components/model/TreeHandler.html">
    TreeHandler</a></code> interface allows adding further tree-specific event
    listeners. To deal with such components, in addition to the methods
    operating on standard event handlers, <code>FormEventManager</code> provides
    a generic method for adding event handlers of an arbitrary type:
    <code>addEventHandler()</code>. This method expects the type of the event
    listener to be added as a string. This can be the name of a constant of the
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/event/FormListenerType.html">
    FormListenerType</a></code> enumeration class which defines all standard
    event listener types. In this case the <code>addEventListener()</code>
    methods behaves exactly as the corresponding specific
    <code>addXXXListener()</code> methods.
  </p>
  
<p>
    However, if the passed in listener type does not match one of the standard
    event types, the method tries to find a corresponding add method using
    reflection. This is based on a simple naming convention: if the string
    <i>Foo</i> is passed as event listener type, the corresponding method
    for registering event listeners must be called <i>addFooListener()</i>.
    (This corresponds to the naming conventions used within the JDK.) Using
    this mechanism it is possible to add arbitrary event listeners to components.
    The following example shows how a
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/components/model/TreeExpansionListener.html">
    TreeExpansionListener</a></code> object is registered at a
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/components/model/TreeHandler.html">
    TreeHandler</a></code>:
  </p>
    
<div class="source">
<pre>
FormEventManager eventManager = builderData.getEventManager();
TreeExpansionListener listener = new TreeExpansionListener() { ... };
eventManager.addEventListener(&quot;tree&quot;, &quot;Expansion&quot;, listener);
    </pre></div>
  
<p>
    Here <i>tree</i> is the name of the tree component.
    <code>addEventListener()</code> searches for a <code>ComponentHandler</code>
    object with the specified name. If it finds one, it calls the method for
    adding the event listener according to the described naming convention. In
    this example it would call the <code>addExpansionListener()</code> method.
    Analogously to the other methods for adding specific event listeners it is
    possible to pass in <b>null</b> for the component name. Then
    <code>addEventListener()</code> iterates over all component handler objects
    available and tries to find a corresponding method for adding the event
    listener. All handlers supporting such a method are called - the others are
    ignored. Using this mechanism it is possible for instance to add a
    <code>TreeExpansionListener</code> at all existing tree components in a
    single method call.
  </p>
  
<p>
    Working directly with <code>FormEventManager</code> is a programmatic
    approach to the registration of event listeners. The corresponding code
    can be placed for instance in initialization methods of
    <a href="formcontroller.html">Form controllers</a>. Later in this document
    we will see, that event listeners can also be registered using specialized
    tags in builder scripts. This is then a declarative approach. But before we
    come to this topic, we first have to discuss <i>actions</i> - the
    components that gave the <i>action builder tag library</i> its name.
  </p>
  </section>

  <section>
<h3><a name="Actions"></a>Actions</h3>
  
<p>
    <i>Actions</i> are a well-established concept in many UI libraries. For
    instance, they are supported by Swing and SWT. An action connects a
    graphical element in the user interface of an application to the operation
    the application should execute when this element is triggered by the user.
    Often the same could be achieved by event listeners registered directly at
    the corresponding UI elements. However, actions are concepts on a higher
    abstraction level and provide some advantages over plain event listeners.
    The main advantage is probably that actions are independent on specific UI
    elements; actually they can be associated with multiple UI elements at once.
    This is especially useful when an application allows its users to execute a
    command in various ways. This pattern is used frequently, for instance, a
    certain operation can be accessed as a menu item or as a tool bar button. If
    this operation is realized as an action, the logic for executing this
    operation can be implemented in a central place. So actions provide a
    sophisticated programming model that supports the separation between UI and
    business logic.
  </p>
  
<p>
    Another advantage of actions is that they also influence the UI elements
    associated with them. For instance, if an action is temporarily not available
    (e.g. due to restrictions in the business logic), it can be disabled. Then
    all associated UI elements are automatically disabled - the developer does
    not have to remember all components affected by the action and disable them
    manually.
  </p>
  
<p>
    Because of their mediator role between the UI and application logic actions
    are twofold: They have a set of properties related to their visual
    representation and also refer to the logic to be executed when they are
    triggered. The visual properties come into play when an action is associated
    with a UI element like a tool bar button; then the UI element initializes
    some of its properties (e.g. label, icon, accelerator, etc.) from the data
    stored by the action. The action is also automatically registered as event
    listener at the associated UI element. When the element fires an action
    event, the action is notified and ensures that the logic is executed.
  </p>
  
<p>
    The actions provided by the <i>JGUIraffe</i> library comply to this
    generic description in all points. Programmatically they are represented by
    the <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/action/FormAction.html">
    FormAction</a></code> interface. This interface is a bit minimalistic; it
    only provides access to properties related to the execution of an action.
    No visual properties can be queried here. This is due to the fact that for
    the action framework such visual properties are of less importance. They are
    evaluated by code that is specific to the underlying UI platform (e.g. Swing
    or SWT) when the action is associated with a specific UI element. After that
    the framework only has to ensure that the action is correctly executed when
    it is triggered. This also conforms to the declarative approach taken by
    <i>JGUIraffe</i>: Actions are defined in builder scripts (as we will see
    soon). When client code obtains an action object it has already been fully
    initialized and can now be used to control its execution.
  </p>
  
<p>
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/action/FormAction.html">
    FormAction</a></code> provides access to the following properties:
    </p>
<ul>
    
<li>Actions are assigned a name at creation time that cannot be changed
    later. The name can be used for instance to lookup the action in a bean
    context.</li>
    
<li>The <code>enabled</code> flag: Using this property actions can be
    disabled and enabled. A disabled action cannot be executed. The enabled
    status is also reflected by UI elements associated with the action; for
    instance, a button is grayed out if its action is disabled.</li>
    
<li>The <code>checked</code> flag: Some actions do not execute code when they
    are triggered, but only changed their <code>checked</code> status. Such
    actions behave similar to checkboxes. They are often used to represent a
    global status of an application. Graphically they are represented by checkable
    menu items or toggle buttons in the tool bar. Using the <code>checked</code>
    property the action's <code>checked</code> status can be queried and set.</li>
    
<li><code>FormAction</code> objects are associated with a task that is
    executed when the action is triggered. This is a difference to the action
    implementations in typical UI frameworks like Swing or SWT where actions
    directly implement the logic they represent. The possibility to dynamically
    change the task of an action allows for very flexible applications. As task
    of an action an object can be set that implements one of the following
    interfaces:
      
<ul>
      
<li><code>java.lang.Runnable</code>: This is the standard interface used
      by the JDK to represent an executable task. Its simple <code>run()</code>
      method does not support any parameters or exceptions.</li>
      
<li><code><a href="../apidocs/net/sf/jguiraffe/gui/builder/action/ActionTask.html">
      ActionTask</a></code> is a slightly enhanced version of the
      <code>Runnable</code> interface. It also defines a <code>run()</code>
      method, but this variant expects some more parameters which can be
      evaluated by an implementation. For instance, a reference to the action
      that is currently executed is passed.</li>
      </ul>
    </li>
    
<li>In addition to these properties <code>FormAction</code> defines an
    <code>execute()</code> method which triggers the action.</li>
    </ul>
  
  
<p>
    In many cases client code does not have to deal with <code>FormAction</code>
    objects directly. They are declared and initialized in a builder script and
    then work automatically, i.e. they are executed when the user interacts
    with the associated UI elements without intervention of the application. So
    how are actions created? Take a look at the following fragment of a builder
    script for some example action declarations:
  </p>
    
<div class="source">
<pre>
  &lt;!-- File new action --&gt;
  &lt;a:action name=&quot;fileNewAction&quot; textres=&quot;act_filenew_text&quot;
    tooltipres=&quot;act_filenew_tip&quot; mnemonicres=&quot;act_filenew_mnemo&quot;
    acceleratorDef=&quot;CONTROL F1&quot; taskBean=&quot;openNewFileDialogTask&quot;&gt;
    &lt;f:icon resource=&quot;new.gif&quot;/&gt;
  &lt;/a:action&gt;

  &lt;!-- File open action --&gt;
  &lt;a:action name=&quot;fileOpenAction&quot; textres=&quot;act_fileopen_text&quot;
    tooltipres=&quot;act_fileopen_tip&quot; mnemonicres=&quot;act_fileopen_mnemo&quot;
    group=&quot;SINGLE_FILE&quot; taskBean=&quot;dummyTask&quot;&gt;
    &lt;f:icon resource=&quot;open.gif&quot;/&gt;
  &lt;/a:action&gt;

  &lt;!-- Edit cut action --&gt;
  &lt;a:action name=&quot;editCutAction&quot; textres=&quot;act_editcut_text&quot;
    tooltipres=&quot;act_editcut_tip&quot; mnemonicres=&quot;act_editcut_mnemo&quot;
    group=&quot;SELECTION&quot; acceleratorDef=&quot;control x&quot; taskBean=&quot;dummyTask&quot;/&gt;
    </pre></div>
  
<p>
    This script defines three different actions. As can be seen, actions are
    created using the <code>&lt;a:action&gt;</code> tag which is implemented by
    the <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/action/tags/ActionTag.html">
    ActionTag</a></code> class. (We assume that the <i>action builder tag
    library</i> is associated with the namespace prefix &quot;a&quot;. This means
    that the Jelly script must contain the attribute declaration
    <code>xmlns:a=&quot;actionBuilder&quot;</code> in its root element.) Using this tag
    the following properties of an action can be set:
    </p>
<ul>
    
<li>The name of the action which is mandatory.</li>
    
<li>The action can be assigned a (display) text. It can be set either
    directly or through a resource ID in the usual way.</li>
    
<li>Actions can also have a tool tip. Again the text of the tool tip can be
    specified directly or as a resource ID.</li>
    
<li>The definition of a mnemonic allows for better keyboard support. For
    instance, if the action is associated with a menu item, the mnemonic is an
    underlined character in the text of the menu item. By typing this character
    the menu item is executed.</li>
    
<li>An accelerator also associates the action with a keyboard action. However,
    in contrast to a mnemonic an accelerator is globally available; it is a direct
    keyborad shortcut for invoking the action. Refer to the
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/action/Accelerator.html">
    Accelerator</a></code> class for a detailed description of accelerators and
    the syntax used to define them.</li>
    
<li>An icon for the action can be defined by a nested
    <code>&lt;f:icon&gt;</code> tag.</li>
    
<li>Actions can be added to groups. This is convenient for actions that are
    logically related. Action groups allow some operations on the elements they
    contain; for instance, it is possible to disable all actions in a group at
    once.</li>
    
<li>Finally, the task of the action can be specified. The name passed to
    the <code>taskBean</code> attribute is looked up in the current bean
    context. It may have been created using the <i>dependency injection
    framework</i>.</li>
    </ul>
  
  
<p>
    After these declarations fully initialized <code>FormAction</code> objects
    exist and are available in the current context. In the next section we will
    see how we can reuse these objects in order to create corresponding UI
    elements.
  </p>
  </section>

  <section>
<h3><a name="Main_menus_and_tool_bars"></a>Main menus and tool bars</h3>
  
<p>
    The <i>action builder tag library</i> provides a set of tags for the
    creation of menus and tool bars. Because menu items and tool bar buttons
    are the default controls to be associated with actions it is reasonable to
    let these components be handled by the same part of the framework. Menus and
    tool bars should be familiar to most developers so there is not much to say
    about them. Let's dive into an example of a menu definition directly:
  </p>
    
<div class="source">
<pre>
  &lt;a:menubar name=&quot;mainMenu&quot;&gt;
    &lt;a:menu textres=&quot;menu_file_text&quot; mnemonicres=&quot;menu_file_mnemo&quot;&gt;
      &lt;a:menuitem actionName=&quot;fileNewAction&quot;/&gt;
      &lt;a:menuitem actionName=&quot;fileOpenAction&quot;/&gt;
      &lt;a:menuitem actionName=&quot;fileEditAction&quot;/&gt;
      &lt;a:menuitem actionName=&quot;filePrintAction&quot;/&gt;
      &lt;a:separator/&gt;
      &lt;a:menuitem actionName=&quot;exitAction&quot;/&gt;
    &lt;/a:menu&gt;
    &lt;a:menu textres=&quot;menu_edit_text&quot; mnemonicres=&quot;menu_edit_mnemo&quot;&gt;
      &lt;a:menuitem actionName=&quot;editCutAction&quot;/&gt;
      &lt;a:menuitem actionName=&quot;editCopyAction&quot;/&gt;
      &lt;a:menuitem actionName=&quot;editPasteAction&quot;/&gt;
      &lt;a:separator/&gt;
      &lt;a:menuitem actionName=&quot;editRefreshAction&quot;/&gt;
      &lt;a:separator/&gt;
      &lt;a:menuitem actionName=&quot;editDeleteAction&quot;/&gt;
    &lt;/a:menu&gt;
    &lt;a:menu textres=&quot;menu_extras_text&quot; mnemonicres=&quot;menu_extras_text&quot;&gt;
      &lt;a:menuitem actionName=&quot;extrasViewDefAction&quot;/&gt;
      &lt;a:separator/&gt;
      &lt;a:menuitem actionName=&quot;extrasSettingsAction&quot;/&gt;
      &lt;a:menuitem actionName=&quot;extrasLongOpAction&quot;/&gt;
    &lt;/a:menu&gt;
  &lt;/a:menubar&gt;
    </pre></div>
  
<p>
    This fragment of a builder script defines the main menu of an application: a
    menu bar with three menus. The items of the menus are defined through
    actions (which are specified using the <code>actionName</code>). Here the
    actions defined in the last example (and some more) are referenced. Of
    course, the names passed to the <code>actionName</code> attribute must point
    to valid actions that have been declared before in this builder script or
    are available in the parent bean context. We give a short overview over the
    tags involved:
  </p>
  
<p>
    </p>
<table class="bodyTable" border="1">
    
<tr class="a">
      
<th>Tag</th>
      
<th>Implementation class</th>
      
<th>Description</th>
    </tr>
    
<tr class="b">
      
<td valign="top"><code>&lt;a:menubar&gt;</code></td>
      
<td valign="top">
      <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/action/tags/MenuBarTag.html">
      MenuBarTag</a></code>
      </td>
      
<td>
      Defines a menu bar. This is the top-level element of a menu definition. It
      has a mandatory <code>name</code> attribute. The whole menu bar created by
      this tag is stored in the current bean context under this name. The name
      can then be used to reference the menu from a window.
      </td>
    </tr>
    
<tr class="a">
      
<td valign="top"><code>&lt;a:menu&gt;</code></td>
      
<td valign="top">
      <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/action/tags/MenuTag.html">
      MenuTag</a></code>
      </td>
      
<td>
      This tag adds a menu to a menu bar or another menu. It can be placed in
      the body of a <code>&lt;a:menubar&gt;</code> tag or another
      <code>&lt;a:menu&gt;</code> tag. The menu is defined by its text (which
      can either be set directly or through a resource ID) and an optional icon.
      A mnemonic can also be defined. Menus are no active elements themselves;
      they merely serve as containers in which other active elements - mainly
      menu items - are placed.
      </td>
    </tr>
    
<tr class="b">
      
<td valign="top"><code>&lt;a:menuitem&gt;</code></td>
      
<td valign="top">
      <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/action/tags/MenuItemTag.html">
      MenuItemTag</a></code>
      </td>
      
<td>
      The <code>&lt;a:menuitem&gt;</code> tag defines the content of a menu.
      Each tag creates an entry in the menu that can be selected by the user
      to initiate an operation. We will discuss the different options supported
      by this tag below.
      </td>
    </tr>
    
<tr class="a">
      
<td valign="top"><code>&lt;a:separator&gt;</code></td>
      
<td valign="top">
      <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/action/tags/SeparatorTag.html">
      SeparatorTag</a></code>
      </td>
      
<td>
      This tag can be used to group menu items. It creates a thin line in a menu
      to separate groups of menu items. It has no further functionality.
      </td>
    </tr>
    </table>
  
  
<p>
    This example script fragment shows that a declarative approach for defining
    menus works pretty well. The hierarchical structure of XML fits well to the
    organization of a menu bar with menus and sub menus. The same menu setup in
    Java code as a series of constructor calls is by far less readable.
  </p>
  
<p>
    All menu items defined by the script are associated with an action whose
    name is passed to the <code>actionName</code> attribute. Under the hood, this
    causes a menu item to be created whose properties are initialized from the
    properties set for the associated action. Constructing menu items from
    actions is the preferred option. It allows using all of the advantages of
    actions. Also, there is no need to manually register an event listener
    because the action is automatically connected with the menu item and gets
    triggered when the user selects the item.
  </p>
  
<p>
    Alternatively the <code>&lt;a:menuitem&gt;</code> tag supports a similar set
    of attributes as used by the <code>&lt;a:action&gt;</code> tag for setting
    the properties of an action (text, mnemonic, accelerator and so on). With
    these attributes the appearance of the menu item can be defined manually.
    If this approach is used, the developer has to add an event listener
    explicitly. In order to do so, the menu item must be assigned a name through
    the <code>name</code> attribute. In this case a <code>ComponentHandler</code>
    is created for the menu item and stored in the current context. The
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/event/FormEventManager.html">
    FormEventManager</a></code> class can then be used to register an action
    listener as discussed in the section <a href="#Basics_of_the_event_system">
    Basics of the event system</a>. It is also possible to use the
    declarative approach for registering an event listener that will be discussed
    below.
  </p>
  
<p>
    So much for menus, we now move on to tool bars. The declarations in a
    builder script that define a tool bar look similar to menu definitions as
    demonstrated by the following snippet:
  </p>
    
<div class="source">
<pre>
  &lt;w:frame titleres=&quot;main_title&quot; menu=&quot;mainMenu&quot; autoClose=&quot;false&quot;&gt;
    &lt;f:panel&gt;
      &lt;f:borderlayout/&gt;
      &lt;!-- A tool bar at the top of the window's content --&gt;
      &lt;a:toolbar&gt;
        &lt;f:borderconstr name=&quot;NORTH&quot;/&gt;
        &lt;a:toolbutton actionName=&quot;fileNewAction&quot;/&gt;
        &lt;a:separator/&gt;
        &lt;a:toolbutton actionName=&quot;fileOpenAction&quot;/&gt;
        &lt;a:toolbutton actionName=&quot;fileEditAction&quot;/&gt;
        &lt;a:toolbutton actionName=&quot;filePrintAction&quot;/&gt;
        &lt;a:separator/&gt;
        &lt;a:toolbutton actionName=&quot;editRefreshAction&quot;/&gt;
      &lt;/a:toolbar&gt;
      ...
    &lt;/f:panel&gt;
  &lt;/w:frame&gt;
    </pre></div>
  
<p>
    There is one obvious difference between menu bars and tool bars: Menus are
    declared as stand-alone components while tool bars are really integrated in
    the UI of the window they belong to. This example defines a frame window
    (the tags for constructing windows are subject of the next chapter). The
    content of the window consists of a panel with a
    <a href="layouts.html#BorderLayout">BorderLayout</a>. The tool bar is added
    to the <i>north</i> of the frame's content panel. This is the typical
    pattern for defining tool bars. All tags involved in the definition of a
    tool bar are listed in the following table:
  </p>
  
<p>
    </p>
<table class="bodyTable" border="1">
    
<tr class="a">
      
<th>Tag</th>
      
<th>Implementation class</th>
      
<th>Description</th>
    </tr>
    
<tr class="b">
      
<td valign="top"><code>&lt;a:toolbar&gt;</code></td>
      
<td valign="top">
      <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/action/tags/ToolbarTag.html">
      ToolbarTag</a></code>
      </td>
      
<td>
      The top-level tag for defining a tool bar. The tag does not have any
      special attributes other than the ones inherited by the super class.
      </td>
    </tr>
    
<tr class="a">
      
<td valign="top"><code>&lt;a:toolbutton&gt;</code></td>
      
<td valign="top">
      <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/action/tags/ToolButtonTag.html">
      ToolButtonTag</a></code>
      </td>
      
<td>
      With this tag a single tool bar button can be added. So a sequence of these
      tags populates the tool bar.
      </td>
    </tr>
    
<tr class="b">
      
<td valign="top"><code>&lt;a:separator&gt;</code></td>
      
<td valign="top">
      <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/action/tags/SeparatorTag.html">
      SeparatorTag</a></code>
      </td>
      
<td>
      The <code>&lt;a:separator&gt;</code> tag has already been introduced in the
      discussion about menus. It can be used for tool bars, too, to logically
      group single buttons. This time it produces a gap between buttons.
      </td>
    </tr>
    </table>
  
  
<p>
    Most comments we made for menu items also apply to tool bar buttons. Again a
    button can either be defined by associating it with an action or by manually
    setting the corresponding properties. Note that partly the same actions were
    used for menu items as for tool bar buttons. In this case both elements
    trigger the same action.
  </p>
  </section>

  <section>
<h3><a name="Popup_menus"></a>Popup menus</h3>
  
<p>
    The menus discussed in the previous section provide commands available for
    the whole application - they are application-global. <i>Popup menus</i> in
    constrast are associated with a single component of the application and
    allow access to functionality specific for this component. The user clicks
    on a specific location on the screen and is displayed a menu with options
    related to this position. Therefore menus of this type are also refered to
    as <i>context menus</i>.
  </p>
  
<p>
    While global menus are pretty static, popup menus are often more dynamic in
    nature. Their content may vary depending on the status of the component
    they are associated with. Consider a table listing the files and sub
    directories of a specific directory. A popup menu for this table can show
    different items depending on the current selection: if a file is selected,
    other options may be available than for a sub directory; other options may
    be always visible.
  </p>
  
<p>
    The <i>action builder tag library</i> supports assigning popup menus to
    specific components. It pays special attention to the dynamic nature of such
    menus because they are not specified directly, but a class has to be
    provided which is able to create the menu on demand. For this purpose the
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/action/PopupMenuHandler.html">
    PopupMenuHandler</a></code> interface exists. Internally, <i>JGUIraffe</i>
    installs the appropriate event listeners listening for a gesture that should
    bring up a popup menu - for most platforms this is a click of the right
    mouse button. If a fitting event is detected, the <code>PopupMenuHandler</code>
    is invoked. It can then create a menu based on arbitrary criteria.
  </p>
  
<p>
    <code>PopupMenuHandler</code> is a simple interface defining only a single
    method: <code>constructPopup()</code>. This method is passed a
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/action/PopupMenuBuilder.html">
    PopupMenuBuilder</a></code> object which can be used to define the content
    of the menu. The <code>PopupMenuBuilder</code> interface defines several
    <code>addXXX()</code> methods for adding different types of objects to the
    popup menu under construction: actions, sub menus, or separators. There is
    also a <code>create()</code> method that has to be called after the menu's
    content has been defined. It causes the menu to be created and displayed.
    Actually, the <code>PopupMenuHandler</code> can decide not to call the
    <code>create()</code> method - in this case no menu will be shown.
  </p>
  
<p>
    Let's come to an example: We stay with the table showing the content of a
    directory. To this table a context menu is to be added. The menu should
    offer operations on the files or directories currently selected. However,
    some operations are only available if the selection contains a single file
    object only. The corresponding actions are grouped together in an action
    group called <i>SINGLE_FILE</i>. The implementation of the
    <code>PopupMenuHandler</code> interface obtains all actions belonging to
    this group and adds them to the menu only if they are enabled. After that it
    adds some actions that are always active.
  </p>
    
<div class="source">
<pre>
package net.sf.jguiraffe.examples.tutorial.mainwnd;

import net.sf.jguiraffe.gui.builder.action.ActionBuilder;
import net.sf.jguiraffe.gui.builder.action.ActionStore;
import net.sf.jguiraffe.gui.builder.action.FormAction;
import net.sf.jguiraffe.gui.builder.action.FormActionException;
import net.sf.jguiraffe.gui.builder.action.PopupMenuBuilder;
import net.sf.jguiraffe.gui.builder.action.PopupMenuHandler;
import net.sf.jguiraffe.gui.builder.components.ComponentBuilderData;

public class TablePopupHandler implements PopupMenuHandler
{
    /** An array with the names of actions that are always present. */
    private static final String[] ACTIVE_ACTIONS = {
            &quot;editDeleteAction&quot;, &quot;editRefreshAction&quot;
    };

    @Override
    public void constructPopup(PopupMenuBuilder builder,
            ComponentBuilderData compData) throws FormActionException
    {
        ActionStore as = (ActionStore) compData.getBeanContext().getBean(
                ActionBuilder.KEY_ACTION_STORE);

        // Handle group with actions for a single file selection
        boolean enabled = false;
        for (String name : as.getActionNamesForGroup(&quot;SINGLE_FILE&quot;))
        {
            FormAction action = as.getAction(name);
            if (action.isEnabled())
            {
                builder.addAction(action);
                enabled = true;
            }
        }

        if (enabled)
        {
            builder.addSeparator();
        }

        // Actions that are always contained in the menu
        for (String name : ACTIVE_ACTIONS)
        {
            builder.addAction(as.getAction(name));
        }

        // Display the menu
        builder.create();
    }
}
    </pre></div>
  
<p>
    This listing also demonstrates the usage of some of the helper classes
    related to action management. The
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/action/ActionStore.html">
    ActionStore</a></code> class manages all action objects and action groups
    defined in the current builder script and allows access to them by name.
    The current instance of this class can be queried from the bean context as
    shown in the example code. Using the <code>ActionStore</code> object the
    names of the actions in the <i>SINGLE_FILE</i> action group can be
    obtained. The code iterates over this set and calls the popup builder's
    <code>addAction()</code> method only if the action is enabled. This assumes
    that there are other components in place which control the enabled status
    of the actions in the group based on the table's current selection. This is
    probably handled by a change event listener registered at the table. If at
    least one action of the group was enabled, a separator is added to the popup
    menu, so the actions of the group are visually separated from the other
    ones. Finally the actions that should always be visible are added to the
    menu. As the very last operation the popup handler calls the builder's
    <code>create()</code> method to actually display the menu.
  </p>
  
<p>
    Now that the logic for creating the menu is available, how can it be
    connected to the table component? For this purpose the <i>action builder
    tag library</i> provides the <code>&lt;a:popup&gt;</code> tag which is
    implemented by the
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/action/tags/PopupHandlerTag.html">
    PopupHandlerTag</a></code> class. The tag has to be placed in the body of
    the input component tag for the element the menu is to be added to:
  </p>
    
<div class="source">
<pre>
  &lt;f:table name=&quot;table&quot; model=&quot;tableModel&quot; multiSelection=&quot;true&quot;&gt;
    ...
    &lt;!-- Add a context menu to the table --&gt;
    &lt;a:popup class=&quot;net.sf.jguiraffe.examples.tutorial.mainwnd.TablePopupHandler&quot;/&gt;
  &lt;/f:table&gt;
    </pre></div>
  
<p>
    The example showed how the content of the popup menu can vary depending on
    certain criteria: some actions were only added to the builder if they were
    enabled. If you have a popup menu that should always display the same menu
    items, you probably do not want to implement a separate
    <code>PopupMenuHandler</code> class for it - especially as it would be
    pretty trivial. <i>JGUIraffe</i> provides a default implementation of the
    interface that can be used in such cases:
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/action/SimplePopupMenuHandler.html">
    SimplePopupMenuHandler</a></code>. When an instance of this class is created
    it is passed a collection with the content of the popup menu to be constructed.
    This collection can contain objects of the following types:
    </p>
<ul>
    
<li><code>FormAction</code> objects are added to the builder using its
    <code>addAction()</code> method. They become menu items in the generated
    menu.</li>
    
<li>Other <code>SimplePopupMenuHandler</code> objects are used to create
    sub menus. In this case the popup menu has a sub menu whose content is
    defined by the <code>SimplePopupMenuHandler</code> object. This can be
    nested to an arbitrary depth.</li>
    
<li>A <b>null</b> reference in the collection causes a separator to be added
    to the popup menu.</li>
    </ul>
  
  
<p>
    Using features of the <i>dependency injection framework</i> it is possible
    to define <code>SimplePopupMenuHandler</code> instances completely in
    builder scripts. That way static popup menus can be created and assigned to
    components without programming. We present an example that is about a text
    area control. The text area allows the user to insert several pre-defined
    text fragments and to clear its content. These operations should be made
    available through a popup menu. The popup menu consists of a sub menu with
    the several insert operations and a menu item for clearing the text. So two
    <code>SimplePopupMenuHandler</code> definitions are needed: one for the sub
    menu and one for the main popup menu. The definitions can look as follows
    (the actions referred to have been dropped):
  </p>
    
<div class="source">
<pre>
  &lt;!-- Action data definition for the append sub menu in the popup menu --&gt;
  &lt;a:actionData textres=&quot;newfile_men_append_text&quot;
    mnemonicres=&quot;newfile_men_append_mnemo&quot; var=&quot;menuAppend&quot;/&gt;

  &lt;!-- Popup menu handler for the append sub menu --&gt;
  &lt;di:bean name=&quot;appendMenu&quot;
    beanClass=&quot;net.sf.jguiraffe.gui.builder.action.SimplePopupMenuHandler&quot;&gt;
    &lt;di:constructor&gt;
      &lt;di:param&gt;
        &lt;di:list&gt;
          &lt;di:element refName=&quot;action:addContentLoremIpsumAction&quot;/&gt;
          &lt;di:element refName=&quot;action:addContentXMLAction&quot;/&gt;
          &lt;di:element refName=&quot;action:addContentHTMLAction&quot;/&gt;
        &lt;/di:list&gt;
      &lt;/di:param&gt;
    &lt;/di:constructor&gt;
    &lt;di:setProperty property=&quot;actionData&quot; refName=&quot;menuAppend&quot;/&gt;
  &lt;/di:bean&gt;

  &lt;!-- Popup menu handler for the text area's content menu --&gt;
  &lt;di:bean name=&quot;fileContentPopupHandler&quot;
    beanClass=&quot;net.sf.jguiraffe.gui.builder.action.SimplePopupMenuHandler&quot;&gt;
    &lt;di:constructor&gt;
      &lt;di:param&gt;
        &lt;di:list&gt;
          &lt;di:element refName=&quot;appendMenu&quot;/&gt;
          &lt;di:element refName=&quot;action:clearContentAction&quot;/&gt;
        &lt;/di:list&gt;
      &lt;/di:param&gt;
    &lt;/di:constructor&gt;
  &lt;/di:bean&gt;
    </pre></div>
  
<p>
    This example uses the <code>&lt;di:list&gt;</code> tag of the <i>dependency
    injection framework</i> to create the lists that have to be passed to the
    <code>SimplePopupMenuHandler</code> objects. In most cases the list elements
    are actions obtained from the current bean context. Note how the reserved
    prefix <i>action:</i> is used to reference the desired actions. The first
    <code>SimplePopupMenuHandler</code> declaration represents the sub menu. It
    is referenced by the second one. The visual properties of the sub menu - e.g.
    its text, mnemonic, or icon - are obtained from the
    <code>SimplePopupMenuHandler</code> instance. In order to initialize them,
    the definition contains a <code>&lt;di:setProperty&gt;</code> tag for the
    <i>ActionData</i> property. Using this property all visual properties
    related to actions can be set at once. With the
    <code>&lt;a:actionData&gt;</code> tag it is possible to create a
    corresponding data object for these properties. The example fragment
    demonstrates how this tag is used. The data object created by the tag is
    stored under the name determined by the <code>var</code> attribute and is later
    referenced by the <code>&lt;di:setProperty&gt;</code> tag. More information
    can be found at the
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/action/tags/ActionDataTag.html">
    ActionDataTag</a></code> class. The following fragment shows how the main
    <code>SimplePopupMenuHandler</code> bean is associated with the text area
    control:
  </p>
    
<div class="source">
<pre>
  &lt;f:textarea name=&quot;fileContent&quot; displayNameres=&quot;newfile_disp_content&quot;&gt;
    ...
    &lt;a:popup beanName=&quot;fileContentPopupHandler&quot;/&gt;
  &lt;/f:textarea&gt;
    </pre></div>
  
<p>
    Result is a popup menu with a nested sub menu:
  </p>
  <img src="../images/userguide/Popup.png" alt="Popup menu" />
  </section>

  <section>
<h3><a name="Declarative_event_listener_registration"></a>Declarative event listener registration</h3>
  
<p>
    In the section <a href="#Basics_of_the_event_system">Basics of the event
    system</a> we have used the <code>FormEventManager</code> class to register
    event listeners at input elements. While this programmatic registration
    surely makes sense in some situations it is not really compatible with the
    declarative approach of declaring UIs: after the builder script was run you
    still have to do some tasks related to the initialization of the UI. It
    would be nice if event listeners could be directly registered in the script,
    too.
  </p>
  
<p>
    Well, the <i>action builder tag library</i> provides such functionality.
    It offers some tags that allow the registration of event listeners at
    components defined in the builder script. There are even two different
    approaches: a simple one that simulates the direct usage of the
    <code>FormEventManager</code> class as described in the section
    <a href="#Basics_of_the_event_system">Basics of the event system</a>, and
    a more advanced one that is based on actions. We start with the simple
    approach.
  </p>
  
<p>
    Normal registrations of event listeners can be done using the
    <code>&lt;a:eventListener&gt;</code> tag which is implemented by the
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/action/tags/EventRegistrationTag.html">
    EventRegistrationTag</a></code> class. Basically, this tag operates like the
    generic <code>addEventHandler()</code> method of
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/event/FormEventManager.html">
    FormEventManager</a></code>: it locates the component of interest, evaluates
    the listener type (which can be either a standard type like <i>action,
    change</i>, or <i>focus</i> or a custom type), and registers the
    specified listener. We present an example in which a change listener is
    registered at a checkbox:
  </p>
    
<div class="source">
<pre>
&lt;!-- The event listener bean --&gt;
&lt;di:bean name=&quot;cbxListener&quot; beanClass=&quot;...&quot;&gt;
  ...
&lt;/di:bean&gt;

&lt;a:eventListener component=&quot;cbx&quot; eventType=&quot;CHANGE&quot; beanName=&quot;cbxListener&quot;/&gt;
    </pre></div>
  
<p>
    The <code>eventType</code> attribute defines the type of listener to
    register. In this case, with the type <i>change</i> (case does not matter)
    a default listener type is used. For non-standard types the same naming
    conventions apply as discussed for the <code>addEventHandler()</code>
    method of <code>FormEventManager</code>. For instance, to register an
    expansion listener for a tree, the event type would be <i>Expansion</i>.
  </p>
  
<p>
    In this example the event listener to register is specified through the
    <code>beanName</code> attribute which references a bean defined by tags of
    the <i>dependency injection builder library</i>. It is also possible to
    specify the <code>class</code> attribute and set it to the fully qualified
    name of the listener class. Then a new instance of this class would be
    created. However, the approach with the <code>beanName</code> attribute is
    more powerful because the whole feature set of bean declarations can be used.
  </p>
  
<p>
    Finally, the component to which the listener should be added has to be
    provided. For this purpose there are multiple options:
    </p>
<ul>
    
<li>With the <code>component</code> attribute the name of an input component
    can be specified. The tag searches for a <code>ComponentHandler</code> with
    this name in the current context and tries to add the listener to this
    handler. This is probably the most basic use case when dealing with event
    listeners.</li>
    
<li>Alternatively it is possible to place the
    <code>&lt;a:eventListener&gt;</code> tag in the body of another input
    component tag. Then the listener will be registered at this component.</li>
    
<li>With the <code>targetBean</code> attribute an arbitrary object can be
    defined as target of the registration. The name specified here is looked up
    in the current bean context. The resulting bean need not be a component
    handler; registration is performed through reflection, so the only
    requirement is that a method exists whose name corresponds to the listener
    type. This also allows adding event listeners to native UI elements.</li>
    
<li>There is another option available for registering the listener at
    multiple components: if the <code>multiple</code> attribute is set to
    <b>true</b>, the tag searches for all <code>ComponentHandler</code> objects
    in the current form that are compatible with the specified listener type.
    The specified event listener is registered at all matching handlers. This
    corresponds to the functionality of <code>FormEventManager</code> to
    register &quot;global&quot; event listeners. When using the
    <code>multiple</code> attribute there must not be a component name nor a
    target bean name.</li>
    </ul>
  
  
<p>
    As another example we show how a menu item can be declared without the
    reference to an action and then be connected to an event listener. As stated
    in the section <a href="#Main_menus_and_tool_bars">Main menus and tool bars</a>,
    it is recommended to use actions for the definition of menu items and tool
    bar buttons because this approach is more flexible. However, if a menu item
    is more or less static, and the functionality it represents is only located
    in the menu and not in other places, it is easier to declare it directly.
    The following fragment from a builder script shows an excerpt from a menu
    definition followed by a tag which assigns an event listener to the
    <i>Cut</i> item from the <i>Edit</i> menu (the declaration of the event
    listener bean has been omitted):
  </p>
    
<div class="source">
<pre>
    ...
    &lt;a:menu text=&quot;Edit&quot; mnemonic=&quot;E&quot;&gt;
      &lt;a:menuitem name=&quot;editCut&quot; text=&quot;Cut&quot; mnemonic=&quot;C&quot; acceleratorDef=&quot;CONTROL X&quot;/&gt;
      ...
    &lt;/a:menu&gt;
    ...
  &lt;a:eventListener component=&quot;editCut&quot; eventType=&quot;ACTION&quot; beanName=&quot;cutListener&quot;/&gt;
    </pre></div>
  
<p>
    Note the following points:
    </p>
<ul>
      
<li>The menu item is assigned a name via the <i>name</i> attribute. This
      causes it to be stored as a UI component so that it can be referenced later
      on.</li>
      
<li>The <code>&lt;eventListener&gt;</code> tag uses the same name in its
      <i>component</i> attribute.</li>
      
<li>The event type is <i>action</i>; the referenced listener bean must
      implement the
      <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/event/FormActionListener.html">
      FormActionListener</a></code> interface.</li>
    </ul>
  
  
<p>
    So using the <code>&lt;a:eventListener&gt;</code> tag the same functionality
    is available as when using <code>FormEventManager</code> directly. Before
    we end this discussion, we want to add some words about the creation of
    event listeners:
  </p>
  
<p>
    In typical UI programming it is often the case that anonymous inner classes
    are used as event listeners. They are declared in the code that constructs
    the UI and directly added to the components they should monitor. This is
    convenient and has the advantage that the listener can access all members
    of the enclosing class - typically an event listener needs access to other
    components, e.g. to manipulate the state of input elements or to change
    properties of beans. However, the big disadvantage of this approach is that
    logic is cluttered and mixed with code for constructing the UI.
  </p>
  
<p>
    Using the declarative approach for registering event listeners together with
    the features of the <i>dependency injection framework</i> does not have
    this drawback. Event listener classes can be declared as regular top-level
    classes, maybe in a separate package for classes that deal with view logic.
    If a listener class needs references to other objects (graphical components
    or other beans like controllers), these dependencies can be automatically
    injected when the listener bean is created. To make this clearer we provide
    an example: An event listener is to be registered at a checkbox. When the
    checkbox is clicked by the user, the listener has to update the enabled
    state of an action and of a text field, depending on the checked state of
    the checkbox. The event listener class could be implemented as follows:
  </p>
    
<div class="source">
<pre>
package com.mypackage;

public class CbxChangeListener implements ChangeListener
{
    /** The action to be enabled/disabled. */
    private final FormAction actionToModify;

    /** The component handler to enable/disable. */
    private final ComponentHandler&lt;?&gt; handlerToModify;

    /**
     * Creates an instance of CbxChangeListener and initializes it with the
     * components to be manipulated.
     *
     * @param action the action to enable/disable
     * @param handler the component handler to enable/disable
     */
    public CbxChangeListener(FormAction action, ComponentHandler&lt;?&gt; handler)
    {
        actionToModify = action;
        handlerToModify = handler;
    }

    /**
     * The value of the monitored checkbox has changed.
     *
     * @param e the change event
     */
    public void elementChanged(FormChangeEvent e)
    {
        // obtain the current value of the checkbox
        // (we can suppress the warning because we know that it is a checkbox)
        @SuppressWarning(&quot;unchecked&quot;)
        ComponentHandler&lt;Boolean&gt; cbxHandler =
            (ComponentHandler&lt;Boolean&gt;) e.getHandler();
        Boolean value = cbxHandler.getData();

        // now modify the components
        actionToModify.setEnabled(value);
        handlerToModify.setEnabled(value);
    }
}
    </pre></div>
  
<p>
    This is pretty straightforward. The class has two member fields for the
    objects (an action and a component handler) it should manipulate. They are
    initialized by the constructor. Provided that an instance is properly
    registered at the checkbox component, the <code>elementChanged()</code>
    method is called every time the value of the checkbox changes. The event
    passed to the method also contains the <code>ComponentHandler</code> of the
    input element which caused the event - in our case this is the checkbox. So
    we just have to query the current value of the checkbox through its
    <code>ComponentHandler</code> and can then set the enabled state of the
    watched components accordingly. This was the Java part. The following
    fragment shows how an instance of this class is created in a builder script
    and associated with the checkbox:
  </p>
    
<div class="source">
<pre>
&lt;!-- The event listener bean --&gt;
&lt;di:bean name=&quot;cbxListener&quot; beanClass=&quot;com.mypackage.CbxChangeListener&quot;&gt;
  &lt;di:constructor&gt;
    &lt;di:param refName=&quot;action:myaction&quot;/&gt;
    &lt;di:param refName=&quot;comp:txtData&quot;/&gt;
  &lt;/di:constructor&gt;
&lt;/di:bean&gt;

&lt;a:eventListener component=&quot;cbx&quot; eventType=&quot;CHANGE&quot; beanName=&quot;cbxListener&quot;/&gt;
    </pre></div>
  
<p>
    The use of the <code>&lt;a:eventListener&gt;</code> tag should be clear. The
    interesting part is the creation of the listener object. Here standard
    functionality of the <a href="dibuilder.html">dependency injection builder</a>
    is used to invoke the constructor of the listener class and pass the expected
    dependencies. The prefixes passed to the <code>refName</code> attributes of
    the <code>&lt;di:param&gt;</code> tags indicate that special elements should be
    looked up: an action and a component handler. These special prefixes are
    supported by the <code>BeanContext</code> that is available in the builder
    script. You can find a documentation about them in the Javadocs of the
    classes <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/components/ComponentBuilderData.html">
    ComponentBuilderData</a></code>,
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/action/ActionBuilder.html">
    ActionBuilder</a></code>, and
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/window/WindowBuilderData.html">
    WindowBuilderData</a></code>. Hopefully, this example demonstrates that it
    is easy to use the declarative approach for registering event listeners. The
    combination of the <i>dependency injection framework</i> and the
    <code>&lt;a:eventListener&gt;</code> tag provides a powerful means to
    separate logic from UI initialization.
  </p>
  </section>

  <section>
<h3><a name="Mapping_events_to_actions"></a>Mapping events to actions</h3>
  
<p>
    The <code>&lt;a:eventListener&gt;</code> tag provides all functionality
    needed for dealing with event listener registrations. So what else has to be
    said about event listeners? <i>JGUIraffe</i> provides another feature
    related to the handling of event listeners: events fired by UI input
    elements can be mapped to actions.
  </p>
  
<p>
    One advantage of actions is that they can be shared between multiple
    components, e.g. a menu item and a tool bar button. The logic behind the
    action has to be implemented once and can then be directly reused by all
    components that are associated with the action. Many input components
    however, cannot be associated with actions; they only support event
    listeners. Now there are some use cases where an event generated by an
    input component should have the same effect as an action. One example is a
    table listing the files of a directory. Through a menu item and a tool bar
    button it is possible to open the file currently selected in the table. The
    logic for opening the file is implemented centrally by an action. To
    improve usability it would be desirable if a double-click on a file would
    also cause the file to be opened.
  </p>
  
<p>
    The problem could be solved by externalizing the code for opening a file
    into a helper class. Then we can write an event listener for mouse events
    and register it at the table that calls the helper class. Analogously, the
    file open action would delegate to this class. This would work without major
    code duplication, but it is still inconvenient and involves creating an
    almost trivial event listener class. <i>JGUIraffe</i> solves the problem
    by providing tags that register special event listeners at components.
    Whenever specific events are received from the component the event listener
    delegates to an action. This happens automatically without intervention of
    the developer. Take a look at the code fragment below:
  </p>
    
<div class="source">
<pre>
&lt;f:table name=&quot;fileTable&quot; model=&quot;dirModel&quot;&gt;
  ...
  &lt;a:mouseEvent actionName=&quot;fileOpenAction&quot;&gt;
  &lt;/a:mouseEvent&gt;
&lt;/f:table&gt;
    </pre></div>
  
<p>
    This example shows how the <code>&lt;a:mouseEvent&gt;</code> tag (which
    is implemented by the
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/action/tags/MouseListenerTag.html">
    MouseListenerTag</a></code> class) is used to map mouse events to the action
    with the name <i>fileOpenAction</i>. The action must be available in the
    current context - typically it has been declared before in the same builder
    script. The tag is placed in the body of the input element tag defining the
    element the event handler is to be registered at. This works not only for
    mouse events, but for all standard event types supported by the event system
    of <i>JGUIraffe</i>. Event custom events are supported. The following
    table lists the tags for the different event types:
  </p>
  
<p>
    </p>
<table class="bodyTable" border="1">
    
<tr class="a">
      
<th>Tag</th>
      
<th>Implementation class</th>
      
<th>Event type</th>
    </tr>
    
<tr class="b">
      
<td><code>&lt;a:actionEvent&gt;</code></td>
      
<td>
      <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/action/tags/ActionListenerTag.html">
      ActionListenerTag</a></code>
      </td>
      
<td>Action events</td>
    </tr>
    
<tr class="a">
      
<td><code>&lt;a:changeEvent&gt;</code></td>
      
<td>
      <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/action/tags/ChangeListenerTag.html">
      ChangeListenerTag</a></code>
      </td>
      
<td>Change events</td>
    </tr>
    
<tr class="b">
      
<td><code>&lt;a:focusEvent&gt;</code></td>
      
<td>
      <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/action/tags/FocusListenerTag.html">
      FocusListenerTag</a></code>
      </td>
      
<td>Focus events</td>
    </tr>
    
<tr class="a">
      
<td><code>&lt;a:mouseEvent&gt;</code></td>
      
<td>
      <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/action/tags/MouseListenerTag.html">
      MouseListenerTag</a></code>
      </td>
      
<td>Mouse events</td>
    </tr>
    
<tr class="b">
      
<td><code>&lt;a:customEvent&gt;</code></td>
      
<td>
      <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/action/tags/FormEventListenerTag.html">
      FormEventListenerTag</a></code>
      </td>
      
<td>Custom events</td>
    </tr>
    </table>
  
  
<p>
    So the <code>&lt;a:mouseEvent&gt;</code> tag in the body of the
    <code>&lt;f:table&gt;</code> tag basically means that whenever the table
    fires a mouse event the specified action is to be executed. But wait! There
    are several types of mouse events (e.g. mouse pressed, mouse released,
    mouse double-clicked, etc.), but we only want the action to be triggered for
    double-click events. This can be achieved by nesting another tag in the
    body of <code>&lt;a:mouseEvent&gt;</code> which defines a specific <i>event
    filter</i>:
  </p>
    
<div class="source">
<pre>
&lt;f:table name=&quot;fileTable&quot; model=&quot;dirModel&quot;&gt;
  ...
  &lt;a:mouseEvent actionName=&quot;fileOpenAction&quot;&gt;
    &lt;a:eventFilter eventType=&quot;MOUSE_DOUBLE_CLICKED&quot;
      class=&quot;net.sf.jguiraffe.gui.builder.event.filter.TypeEventFilter&quot;/&gt;
  &lt;/a:mouseEvent&gt;
&lt;/f:table&gt;
    </pre></div>
  
<p>
    Using the <code>&lt;a:eventFilter&gt;</code> tag (implemented by the
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/action/tags/EventFilterTag.html">
    EventFilterTag</a></code> class) a filter can be added to the automatically
    generated event listener which constraints the execution of the associated
    action: only if a specified condition is matched by the event, the action gets
    fired. In this example the filter accepts only events with the type
    <i>MOUSE_DOUBLE_CLICKED</i>. The <code>&lt;a:eventFilter&gt;</code> tag
    creates an object implementing the
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/event/filter/EventFilter.html">
    EventFilter</a></code> interface and initializes it. Here we use an instance
    of the <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/event/filter/TypeEventFilter.html">
    TypeEventFilter</a></code> class, a specialized <code>EventFilter</code>
    implementation which can check for an event's <code>type</code> property.
    The <code>net.sf.jguiraffe.gui.builder.event.filter</code> package contains
    various implementations of event filters. It is also possible to combine
    multiple filters using boolean logic (<i>and</i> and <i>or</i>). In the
    following example a filter is defined which accepts single or double-click
    mouse events:
  </p>
    
<div class="source">
<pre>
&lt;a:mouseEvent actionName=&quot;fileOpenAction&quot;&gt;
  &lt;a:orEventFilter&gt;
    &lt;a:eventFilter eventType=&quot;MOUSE_DOUBLE_CLICKED&quot;
      class=&quot;net.sf.jguiraffe.gui.builder.event.filter.TypeEventFilter&quot;/&gt;
    &lt;a:eventFilter eventType=&quot;MOUSE_CLICKED&quot;
      class=&quot;net.sf.jguiraffe.gui.builder.event.filter.TypeEventFilter&quot;/&gt;
  &lt;/a:orEventFilter&gt;
&lt;/a:mouseEvent&gt;
    </pre></div>
  
<p>
    This fragment creates two instances of <code>TypeEventFilter</code> with
    different values of the <code>type</code> property and combines them using an
    <code>&lt;a:orEventFilter&gt;</code> tag. That way complex conditional logic
    can be specified in a declarative way.
  </p>
  
<p>
    In addition to the standard events supported by <i>JGUIraffe</i>'s event
    system, it is also possible to map custom events to actions. For this
    purpose the generic <code>&lt;a:customEvent&gt;</code> tag exists. The
    actual event type is defined by a nested <code>&lt;a:listenerType&gt;</code>
    tag. This tag is implemented by the
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/action/tags/EventListenerTypeTag.html">
    EventListenerTypeTag</a></code> class. It expects the event listener type
    (as required by the <code>FormEventManager</code> class) and the class of the
    event listener interface as attributes. The latter is needed only for
    non-standard event types. The next example maps the <i>tree expansion</i>
    event of a tree component to an action:
  </p>
    
<div class="source">
<pre>
&lt;f:tree name=&quot;testTree&quot; model=&quot;treeModel&quot;&gt;
  &lt;a:customEvent actionName=&quot;expansionAction&quot;&gt;
    &lt;a:listenerType type=&quot;Expansion&quot;
      listenerClass=&quot;net.sf.jguiraffe.gui.builder.components.model.TreeExpansionListener&quot;/&gt;
  &lt;/a:customEvent&gt;
&lt;/f:tree&gt;
    </pre></div>
  
<p>
    It should now be clear how to map arbitrary events generated by input
    components to actions. One last hint: The <code>enabled</code> property of
    a <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/action/FormAction.html">
    FormAction</a></code> determines whether a mapped action is invoked or not:
    When an event arrives (which is accepted by a possibly installed event
    filter) the automatically generated event listener checks whether the action
    is enabled. Only then it executes the action. This is another advantage
    over the standard approach with event listeners: a typical event listener
    has no built-in mechanism to temporarily disable event processing.
  </p>
  </section>

  <section>
<h3><a name="Actions_and_commands"></a>Actions and commands</h3>
  
<p>
    In the chapter about <a href="commands.html">Commands</a> we already pointed
    out that the programming model around command objects enforces a
    centralization of business logic which increases the maintainability of an
    application. Now about <a href="#Actions">Actions</a> we claimed something
    similar. How do these concept relate together?
  </p>
  
<p>
    To answer this question it makes sense to first emphasize the main difference
    between actions and commands: Actions are directly invoked by the thread
    that manages the UI - the <i>event dispatching thread</i>. Commands in
    contrast are intended to be executed by a separate worker thread. This
    allows the UI to stay responsive while the application is working in the
    background.
  </p>
  
<p>
    Because of their different execution modes actions and commands are taylored
    to different kinds of operations. If an operation runs very fast - maybe
    just an update of the UI -, an action is appropriate. However, all longer
    running operations should be implemented as commands running in a background
    thread.
  </p>
  
<p>
    In order to create and execute a command usually some glue code is
    required. A typical use case is that a menu item or a tool bar button
    should trigger an operation which may take a while. The graphical elements
    (the menu item or the tool bar button) are associated with an action. In the
    task of this action the logic is placed that handles the execution of the
    command. Here lies the typical relation between actions and commands:
    actions act as starters for command objects. They bridge between the UI
    thread and the worker thread for background execution.
  </p>
  
<p>
    Because starting a command from an action is a standard pattern in UI
    programming <i>JGUIraffe</i> provides some special support for it. With
    the <code><a href="../apidocs/net/sf/jguiraffe/gui/app/CommandActionTask.html">
    CommandActionTask</a></code> class there is a specialized task implementation
    that executes a configurable command. An instance of
    <code>CommandActionTask</code> can be fully defined in a builder script.
    It is assigned the command to be executed. This command can also be defined
    in the builder script. An example should make this clearer. Imagine we have
    written a command class for opening a dialog with view settings. This is a
    simple command class which does not expect any configuration parameters. So
    its definition in a builder script is straightforward:
  </p>
    
<div class="source">
<pre>
&lt;di:bean name=&quot;openViewDefsDialogCommand&quot;
  beanClass=&quot;net.sf.jguiraffe.examples.tutorial.viewset.OpenViewSettingsDlgCommand&quot;&gt;
&lt;/di:bean&gt;
    </pre></div>
  
<p>
    This declaration just defines an instance of the
    <code>OpenViewSettingsDlgCommand</code> class and makes it available in the
    current bean context under the name <i>openViewDefsDialogCommand</i>. The
    class implements the <code>Command</code> interface. Now we define an
    instance of <code>CommandActionTask</code> and associate it with the command
    bean:
  </p>
    
<div class="source">
<pre>
&lt;di:bean name=&quot;openViewDefsDialogTask&quot;
  beanClass=&quot;net.sf.jguiraffe.gui.app.CommandActionTask&quot;&gt;
  &lt;di:setProperty property=&quot;commandBeanName&quot; value=&quot;openViewDefsDialogCommand&quot;/&gt;
&lt;/di:bean&gt;
    </pre></div>
  
<p>
    The property <code>commandBeanName</code> connects the task implementation
    to the command to be executed. The last step is to assign this task to an
    action:
  </p>
    
<div class="source">
<pre>
&lt;a:action name=&quot;extrasViewDefAction&quot; textres=&quot;act_extrviewdef_text&quot;
  tooltipres=&quot;act_extrviewdef_tip&quot; mnemonicres=&quot;act_extrviewdef_mnemo&quot;
  taskBean=&quot;openViewDefsDialogTask&quot;&gt;
  &lt;f:icon resource=&quot;view.gif&quot;/&gt;
&lt;/a:action&gt;
    </pre></div>
  
<p>
    This is a complete action definition. Of special importance is the
    <code>taskBean</code> attribute referencing the task we setup in the
    previous step.
  </p>
  
<p>
    So <code><a href="../apidocs/net/sf/jguiraffe/gui/app/CommandActionTask.html">
    CommandActionTask</a></code> can be used out of the box to associate actions
    with long-running background tasks. The class provides another feature which
    is useful in this context: it allows disabling or enabling specific UI
    elements while the background processing is running. Often there are some
    restrictions while an operation runs in a background task. For instance,
    some other operations cannot be started until results of the current
    operation are available. Another typical use case is that it is not allowed
    to start an operation again while it is still running. To achieve this, a
    <code>CommandActionTask</code> instance can be associated with an
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/enablers/ElementEnabler.html">
    ElementEnabler</a></code>. An <code>ElementEnabler</code> is a generic object
    that knows how to disable or enable certain UI elements, e.g. actions,
    action groups, or input components. Have a look at the following example
    which is a slight extension of the previous one:
  </p>
    
<div class="source">
<pre>
&lt;di:bean name=&quot;openViewDefsDialogTask&quot;
  beanClass=&quot;net.sf.jguiraffe.gui.app.CommandActionTask&quot;&gt;
  &lt;di:setProperty property=&quot;commandBeanName&quot; value=&quot;openViewDefsDialogCommand&quot;/&gt;
  &lt;di:setProperty property=&quot;beforeEnabler&quot; value=&quot;action:extrasViewDefAction&quot;/&gt;
&lt;/di:bean&gt;
    </pre></div>
  
<p>
    Here again the task for the action for opening the dialog with view settings
    is defined, but this time the additional <code>beforeEnabler</code>
    property is set. If you look at the Javadocs, you will see that the
    <code>beforeEnabler</code> property actually expects an object implementing
    the <code>ElementEnabler</code> interface. However, when executing a builder
    script a specialized <a href="dibuilder.html#type_converters">data type
    converter</a> for element enablers is active. The converter is able to
    transform a textual representation of an element enabler to a concrete
    implementation object. This is done with the help of the
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/enablers/EnablerBuilder.html">
    EnablerBuilder</a></code> class. In this example fragment the value
    <i>action:extrasViewDefAction</i> means that during the execution of the
    associated background command the action with the name
    <i>extrasViewDefAction</i> (this is the action itself) should be
    disabled. So the user cannot accidently open multiple dialog windows by
    issuing multiple clicks. There is also a property named
    <code>afterEnabler</code> which allows setting an enabler to be invoked
    after the command was executed. If it is not defined, an enabler is set
    which does exactly the opposite of the before enabler; therefore all
    elements that have been disabled when the execution of the command started
    are enabled again when it finishes. If you want to change the states of
    elements in a non-symmetric way, you can specify a different object for the
    <code>afterEnabler</code> property.
  </p>
  
<p>
    Action enablers are a pretty neat feature that
    supports dealing with concurrency issues that might arise when working with
    background tasks. Have a look at the Javadocs for the
    <code><a href="../apidocs/net/sf/jguiraffe/gui/app/CommandActionTask.html">
    CommandActionTask</a></code> and
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/enablers/EnablerBuilder.html">
    EnablerBuilder</a></code> classes for more details about the enabler
    mechanism.
  </p>
  
<p>
    One special case of longer-running tasks is the processing of builder
    scripts. Well, actually typical builder scripts are executed pretty fast,
    but nevertheless this operation involves I/O activities, so it will not do
    any harm to put it in a background thread. <i>JGUIraffe</i> provides a
    pre-defined <code>Command</code> implementation that processes a builder
    script and opens the main window defined by the script. This command can be
    used for instance everytime an application needs to open a dialog window.
    The following code fragment shows an example:
  </p>
    
<div class="source">
<pre>
&lt;di:bean name=&quot;openNewFileDialogCommand&quot;
  beanClass=&quot;net.sf.jguiraffe.gui.app.OpenWindowCommand&quot;&gt;
  &lt;di:constructor&gt;
    &lt;di:param&gt;
      &lt;di:bean beanClass=&quot;net.sf.jguiraffe.locators.ClassPathLocator&quot;&gt;
        &lt;di:factory&gt;
          &lt;di:methodInvocation method=&quot;getInstance&quot;
            targetClass=&quot;net.sf.jguiraffe.locators.ClassPathLocator&quot;&gt;
            &lt;di:param value=&quot;newfile.jelly&quot;/&gt;
          &lt;/di:methodInvocation&gt;
        &lt;/di:factory&gt;
      &lt;/di:bean&gt;
    &lt;/di:param&gt;
  &lt;/di:constructor&gt;
&lt;/di:bean&gt;
    </pre></div>
  
<p>
    <code><a href="../apidocs/net/sf/jguiraffe/gui/app/OpenWindowCommand.html">
    OpenWindowCommand</a></code> implements the <code>Command</code> interface
    in a way that it executes the builder script defined by the
    <code><a href="../apidocs/net/sf/jguiraffe/locators/Locator.html">Locator</a>
    </code> object passed to the constructor. After the script has been evaluated
    the window it defines is opened. The bean definition in the example fragment
    declares an instance of <code>OpenWindowCommand</code> and also defines the
    <code>Locator</code> object to be passed to the constructor - a
    <code><a href="../apidocs/net/sf/jguiraffe/locators/ClassPathLocator.html">
    ClassPathLocator</a></code> in this case. The major part of the bean
    definition deals with the creation of the <code>ClassPathLocator</code>
    object. This is because instances of this class are created using a static
    factory method which complicates the definition. Fortunately, there is a
    simpler way to write this declaration because the dependency injection
    framework provides a specialized <a href="dibuilder.html#type_converters">
    data type converter</a> for <code>Locator</code> objects:
    <code><a href="../apidocs/net/sf/jguiraffe/locators/LocatorConverter.html">
    LocatorConverter</a></code>. The Javadocs of this class describe the syntax
    understood by this converter. Using this mechanism the declaration of the
    command can be abbreviated as follows:
  </p>
    
<div class="source">
<pre>
&lt;di:bean name=&quot;openNewFileDialogCommand&quot;
  beanClass=&quot;net.sf.jguiraffe.gui.app.OpenWindowCommand&quot;&gt;
  &lt;di:constructor&gt;
    &lt;di:param value=&quot;classpath:newfile.jelly&quot;/&gt;
  &lt;/di:constructor&gt;
&lt;/di:bean&gt;
    </pre></div>
  
<p>
    This is much easier, isn't it? Now this command bean can be assigned a
    <code><a href="../apidocs/net/sf/jguiraffe/gui/app/CommandActionTask.html">
    CommandActionTask</a></code> bean, and then it is directly available to an
    action:
  </p>
    
<div class="source">
<pre>
&lt;di:bean name=&quot;openNewFileDialogTask&quot;
  beanClass=&quot;net.sf.jguiraffe.gui.app.CommandActionTask&quot;&gt;
  &lt;di:setProperty property=&quot;commandBeanName&quot; value=&quot;openNewFileDialogCommand&quot;/&gt;
  &lt;di:setProperty property=&quot;enablerSpecification&quot; value=&quot;action:fileNewAction&quot;/&gt;
&lt;/di:bean&gt;
    </pre></div>
  
<p>
    Because the builder script <i>newfile.jelly</i> is read the dialog window
    created by the command is proably about creating a new file. So the
    corresponding task can be referenced by the <i>fileNewAction</i>. Note
    that this action also appears in the <code>enablerSpecification</code>
    property of the task bean. So while the builder script is processed, the
    user cannot trigger the action again to open multiple copies of the dialog.
    When the dialog is open it is modal, so actions in the parent window are
    not available per se.
  </p>
  
<p>
    These examples show that actions for opening dialog windows that are defined
    by builder scripts can be completely defined in a declarative way. No
    programming is required unless there are special requirements related to the
    initialization of the builder. For instance, if some application-specific
    properties have to be passed to the builder script, a custom class has to
    be created. This class can be derived from
    <code><a href="../apidocs/net/sf/jguiraffe/gui/app/OpenWindowCommand.html">
    OpenWindowCommand</a></code>; it can override the
    <code>prepareBuilderData()</code> method to perform additional
    initialization before the builder is invoked.
  </p>
  </section>
  </section>



      </div>
    </div>
    <div class="clear">
      <hr/>
    </div>
    <div id="footer">
      <div class="xright">
        Copyright &#169;      2021The JGUIraffe Team.
.      </div>
      <div class="clear">
        <hr/>
      </div>
    </div>
  </body>
</html>