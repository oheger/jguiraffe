<!DOCTYPE html>
<!--
 | Generated by Apache Maven Doxia Site Renderer 1.9.2 from src/site/xdoc/userguide/formbuilder.xml at 2021-07-28

 | Rendered using Apache Maven Default Skin
-->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="generator" content="Apache Maven Doxia Site Renderer 1.9.2" />
    <meta name="author" content="Oliver Heger" />
    <title>JGUIraffe &#x2013; Building user interfaces</title>
    <link rel="stylesheet" href="../css/maven-base.css" />
    <link rel="stylesheet" href="../css/maven-theme.css" />
    <link rel="stylesheet" href="../css/site.css" />
    <link rel="stylesheet" href="../css/print.css" media="print" />
  </head>
  <body class="composite">
    <div id="banner">
<a href=".././" id="bannerLeft"><img src="../images/giraffe.jpg"  alt="JGUIraffe"/></a>      <div class="clear">
        <hr/>
      </div>
    </div>
    <div id="breadcrumbs">
      <div class="xleft">
        <span id="publishDate">Last Published: 2021-07-28</span>
          &#xA0;| <span id="projectVersion">Version: 1.4-SNAPSHOT</span>
      </div>
      <div class="xright"><a href=".././" title="GitHub project">GitHub project</a>      </div>
      <div class="clear">
        <hr/>
      </div>
    </div>
    <div id="leftColumn">
      <div id="navcolumn">
       <h5>JGuiraffe</h5>
    <ul>
     <li class="none"><a href="../index.html" title="Home">Home</a></li>
     <li class="none"><a href="../introduction.html" title="Introduction">Introduction</a></li>
     <li class="none"><a href="../overview.html" title="Overview">Overview</a></li>
     <li class="none"><a href="../userguide/user_guide.html" title="User's Guide">User's Guide</a></li>
     <li class="none"><a href="../apidocs/index.html" title="Javadoc (latest)">Javadoc (latest)</a></li>
     <li class="none"><a href="../jguiraffe-parent/jguiraffe-examples/index.html" title="JGUIraffe Examples">JGUIraffe Examples</a></li>
     <li class="none"><a href="../building.html" title="Building from Source">Building from Source</a></li>
     <li class="none"><a href="../jguiraffe-parent/jguiraffe/changes-report.html" title="Changes Report">Changes Report</a></li>
    </ul>
       <h5>Modules</h5>
    <ul>
     <li class="none"><a href="../jguiraffe-parent/jguiraffe/index.html" title="JGUIraffe Core">JGUIraffe Core</a></li>
     <li class="none"><a href="../jguiraffe-parent/jguiraffe-swing/index.html" title="JGUIraffe Swing integration">JGUIraffe Swing integration</a></li>
     <li class="none"><a href="../jguiraffe-parent/jguiraffe-java-fx/index.html" title="JGUIraffe JavaFX integration">JGUIraffe JavaFX integration</a></li>
    </ul>
      <a href="http://maven.apache.org/" title="Built by Maven" class="poweredBy">
        <img class="poweredBy" alt="Built by Maven" src="../images/logos/maven-feather.png" />
      </a>
      </div>
    </div>
    <div id="bodyColumn">
      <div id="contentBox">


 
  <section>
<h2><a name="Building_user_interfaces"></a>Building user interfaces</h2>
  
<p>
    In the previous sections it was discussed that builders that interprete
    XML-based scripts play an important role in the <i>JGUIraffe</i>
    framework. The chapter about the <a href="dibuilder.html">dependency
    injection builder</a> showed how arbitrary Java objects can be defined and
    created. In this section we focus on the creation of user interface
    elements that can be used in forms to gather user input. For this purpose
    the <i>JGUIraffe</i> library provides a specialized tag library: the
    <i>form builder</i> or <i>component builder</i> tag library.
  </p>
  
<p>
    The tags of the form builder tag library support the definition of typical
    UI elements like panels, labels, text fields, or radio buttons. They also
    allow the creation of layouts for containers. Last, but not least UI-related
    helper objects like validators or transformers can be declared. One big
    advantage of the form builder tag library is that it does not only create
    the user interface, but automatically generates a
     <code><a href="../apidocs/net/sf/jguiraffe/gui/forms/Form.html">Form
    </a></code> object which is able to process the user input entered in this
    UI. Refer to the <a href="forms.html">Working with forms</a> section for
    more information about forms.
  </p>
  
<p>
    We will show how this looks like in practice. But first we have to introduce
    some central classes and interfaces whose knowledge is important when using
    the form builder tag library.
  </p>

  <section>
<h3><a name="Fundamental_classes_and_interfaces"></a>Fundamental classes and interfaces</h3>
  
<p>
    While processing a builder script with UI definitions the builder actually
    creates two different structures in memory:
    </p>
<ul>
      
<li>the actual UI components, i.e. panels, input fields, etc. nested in a
      hierarchical structure according to the defined layout</li>
      
<li>objects for managing the data of the input components that belong to
      the UI. These objects allow automatic processing of data entered by the
      user.</li>
    </ul>
  
  
<p>
    The most important objects for managing input components are
    <code><a href="../apidocs/net/sf/jguiraffe/gui/forms/ComponentHandler.html">
    ComponentHandler</a></code> objects. A <code>ComponentHandler</code> wraps
    a graphical input element and provides read and write access to its data.
    The type of the data depends on the concrete input element. A text field
    for instance, has the entered text as its data. For a check box the data
    consists of a boolean flag (whether the check box is checked or not). For a
    list box it is the index of the selected element (or an array of the selected
    indices if multi-selection is allowed). The actual Java data type of a
    <code>ComponentHandler</code> can be queried using its <code>getType()</code>
    method.
  </p>
  
<p>
    The methods <code>getData()</code> and <code>setData()</code> can be used to
    query or set the current content of an input element. Note that the
    <code>ComponentHandler</code> interface has a generics parameter that defines
    the return or parameter types of these methods. With the methods
    <code>isEnabled()</code> and <code>setEnabled()</code> the enabled state of
    an input element can be queried or set. By using the <code>setEnabled()</code>
    method it is possible for instance to disable an input element if it is
    temporarily not available, maybe because of the status of other input
    elements.
  </p>
  
<p>
    Component handlers are used under the hood by the <code>Form</code> class to
    transform data between graphical input elements and the form's model or vice
    versa. So if only the data entered by a user into a form is of interest, a
    developer need not deal with these handlers directly. However, if the form
    is more dynamic and should change the status of some components based on
    user input, it might be necessary to use component handlers to read the
    current data of input elements and to manipulate other dependent elements.
    An example is a check box that controls other input elements: only if the
    check box is checked, the dependent input elements should be enabled. A way
    to achieve this is to add an event listener at the check box for change
    events (we will show how this is done in later sections). In this event
    handler the <code>ComponentHandler</code> for the check box is obtained and
    queried for the data of the checkbox. This results in a boolean flag which
    determines the enabled status of the dependent elements.
  </p>
  
<p>
    The <code>ComponentHandler</code> interface defines the minimum protocol
    required by the framework for the interaction with input components. It does
    not cover any specialities of components. This is a shortcoming, especially
    when dealing with more complex input elements like tables or trees. Such
    components provide special functionality which cannot be accessed by the
    <code>ComponentHandler</code> interface. Therefore the <i>JGUIraffe</i>
    library provides a number of specialized interfaces derived from
    <code>ComponentHandler</code> which are tailored for specific component
    types. These interfaces live in the
    <code>net.sf.jguiraffe.gui.builder.components.model</code> package. For
    instance, there are specialized handler interfaces for tables, trees, or
    progress bars. If you work with one of these components, the associated
    <code>ComponentHandler</code> object can be casted to the specialized
    interface to obtain extended access to this component.
  </p>
  
<p>
    While the <code>ComponentHandler</code> interface focuses on data access to
    input components, the
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/components/WidgetHandler.html">
    WidgetHandler</a></code> interface allows the manipulation of graphical
    properties of elements, e.g. the colors or the visible state. Widget handlers
    are available for all graphical elements, not only for input elements. This
    includes labels for example. Again, widget handlers are useful for dynamic
    forms which adapt their appearance to current user input.
  </p>
  
<p>
    We have seen that during a builder operation a bunch of objects is created:
    a <code>Form</code> object, component handlers, widget handlers. But how can
    these objects be accessed? All objects created during the builder operation
    are collected by a central object which represents the results of the
    builder. This is an object of type
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/components/ComponentBuilderData.html">
    ComponentBuilderData</a></code>. This class defines a bunch of useful methods
    for obtaining the objects created:
    </p>
<ul>
    
<li><code>getComponentHandler()</code> returns the <code>ComponentHandler</code>
    for the input element with the specified name.</li>
    
<li><code>getComponent()</code> returns the actual component with the
    specified name. This is the platform-specific UI element, e.g. a Swing text
    field. Because the type of this element depends on the underlying UI toolkit
    <code>getComponent()</code> has the unspecific type <code>java.lang.Object</code>
    as its return type.</li>
    
<li><code>getWidgetHandler()</code> returns the <code>WidgetHandler</code>
    for the UI element with the specified name. This method can also be called
    for non-input elements, provided that a name was specified for them.</li>
    
<li><code>getForm()</code> returns a reference to the <code>Form</code>
    object created during the builder operation. This form contains fields for
    all the input elements defined in the builder script.</li>
    
<li><code>getBeanContext()</code> returns the <code>BeanContext</code> of the
    current builder operation. This <code>BeanContext</code> provides access to
    almost all objects created by the builder. Refer to the section
    <a href="dibuilder.html">The dependency injection builder</a> for more
    information about bean contexts and the definition of objects. There are some
    special short cuts for accessing graphical objects produced by the builder
    like components or their handlers. The Javadocs for the
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/components/ComponentBuilderData.html">
    ComponentBuilderData</a></code> class describe which additional objects can
    be retrieved in detail.</li>
    </ul>
  
  
<p>
    So from the <code>ComponentBuilderData</code> object access to all builder
    results is possible. How to obtain the <code>ComponentBuilderData</code>
    object itself depends on the target object: A class derived from
    <code>FormController</code> (refer to the section <a href="formcontroller.html">
    Form controllers</a>) has direct access to the <code>ComponentBuilderData</code>
    object through its <code>getComponentBuilderData()</code> method. Typically
    the controller of a form needs this object if it has to manipulate UI
    elements depending on some logic. If some other object needs access to the
    <code>ComponentBuilderData</code> object, the best way to achieve this is to
    define this object in the builder script and inject a corresponding
    reference. As an example consider the following class definition:
  </p>
    
<div class="source">
<pre>
package com.mypackage;

import net.sf.jguiraffe.gui.builder.components.ComponentBuilderData;

public class MyClass
{
    private final ComponentBuilderData builderData;

    public MyClass(ComponentBuilderData cd)
    {
        builderData = cd;
     }

     // remaining part omitted
}
    </pre></div>
  
<p>
    Here a simple class is defined which expects a <code>ComponentBuilderData</code>
    object to be passed to its constructor. An instance of this class can be
    created in a builder script using the following tags:
  </p>
    
<div class="source">
<pre>
&lt;di:bean name=&quot;myClassInstance&quot; beanClass=&quot;com.mypackage.MyClass&quot;&gt;
  &lt;di:constructor&gt;
    &lt;di:param refName=&quot;COMPONENT_BUILDER_DATA&quot;/&gt;
  &lt;/di:constructor&gt;
&lt;/di:bean&gt;
    </pre></div>
  
<p>
    Now that we know how to obtain a <code>ComponentBuilderData</code> object we
    can implement the example mentioned above: a form contains a check box which
    controls a text field. Only if the check box is checked, the text field
    should be enabled. We assume that this rule is to be implemented by a
    <code>FormController</code> object which is registered as change listener
    at the checkbox. Then the controller class can contain the following code:
  </p>
    
<div class="source">
<pre>
/** Constant for the name of the check box component. */
private static final String COMP_CHECKBOX = &quot;testCheckBox&quot;;

/** Constant for the name of the text field component. */
private static final String COMP_TEXT = &quot;dependentTextField&quot;;

/**
 * Notifies this object about a change in the data of an element.
 * @param e the change event
 */
public void elementChanged(FormChangeEvent e)
{
    // obtain the handler for the check box (the type-safety warning can be
    // suppressed because we know that it is a check box handler
    @SuppressWarnings(&quot;unchecked&quot;)
    ComponentHandler&lt;Boolean&gt; checkHandler = (ComponentHandler&lt;Boolean&gt;)
        getComponentBuilderData().getComponentHandler(COMP_CHECKBOX);

    // obtain the handler for the text field
    ComponentHandler&lt;?&gt; textHandler =
        getComponentBuilderData.getComponentHandler(COMP_TEXT);

    // Change enabled state based on the check box's data
    Boolean checked = checkHandler.getData();
    textHandler.setEnabled(checked.booleanValue());
}
    </pre></div>
  
<p>
    This example shows how UI-related logic can be implemented with component
    handlers and the help of the <code>ComponentBuilderData</code> object. Event
    listeners will be discussed in a later section. Next we talk about builder
    scripts that define UI components.
  </p>
  </section>

  <section>
<h3><a name="Builder_scripts_and_base_tag_handler_classes"></a>Builder scripts and base tag handler classes</h3>
  
<p>
    The previous sections already contained examples for builder scripts. Scripts
    defining UI components do not look differently. It is essential that the
    namespace declaration on the root element includes the component builder tag
    library, so that all these tags can be used. The following listing shows the
    skeleton of a builder script which we use in the examples in this section.
    It defines a dialog window with its content:
  </p>
    
<div class="source">
<pre>
&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;
&lt;j:jelly xmlns:j=&quot;jelly:core&quot; xmlns:di=&quot;diBuilder&quot; xmlns:f=&quot;formBuilder&quot;
  xmlns:a=&quot;actionBuilder&quot; xmlns:w=&quot;windowBuilder&quot;&gt;

  &lt;!-- Definition of the dialog window --&gt;
  &lt;w:dialog titleres=&quot;dialog_title&quot; center=&quot;true&quot;&gt;
    &lt;!-- Define the content of the dialog window here --&gt;

  &lt;/w:dialog&gt;
&lt;/j:jelly&gt;
    </pre></div>
  
<p>
    Here the component builder tag library is registered with the namespace
    prefix &quot;f&quot; (for <i>form</i>). So all XML elements starting with
    <code>f:</code> are looked up in this tag library. The
    <code>&lt;j:jelly&gt;</code> root element also declares namespaces for other
    tag libraries:
    </p>
<ul>
    
<li>the &quot;di&quot; namespace for the dependency injection tag library</li>
    
<li>the &quot;a&quot; namespace for the action builder tag library</li>
    
<li>the &quot;w&quot; namespace for the window builder tag library</li>
    </ul>
    The dependency injection tag library was already discussed in the previous
    chapter. The action builder and the window builder tag libraries are subject
    of following chapters. Typically you want to include all of these tag
    libraries so that you can use the full functionality provided by
    <i>JGUIraffe</i>.
  
  
<p>
    The skeleton script contains a <code>&lt;w:dialog&gt;</code> tag which is
    part of the window builder tag library. This tag will be introduced when
    the window builder tag library is described. For now it is sufficient to
    know that this tag - not surprisingly - creates a dialog window. In the
    body of the tag the definition of the dialog's content is placed. Here the
    tags of the component builder tag library occur; they define the UI elements
    that comprise the UI of the dialog window.
  </p>
  
<p>
    The component builder tag library contains a large number of tags for
    creating various UI components and objects related to them. There are some
    exceptions, but most of the tags can be grouped into one of these categories:
    </p>
<ul>
      
<li>graphical input elements</li>
      
<li>graphical elements which do not gather user input</li>
      
<li>non-graphical objects</li>
    </ul>
    Technically, abstract base classes are used to implement the tag handler
    classes for the tags in the different categories. While the developer usually
    does not have to deal with these base classes, it makes sense to have a short
    glance at them because they do not only implement base functionality, but
    also provide common attributes for all derived tag handler classes. We will
    give a short overview over these base tag handler classes and the attributes
    they support.
  
  
<p>
    The most tags contained in the component builder tag library are derived
    (either directly or indirectly) from the
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/components/tags/FormBaseTag.html">
    FormBaseTag</a></code> class. This class does not implement a great deal of
    functionality, it mainly provides access to the current
    <code>ComponentBuilderData</code> object which lives in the Jelly context.
    But it defines two interesting attributes which are inherited by all sub
    classes: <code>ifName</code> and <code>unlessName</code>. These attributes
    control a conditional execution of the tag.
  </p>
  
<p>
    The builder that processes the builder scripts can be assigned a name. The
    <code>ifName</code> and <code>unlessName</code> attributes compare the name
    of the builder with the value of the attribute and execute the tag only if
    the names match (in the case of <code>ifName</code>) or do not match (for
    <code>unlessName</code>). The background for these attributes lies in the
    fact that <i>JGUIraffe</i> tries to be compatible with multiple UI
    libraries. It may be possible that some libraries require specific
    adaptations in builder scripts. Using these attributes it is pretty easy to
    implement such adaptions by letting certain tags only execute for specific
    builders. For instance, some parts of the builder script should only be
    executed if Swing is used as underlying UI library; other parts may deal with
    specialities of SWT, etc. Conditional execution of tags is of course also
    possible with tags of the standard Jelly tag libraries. However, the
    <code>ifName</code> and <code>unlessName</code> attributes provide a
    convenient short cut.
  </p>
  
<p>
    The next abstract base class in the hierarchy of the component builder tag
    library is
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/components/tags/ComponentBaseTag.html">
    ComponentBaseTag</a></code>. It acts as the base class for all graphical
    elements and defines a set of common standard attributes. With these
    attributes the following properties of graphical components can be set:
    </p>
<ul>
      
<li>A name for the component. Names are optional. They identify objects
      in the builder script in a unique way and are needed if the elements are
      to be accessed programmatically. They are also used to set the name of
      the underlying UI control which is required for accessible user
      interfaces.</li>
      
<li>The foreground and the background color. Colors are specified as
      strings that are parsed by the
      <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/components/ColorHelper.html">
      ColorHelper</a></code> helper class. Have a look at the documentation of
      this class to learn about the format of strings describing colors.</li>
      
<li>The font of the component.</li>
      
<li>An object with layout constraints. Such objects tell the layout
      manager how to place the corresponding component on the screen. We talk
      about the definition of layouts later in this section.</li>
    </ul>
  
  
<p>
    From <code>ComponentBaseTag</code> two other base classes are derived:
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/components/tags/SimpleComponentTag.html">
    SimpleComponentTag</a></code> and
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/components/tags/InputComponentTag.html">
    InputComponentTag</a></code>. <code>SimpleComponentTag</code> is the base
    class for graphical elements that do not support user input. No additional
    standard attributes are defined. For instance, the tag for defining a label
    is derived from this class. <i>Container tags</i> are also sub classes of
    <code>SimpleComponentTag</code>. Container tags are tags that manage a set
    of other components, e.g. a panel.
  </p>
  
<p>
    Many tags of the component builder tag library define input elements and
    thus are derived from
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/components/tags/InputComponentTag.html">
    InputComponentTag</a></code>. This base class not only takes care about the
    creation of the corresponding input element, but also ensures that appropriate
    handler objects are created and added to the current <code>Form</code>
    object. This establishes a connection between the input element and the
    model of the form, so that the form can be used to read and write the data
    of the input element. For input elements a bunch of standard attributes is
    available (in addition to the ones supported for all components):
    </p>
<ul>
    
<li>The name of the input element is now mandatory. It is used to associate
    the input element with a field of the form.</li>
    
<li>An optional display name can be specified. This name is displayed to the
    user, e.g. in case of a validation error. It can be specified directly or as
    a resource name.</li>
    
<li>An optional property name can be set. This is the name of the
    corresponding property in the form's model object. If it is not specified,
    the name of the input element is used.</li>
    
<li>In some use cases input elements should be placed on the UI which are
    not associated with a form. For instance, the element may be used to disable
    or enable other parts of the UI, but it should not be saved with the other
    data entered by the user. In this case the <code>noField</code> attribute
    can be set to <b>true</b>. This attribute prevents that a field is created
    for the input element in the current form.</li>
    
<li>Using the <code>groups</code> attribute an input element can be added
    to one or more logic groups of components. This is just a logic grouping and
    not visible. Component groups provide some functionality, e.g. to obtain
    <code>ComponentHandler</code> objects for all elements in the group or to
    change the enabled state of all elements.</li>
    </ul>
  
  
<p>
    The last base class we want to discuss here is
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/components/tags/UseBeanBaseTag.html">
    UseBeanBaseTag</a></code>. The standard tag libraries shipped with Jelly
    provide a means for creating and accessing beans: the
    <code>&lt;useBean&gt;</code> tag. Using this tag simple Java objects can be
    created by calling their standard constructor, and attributes of the tag are
    used to define properties. The <code>UseBeanBaseTag</code> class of the
    component builder tag library extends this functionality to better integrate
    with the <i>dependency injection framework</i>. The main purpose of tags
    derived from <code>UseBeanBaseTag</code> is to fetch a bean that was defined
    by a <code>&lt;di:bean&gt;</code> tag and to pass it to another tag handler.
    For instance, each input component can be assigned a validator object. The
    <code>&lt;f:validator&gt;</code> tag is responsible for this task. It is
    derived from <code>UseBeanBaseTag</code>. So it can either create a validator
    object directly or obtain one that was defined using a
    <code>&lt;di:bean&gt;</code> tag. This object is then passed to the target
    input element.
  </p>
  </section>

  <section>
<h3><a name="A_simple_example"></a>A simple example</h3>
  
<p>
    To give you a better impression of how the definition of a user interface
    in a builder script looks like we present parts of a script that defines a
    simple dialog box. Using this script we can explain some of the essentials
    of this approach. The following figure shows the dialog that is to be
    defined:
  </p>
  <img src="../images/userguide/FormbuilderExample.png" alt="Example dialog" />
  
<p>
    This is a simple dialog that allows the user to create a new file. The name
    of the file and its content can be specified in input fields. The layout is
    not very complex: the main part of the dialog consists of the two text
    input fields and their labels; at the bottom there is a bar with the buttons
    for closing or canceling the dialog. The builder script that defines the
    dialog is presented below (we only focus on the UI part; some definitions
    for controller elements are omitted):
  </p>
    
<div class="source">
<pre>
&lt;j:jelly xmlns:j=&quot;jelly:core&quot; xmlns:di=&quot;diBuilder&quot; xmlns:f=&quot;formBuilder&quot;
  xmlns:a=&quot;actionBuilder&quot; xmlns:w=&quot;windowBuilder&quot;&gt;

  &lt;!-- A validator for required input fields.--&gt;
  &lt;di:bean name=&quot;requiredValidator&quot;
    beanClass=&quot;net.sf.jguiraffe.transform.RequiredValidator&quot;&gt;
  &lt;/di:bean&gt;

  &lt;!-- A regular expression validator for validating a file name. Certain
       characters are not allowed in file names.
  --&gt;
  &lt;di:bean name=&quot;fileNameValidator&quot;
    beanClass=&quot;net.sf.jguiraffe.transform.RegexValidator&quot;&gt;
    &lt;di:setProperty property=&quot;regex&quot; value=&quot;[^\*\\/~\|&amp;lt;&amp;gt;]*&quot;/&gt;
  &lt;/di:bean&gt;

  &lt;!-- The dialog window --&gt;
  &lt;w:dialog titleres=&quot;newfile_title&quot; center=&quot;true&quot; resizable=&quot;true&quot;&gt;
    &lt;f:borderlayout/&gt;
    &lt;!-- The main panel --&gt;
    &lt;f:panel&gt;
      &lt;f:borderconstr name=&quot;CENTER&quot;/&gt;
      &lt;f:percentlayout columns=&quot;4dlu start/preferred 3dlu full/preferred(6cm)/100 4dlu&quot;
        rows=&quot;4dlu preferred 3dlu preferred full/preferred(5cm)/100 4dlu&quot;/&gt;
      &lt;f:label textres=&quot;newfile_lab_name&quot;&gt;
        &lt;f:percentconstr col=&quot;1&quot; row=&quot;1&quot;/&gt;
      &lt;/f:label&gt;
      &lt;f:textfield name=&quot;fileName&quot; displayNameres=&quot;newfile_disp_name&quot;
        maxlength=&quot;200&quot; tooltipres=&quot;newfile_txt_name_tip&quot;&gt;
        &lt;f:percentconstr col=&quot;3&quot; row=&quot;1&quot;/&gt;
        &lt;f:validators phase=&quot;syntax&quot;&gt;
          &lt;f:validator beanName=&quot;requiredValidator&quot;/&gt;
          &lt;f:validator beanName=&quot;fileNameValidator&quot;&gt;
            &lt;f:properties&gt;
              &lt;f:property property=&quot;ERR_PATTERN&quot;&gt;
                &lt;f:localized resid=&quot;ERR_FILENAME_PATTERN&quot;/&gt;
              &lt;/f:property&gt;
            &lt;/f:properties&gt;
          &lt;/f:validator&gt;
          &lt;f:validator
            class=&quot;net.sf.jguiraffe.examples.tutorial.createfile.UniqueFileNameValidator&quot;/&gt;
        &lt;/f:validators&gt;
      &lt;/f:textfield&gt;
      &lt;f:label textres=&quot;newfile_lab_content&quot;&gt;
        &lt;f:percentconstr col=&quot;1&quot; row=&quot;3&quot;/&gt;
      &lt;/f:label&gt;
      &lt;f:textarea name=&quot;fileContent&quot; displayNameres=&quot;newfile_disp_content&quot;&gt;
        &lt;f:percentconstr col=&quot;1&quot; row=&quot;4&quot; spanx=&quot;3&quot; targetCol=&quot;3&quot;/&gt;
        &lt;f:font name=&quot;Monospaced&quot; size=&quot;13&quot;/&gt;
        &lt;f:validator phase=&quot;syntax&quot; beanName=&quot;requiredValidator&quot;&gt;
        &lt;/f:validator&gt;
      &lt;/f:textarea&gt;
    &lt;/f:panel&gt;

    &lt;!-- The button bar --&gt;
    &lt;f:panel&gt;
      &lt;f:borderconstr name=&quot;SOUTH&quot;/&gt;
      &lt;f:buttonlayout/&gt;
      &lt;f:button name=&quot;btnOk&quot; textres=&quot;newfile_btn_create&quot;
        mnemonicres=&quot;newfile_btn_create_mnemo&quot; default=&quot;true&quot;/&gt;
      &lt;f:button name=&quot;btnCancel&quot; textres=&quot;newfile_btn_cancel&quot;
        mnemonicres=&quot;newfile_btn_cancel_mnemo&quot; cancel=&quot;true&quot;/&gt;
    &lt;/f:panel&gt;
  &lt;/w:dialog&gt;
&lt;/j:jelly&gt;
    </pre></div>
  
<p>
    The listing is a bit verbose as XML documents tend to become in general.
    However, it should be understandable which parts are responsible for the
    creation of which UI elements.
  </p>
  
<p>
    After the typical namespace declaration which includes all of the
    <i>JGUIraffe</i> tag libraries there is a block that uses the tags of the
    dependency injection tag library to define some validator objects. These
    objects are later assigned to the text fields to ensure that they can
    contain only valid data.
  </p>
  
<p>
    The interesting part starts with the <code>&lt;w:dialog&gt;</code> tag that
    introduces a new dialog window. In the body of this tag the definition of
    the dialog's user interface is placed. For the dialog window as a whole a
    <i>border layout</i> is defined by the <code>&lt;f:borderlayout&gt;</code>
    tag (refer to the <a href="layouts.html">Layouts</a> section for more
    details about the dialogs supported by <i>JGUIraffe</i>). The UI of the
    dialog consists of two panels that are arranged using the border layout: the
    main panel in the center, and the buttons panel in the south. Both are
    defined by <code>&lt;f:panel&gt;</code> tags in the body of the
    <code>&lt;w:dialog&gt;</code> tag. The content of the panels is again defined
    in the body of these tags. This nesting of tags is a fundamental principle
    used within builder scripts. It should not be hard to understand because it
    corresponds to the structure of the UI elements created. The layout
    constraints that tell the layout manager where to place the panels are
    specified by nested tags in the body of the <code>&lt;f:panel&gt;</code>
    tags (<code>&lt;f:borderconstr&gt;</code> in this case). This is the
    typical way to specify layout constraints: they are placed in the body of
    the tag they refer to, too.
  </p>
  
<p>
    The first panel is the more complex one. It uses a <code>PercentLayout</code>
    layout manager to layout the components it contains. The layout is defined
    by the <code>&lt;f:percentlayout&gt;</code> tag in the body of the panel.
    The attributes of the tag specify the columns and rows comprising the
    tabular layout. To actually place components in this layout,
    <code>&lt;f:percentconstr&gt;</code> tags are needed that define the position
    and other properties of components which belong to the panel. Again these
    tags can be found in the bodies of the tags defining the components they
    refer to.
  </p>
  
<p>
    The main panel consists of two labels and two text fields (a single line
    text field and a text area with multiple lines). Labels are pretty easy to
    define. For this example the labels are only assigned texts - they support
    icons, too, but this is not needed here. The texts of the labels are
    specified using the <code>textres</code> attribute. The suffix &quot;res&quot;
    stands for <i>resource</i>; this means that the actual text of the label
    is loaded from the application's resources using the value of the attribute
    as resource ID. (More information about resources can be found in the
    section <a href="resources.html">Resources</a>.) Here we see another common
    principle used within the <i>JGUIraffe</i> tag libraries: when texts are
    to be defined that are displayed to the end user, there are always the
    following possibilities:
    </p>
<ul>
    
<li>The text can be specified directly in the builder script. In this case
    it is hard-coded and does not react on the user's locale. Attributes that
    allow setting texts directly do not have any specific suffix. For instance,
    the <code>&lt;f:label&gt;</code> tag has the attribute <code>text</code>
    that takes the text of the label.</li>
    
<li>The text can be defined by a resource ID that is looked up in the
    application's resources. This is done by an attribute with the suffix
    &quot;res&quot; as the <code>textres</code> attribute in the example script.
    As resource group the application's default resource group is used.</li>
    
<li>If the resource group should be different from the default resource group, it
    has to be specified using another attribute. These attributes end on the
    suffix &quot;grp&quot;. For the resource group of a label's text the
    attribute is named <code>resgrp</code>.</li>
    </ul>
    Such a triple of attributes is typical for many tags. Other examples taken
    from the script above are the <code>titleres</code> attribute of the
    <code>&lt;w:dialog&gt;</code> tag and the <code>displayNameres</code>
    attribute of the <code>&lt;f:textarea&gt;</code> tag.
  
  
<p>
    The text input components are more complex. The corresponding tags have more
    attributes than the simple <code>&lt;f:label&gt;</code> tag, e.g. a tooltip
    and a display name. For the text area a special font is set using a nested
    <code>&lt;f:font&gt;</code> tag. Fonts can be set this way for all kinds of
    graphical elements. It is also possible to share font objects between
    multiple elements. This is achieved by specifying the <code>var</code>
    attribute of the <code>&lt;f:font&gt;</code> tag. Then the font is stored
    under this name in the current context. It can be referenced by other tags
    for graphical elements using their <code>fontRef</code> attribute. Refer to
    the documentation of the
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/components/tags/FontTag.html">
    FontTag</a></code> class for more details.
  </p>
  
<p>
    But what makes the tags for the text components really complex are the validator
    definitions in their bodies. For the text area a <i>required</i>
    validator is specified which checks whether the field contains a value - it
    is not permitted to leave the field empty. A nested
    <code>&lt;f:validator&gt;</code> tag is used to assign the validator to the
    text area. The other text field contains even multiple validators. Therefore
    the <code>&lt;f:validators&gt;</code> tag occurs in the tag's body which in
    turn contains three nested <code>&lt;f:validator&gt;</code> tags. This means
    that on validation of the text field all its validators are invoked. Only if
    all of them return a valid result, the text field is considered valid.
  </p>
  
<p>
    The <code>&lt;f:validator&gt;</code> tag is derived from the
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/components/tags/UseBeanBaseTag.html">
    UseBeanBaseTag</a></code> base tag handler class. The example script
    contains different variants of this tag demonstrating the different ways to
    obtain beans:
    </p>
<ul>
    
<li>If the <code>beanName</code> attribute is used, there must be a bean
    definition with this name in the current script or in the parent bean
    context. In this example validator beans are referenced that are defined at
    the beginning of the script using <code>&lt;di:bean&gt;</code> tags.</li>
    
<li>Another variant uses the <code>class</code> attribute rather than
    <code>beanName</code>. This causes an instance of the specified class being
    created using its standard constructor - which is convenient, but less
    powerful than the variant that uses the full power of the dependency
    injection framework.</li>
    </ul>
    Regardless of the way the validator bean was created, it is passed to the
    nesting input element tag.
  
  
<p>
    This concludes our discussion of the first example builder script. You should
    now have an impression of how builder scripts look like and know the basic
    principles of defining UI elements. In the next section we discuss the tags
    for creating specific UI elements.
  </p>
  </section>

  <section>
<h3><a name="The_tags_of_the_component_builder_tag_library"></a>The tags of the component builder tag library</h3>
  
<p>
    In this sub section we present the tags that comprise the component builder
    tag library. The single tags are introduced, and their implementing tag
    handler classes are noted. We give short usage examples and mention points
    that may not be obvious or may help to avoid pitfalls. Note that this is not
    a reference of the tags with all their attributes. Reference information
    can be found in the Javadocs of the tag handler classes (which are linked
    from the describing text).
  </p>
  
<p>
    <a name="labels"></a><b>Labels and icons</b>
  </p>
  
<p>
    Labels belong to the most simple graphical components. They just display a
    text and/or an icon which cannot be changed at runtime. Nevertheless, there
    is a bunch of attributes available allowing to customize the display of the
    label. A description of all available attributes can be found in the Javadocs
    of the <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/components/tags/LabelTag.html">
    LabelTag</a></code> class.
  </p>
  
<p>
    As was already described in the subsection <a href="#A_simple_example">A
    simple example</a>, the text of a label can be defined either directly by
    specifying the <code>text</code> attribute or via a resource ID using the
    <code>textres</code> attribute. In addition, a label can have an icon. Icons
    are defined by nested <code>&lt;f:icon&gt;</code> tags which are implemented
    by the <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/components/tags/IconTag.html">
    IconTag</a></code> tag handler class. The following fragment shows an
    example of a more complicated label declaration:
  </p>
    
<div class="source">
<pre>
&lt;f:label text=&quot;Hello world!&quot; foreColor=&quot;blue&quot; mnemonic=&quot;w&quot; alignment=&quot;center&quot;
  componentref=&quot;TestComponent&quot;&gt;
  &lt;f:icon resource=&quot;icon.gif&quot;/&gt;
&lt;/f:label&gt;
    </pre></div>
  
<p>
    Here some more attributes of the <code>&lt;f:label&gt;</code> tag are used.
    A text is directly assigned, and an icon is specified by a nested
    <code>&lt;f:icon&gt;</code> tag. The <code>alignment</code> attribute
    determines the alignment of the label's text. With <code>componentref</code>
    another component (which must be defined in the same builder script) can be
    specified; this will associate the label with this component, so that
    pressing the mnemonic key of the label sets the focus on the associated
    component.
  </p>
  
<p>
    The <code>&lt;f:icon&gt;</code> tag supports various ways to obtain an icon.
    Here we use the <code>resource</code> attribute which looks up the icon in
    the class path. It is also possible to provide a URL from which the icon is
    to be loaded. The most generic way is to specify a
    <code><a href="../apidocs/net/sf/jguiraffe/locators/Locator.html">Locator
    </a></code> object via the <code>locator</code> attribute. The
    <code>Locator</code> is looked up in the current bean context.
  </p>
  
<p>
    <a name="panels"></a><b>Panels</b>
  </p>
  
<p>
    Panels are UI elements whose most important functionality is to group other
    components together. Allthough they are visible components, usually it is
    not their appearance what makes them special, but the fact that they
    operate as a container for components defining their own layout. In Java
    applications complex layouts are often implemented by nesting multiple
    panels.
  </p>
  
<p>
    Complex nesting of panels should not be necessary for <i>JGUIraffe</i>
    applications because the provided layout managers like <i>percent layout</i>
    allow the arrangement of components in a flexible and powerful way.
    Nevertheless it is often convenient to group a UI into at least two panels.
    The example dialog box presented in the <a href="#A_simple_example">A
    simple example</a> subsection used two panels: one for the main part of the
    dialog's UI and one for the buttons at the bottom. This is a typical pattern.
  </p>
  
<p>
    Panels are defined using the <code>&lt;f:panel&gt;</code> tag implemented by the
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/components/tags/PanelTag.html">
    PanelTag</a></code> class. The content of the panel is defined by tags in
    the body of the <code>&lt;f:panel&gt;</code> tag. In the most typical use case
    a <code>&lt;f:panel&gt;</code> tag does not have any attributes, but defines
    a layout manager in its body and nests tags for other components. This looks
    as in the following example:
  </p>
    
<div class="source">
<pre>
&lt;f:panel&gt;
  &lt;f:borderlayout/&gt;
  &lt;f:textarea name=&quot;mainText&quot;&gt;
    &lt;f:borderconstr name=&quot;CENTER&quot;/&gt;
  &lt;/f:textarea&gt;
&lt;/f:panel&gt;
    </pre></div>
  
<p>
    Here a panel with a <i>border layout</i> is defined. A text area is placed
    in the center part of its UI. (We cover tags for layouts soon.) The panel
    merly acts as background for the componets placed on it. The
    <code>PanelTag</code> class supports some attributes which modify the
    panel's appearance. Of course, the standard attributes for visible components
    are available, e.g. for changing the foreground or background colors. It is
    also possible to define a text as a caption for the panel or to instruct the
    panel to draw a border. A more complex example is shown below:
  </p>
    
<div class="source">
<pre>
&lt;f:panel backColor=&quot;black&quot; border=&quot;true&quot; textres=&quot;PANEL&quot; textColor=&quot;YELLOW&quot;
  resgrp=&quot;testformbuilderresources&quot;&gt;
...
&lt;/f:panel&gt;
    </pre></div>
  
<p>
    <a name="layouts"></a><b>Layouts</b>
  </p>
  
<p>
    The <i>JGUIraffe</i> library ships with several custom layout manager
    implementations. For each of them the component builder tag library
    contains corresponding tags for creating layouts and defining layout
    constraints. The following table displays the associations between layout
    manager class, tag, and tag handler class.
  </p>
  
<p>
    </p>
<table class="bodyTable" border="1">
    
<tr class="a">
      
<th>Layout manager</th>
      
<th>Tag</th>
      
<th>Tag handler class</th>
    </tr>
    
<tr class="b">
      
<td>
      <code><a href="../apidocs/net/sf/jguiraffe/gui/layout/PercentLayout.html">
      PercentLayout</a></code>
      </td>
      
<td><code>&lt;f:percentlayout&gt;</code></td>
      
<td>
      <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/components/tags/PercentLayoutTag.html">
      PercentLayoutTag</a></code>
      </td>
    </tr>
    
<tr class="a">
      
<td>
      <code><a href="../apidocs/net/sf/jguiraffe/gui/layout/BorderLayout.html">
      BorderLayout</a></code>
      </td>
      
<td><code>&lt;f:borderlayout&gt;</code></td>
      
<td>
      <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/components/tags/BorderLayoutTag.html">
      BorderLayoutTag</a></code>
      </td>
    </tr>
    
<tr class="b">
      
<td>
      <code><a href="../apidocs/net/sf/jguiraffe/gui/layout/ButtonLayout.html">
      ButtonLayout</a></code>
      </td>
      
<td><code>&lt;f:buttonlayout&gt;</code></td>
      
<td>
      <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/components/tags/ButtonLayoutTag.html">
      ButtonLayoutTag</a></code>
      </td>
    </tr>
    </table>
  
  
<p>
    <code>PercentLayout</code> is the most powerful layout manager provided by
    <i>JGUIraffe</i>. The corresponding <code>&lt;f:percentlayout&gt;</code> tag
    allows creating such a layout with all possible properties. There are two
    variants for creating a percent layout: The first variant is to specify the
    column and row constraints as strings as in the following example. This
    corresponds to the constructor of the <code>PercentLayout</code> class
    which accepts to strings:
  </p>
    
<div class="source">
<pre>
&lt;f:percentlayout columns=&quot;4dlu end/preferred 3dlu start/preferred 4dlu&quot;
  rows=&quot;4dlu preferred 1dlu preferred 1dlu preferred 1dlu preferred 4dlu&quot;/&gt;
    </pre></div>
  
<p>
    The strings passed to the attributes must be valid constraints definitions.
    The other variant uses nested <code>&lt;f:colconstr&gt;</code> and
    <code>&lt;f:rowconstr&gt;</code> tags for defining the cell constraints.
    This looks as follows:
  </p>
    
<div class="source">
<pre>
  &lt;f:percentlayout canShrink=&quot;true&quot;&gt;
    &lt;f:colconstr constr=&quot;4dlu&quot;/&gt;
    &lt;f:colconstr constr=&quot;0.5cm&quot;/&gt;
    &lt;f:colconstr constr=&quot;start/preferred&quot;/&gt;
    &lt;f:colconstr constr=&quot;3dlu&quot;/&gt;
    &lt;f:colconstr constr=&quot;full/preferred&quot;/&gt;
    &lt;f:colconstr constr=&quot;3dlu&quot;/&gt;
    &lt;f:colconstr constr=&quot;preferred&quot;/&gt;
    &lt;f:colconstr constr=&quot;3dlu&quot;/&gt;
    &lt;f:colconstr constr=&quot;full/preferred&quot;/&gt;
    &lt;f:colconstr constr=&quot;4dlu&quot;/&gt;

    &lt;f:rowconstr constr=&quot;4dlu&quot;/&gt;
    &lt;f:rowconstr constr=&quot;preferred&quot;/&gt;
    &lt;f:rowconstr constr=&quot;1dlu&quot;/&gt;
    &lt;f:rowconstr constr=&quot;start/minimum(2cm)&quot;/&gt;
    &lt;f:rowconstr constr=&quot;3dlu&quot;/&gt;
    &lt;f:rowconstr constr=&quot;preferred&quot;/&gt;
    &lt;f:rowconstr constr=&quot;1dlu&quot;/&gt;
    &lt;f:rowconstr constr=&quot;preferred&quot;/&gt;
    &lt;f:rowconstr constr=&quot;3dlu&quot;/&gt;
    &lt;f:rowconstr constr=&quot;preferred&quot;/&gt;
    &lt;f:rowconstr constr=&quot;1dlu&quot;/&gt;
    &lt;f:rowconstr constr=&quot;preferred&quot;/&gt;
    &lt;f:rowconstr constr=&quot;4dlu&quot;/&gt;

    &lt;f:colgroup idx1=&quot;4&quot; idx2=&quot;8&quot;/&gt;
  &lt;/f:percentlayout&gt;
    </pre></div>
  
<p>
    Here each nested tag defines column or row constrains for a single cell.
    The corresponding tag handler classes are
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/components/tags/PercentColConstraintsTag.html">
    PercentColConstraintsTag</a></code> and
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/components/tags/PercentRowConstraintsTag.html">
    PercentRowConstraintsTag</a></code> respective. As can be seen with the
    <code>&lt;f:colgroup&gt;</code> tag column groups can be defined. Analogously
    the <code>&lt;f:rowgroup&gt;</code> tag defines groups for rows. This also
    works if the column and row constraints are defined as attributes. The
    corresponding tag handler classes are
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/components/tags/PercentColGroupTag.html">
    PercentColGroupTag</a></code> and
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/components/tags/PercentRowGroupTag.html">
    PercentRowGroupTag</a></code>. Also note the <code>canShrink</code>
    attribute added to the <code>&lt;f:percentlayout&gt;</code> tag. It tells
    the tag that is should set the <code>canShrink</code> property of the
    generated layout.
  </p>
  
<p>
    When working with <code>PercentLayout</code> each component to be added to
    the layout must be associated with a
    <code><a href="../apidocs/net/sf/jguiraffe/gui/layout/PercentData.html">
    PercentData</a></code> constraints object. In a builder script this is
    achieved by placing the <code>&lt;f:percentconstr&gt;</code> tag in the
    body of the tag defining the associated component.
    <code>&lt;f:percentconstr&gt;</code> is implemented by the
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/components/tags/PercentConstraintsTag.html">
    PercentConstraintsTag</a></code> class and supports attributes for setting
    all properties of a <code>PercentData</code> object, e.g. the position in
    the grid, the span, the target cell, or additional constraints. The
    following fragment shows an example of using this tag:
  </p>
    
<div class="source">
<pre>
&lt;f:label textres=&quot;viewset_lab_filtertypes&quot;&gt;
  &lt;f:percentconstr col=&quot;1&quot; row=&quot;1&quot; spanx=&quot;2&quot;/&gt;
&lt;/f:label&gt;
    </pre></div>
  
<p>
    Another layout manager supported by <i>JGUIraffe</i> is <i>border layout</i>.
    Layouts of this type can be created using the <code>&lt;f:borderlayout&gt;</code>
    tag implemented by the
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/components/tags/BorderLayoutTag.html">
    BorderLayoutTag</a></code> class. This tag provides attributes to set all
    the properties supported by a <code>BorderLayout</code> object, namely the
    margins and gaps between the areas of the layout. The constraints used by
    <code>BorderLayout</code> are strings defining one of the five possible
    areas (NORTH, EAST, SOUTH, WEST, CENTER) in which a component is to be
    placed. They are defined by <code>&lt;f:borderconstr&gt;</code> tags placed
    in the bodies of the tags for the associated components. The following
    example demonstrates how this looks in practice:
    </p>
<div class="source">
<pre>
&lt;f:borderlayout leftMargin=&quot;0.5cm&quot; rightMargin=&quot;0.5cm&quot; topMargin=&quot;0.25cm&quot;
  bottomMargin=&quot;0.25cm&quot; northGap=&quot;2dlu&quot; southGap=&quot;2dlu&quot;&gt;
  &lt;f:label text=&quot;Label in the north&quot;&gt;
    &lt;f:borderconstr name=&quot;NORTH&quot;/&gt;
  &lt;/f:label&gt;
  &lt;f:panel&gt;
    &lt;f:borderconstr name=&quot;CENTER&quot;/&gt;
    &lt;!-- Content of panel in the center --&gt;
    ...
  &lt;/f:panel&gt;
&lt;/f:borderlayout&gt;
    </pre></div>
  
  
<p>
    A <code>ButtonLayout</code> is specialized on placing buttons in a dialog
    box. The corresponding tag is  <code>&lt;f:buttonlayout&gt;</code>,
    implemented by the
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/components/tags/ButtonLayoutTag.html">
    ButtonLayoutTag</a></code> class. Again the properties of the layout are
    defined using attributes: it is possible to set the margins of the layout,
    the gap between the buttons, and the alignment of the whole button bar
    (<i>left</i>, <i>right</i>, or <i>center</i>). For a button layout no
    constraints are needed because the buttons are placed in the layout in the
    order they are added. The following listing shows an example:
  </p>
    
<div class="source">
<pre>
&lt;f:panel&gt;
  &lt;f:buttonlayout leftMargin=&quot;0.25cm&quot; rightMargin=&quot;0.25cm&quot; gap=&quot;0.5cm&quot;
    align=&quot;right&quot;/&gt;
  &lt;f:button name=&quot;btnOk&quot; textres=&quot;viewset_btn_save&quot;
    mnemonicres=&quot;viewset_btn_save_mnemo&quot; default=&quot;true&quot;/&gt;
  &lt;f:button name=&quot;btnCancel&quot; textres=&quot;viewset_btn_cancel&quot;
    mnemonicres=&quot;viewset_btn_cancel_mnemo&quot; cancel=&quot;true&quot;/&gt;
&lt;/f:panel&gt;
    </pre></div>
  
<p>
    <a name="static_texts"></a><b>Static texts</b>
  </p>
  
<p>
    We already discussed <a href="#labels">labels</a> which are used to output
    texts and icons the user cannot manipulate. Labels are immutable; once created
    they cannot be changed any more. Sometimes an application wants to display
    text and/or icons that can change dynamically. For this purpose the
    component builder tag library provides the <code>&lt;statictext&gt;</code>
    tag which is implemented by the
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/components/tags/StaticTextTag.html">
    StaticTextTag</a></code> class.
  </p>
  
<p>
    The definition of a static text is very similar to a regular label definition.
    The <code>&lt;statictext&gt;</code> tag supports the same attributes.
    However, under the hood it creates a fully-functional input component for
    the text - which means that there is an associated
    <code>ComponentHandler</code> for it. The component handler can be accessed
    from the <code>ComponentBuilderData</code> object using the name specified
    in the <code>&lt;statictext&gt;</code> tag's <code>name</code> attribute. It
    can be cast to the specialized handler interface
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/components/model/StaticTextHandler.html">
    StaticTextHandler</a></code> which provides convenient methods for
    manipulating the text and the icon directly. Note that per default no field
    is created for the static text element in the form object created by the
    builder. The following fragment of a builder script shows the declaration of
    a static text element:
  </p>
    
<div class="source">
<pre>
&lt;f:statictext name=&quot;staticText&quot; textres=&quot;STATIC_TEXT&quot; alignment=&quot;right&quot;&gt;
  &lt;f:icon resource=&quot;icon.gif&quot;/&gt;
&lt;/f:statictext&gt;
    </pre></div>
  
<p>
    As can be seen, a static text can be assigned a text and an icon in the
    same way as a label. Given this declaration, the element can be manipulated
    (e.g. by a form controller class) in the following way:
  </p>
    
<div class="source">
<pre>
StaticTextHandler handler = (StaticTextHandler)
  getComponentBuilderData().getComponentHandler(&quot;staticText&quot;);
handler.setText(&quot;new text&quot;);
    </pre></div>
  
<p>
    The following rule of thumb can be used to determine whether a plain label
    or a static text element should be used: If the element is not changed
    during the life time of the application, use a label. Otherwise take a static
    text and manipulate it accordingly.
  </p>
  
<p>
    Although there exists a <code>ComponentHandler</code> for each static text
    element, the handlers are not added to the form object constructed for the
    UI per default. This is typically not desired because these elements are not
    used to gather user input and therefore do not need a corresponding
    property in the model object of the form. However, the default behavior can
    be changed by setting the <code>noField</code> attribute of the
    <code>&lt;statictext&gt;</code> tag to <b>false</b>. The tag
    should then also be given a name. Then it is possible to write data from
    the model object of the form into the UI elements.
  </p>
  
<p>
    There is one problem however:
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/components/model/StaticTextHandler.html">
    StaticTextHandler</a></code> expects that it is passed data as
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/components/model/StaticTextData.html">
    StaticTextData</a></code> objects; therefore the properties of the form's
    model bound to static text elements must be of this type. This is
    inconvenient for instance if the elements are used to display mutable text
    only. In order to simplify this use case, <i>JGUIraffe</i> provides a
    special <a href="validators.html">transformer</a> implementation which can
    convert data to <code>StaticTextData</code> objects:
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/components/tags/StaticTextDataTransromer.html">
    StaticTextDataTransromer</a></code>. Among other things, this class is able
    to transform a plain text string into a <code>StaticTextData</code> object
    which can then be used to initialize the static text element. So if this
    transformer is applied, properties of the form's model object can be
    simple types. We will see in a moment how transformers are assigned to UI
    elements.
  </p>
  
<p>
    <a name="transformers"></a><b>Transformers</b>
  </p>
  
<p>
    Often an application has the requirement that a user enters data of
    specific data types. As an example consider an order entry application which
    allows the user to enter the quantity of the product to be ordered. Input
    fields typically do not know about numbers, but only operate on text. So the
    text data used internally by the input component has to be converted to a
    number to be compatible with the model of the form. Analoguously, if the
    input fields are populated from the model of the form, another data type
    conversion has to be performed from number to string. This is where
    transformers come into play. They can handle arbitrary conversions of form
    data. Refer to the section <a href="validators.html">Transformers and
    Validators</a> for more background information.
  </p>
  
<p>
    Every input component can be assigned up to two transformers:
    </p>
<ul>
    
<li>The <i>read transformer</i> is invoked when the data entered by the
    user is read and stored in the form's model.</li>
    
<li>The <i>write transformer</i> is invoked when the input components are
    populated with data from the form's model.</li>
    </ul>
    Transformers are specified using <code>&lt;f:transformer&gt;</code> tags
    placed in the bodies of input component tags. The tag handler implementation
    class is
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/components/tags/TransformerTag.html">
    TransformerTag</a></code>.
    Have a look at the following example:
  
    
<div class="source">
<pre>
  &lt;!-- Transformer for converting arbitrary data to string --&gt;
  &lt;di:bean name=&quot;stringTransformer&quot;
    beanClass=&quot;net.sf.jguiraffe.transform.ToStringTransformer&quot;&gt;
  &lt;/di:bean&gt;

  &lt;!-- A validator/transformer for date input fields.--&gt;
  &lt;di:bean name=&quot;dateTransformer&quot;
    beanClass=&quot;net.sf.jguiraffe.transform.DateTransformer&quot;&gt;
  &lt;/di:bean&gt;

  ...

    &lt;f:textfield name=&quot;dateField&quot;&gt;
      &lt;f:transformer type=&quot;read&quot; beanName=&quot;dateTransformer&quot;/&gt;
      &lt;f:transformer type=&quot;write&quot; beanName=&quot;stringTransformer&quot;/&gt;
    &lt;/f:textfield&gt;
    </pre></div>
  
<p>
    Here a field is defined that allows the user to enter a date. This is
    implemented by assigning two transformers to the text field: the read
    transformer is able to parse a string into a date; the write transformer
    can transform arbitrary objects to strings. Both transformers are defined
    using <code>&lt;di:bean&gt;</code> tags and referenced by the
    <code>&lt;f:transformer&gt;</code> tags. Because <code>TransformerTag</code>
    is derived from
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/components/tags/UseBeanBaseTag.html">
    UseBeanBaseTag</a></code> it can also directly create transformer objects.
    However, using the <code>&lt;di:bean&gt;</code> tag for this purpose is more
    powerful. This also allows sharing the transformers for multiple components
    (which does not cause any problems; because the UI is accessed only by a
    single thread there can be no race conditions): just reference the transformer bean from multiple
    <code>&lt;f:transformer&gt;</code> tags. By the way, the transformers used
    in this example are standard transformers shipped with the <i>JGUIraffe</i>
    library. The standard transformers support many primitive data types so that
    it is easy to implement text fields for entering data in these types.
  </p>
  
<p>
    One note: When working with transformers it must be ensured that the data
    entered by the user can actually be transformed into the target data type;
    otherwise the transformer throws an exception. The easiest way to do this is
    to add a corresponding validator to the input component. The validator is
    invoked first, and only if it signals that the data is valid, the
    transformer is called.
  </p>
  
<p>
    <a name="validators"></a><b>Validators</b>
  </p>
  
<p>
    The handling of validators in builder scripts is pretty similar to the
    handling of <a href="#transformers">transformers</a>. Actually, the tag
    handler class for validators,
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/components/tags/ValidatorTag.html">
    ValidatorTag</a></code>, is derived from the same base class as the tag
    handler class for transformers. Like transformers, validators are defined by
    tags nested in the bodies of input element tags. This time the name of the
    tag is <code>&lt;f:validator&gt;</code>. It supports the same attributes
    for creating or referencing the validator object. In addition the
    <code>phase</code> attribute is available which controls when the validator
    is invoked. It accepts the following values:
    </p>
<ul>
    
<li><i>syntax</i> means that the validator is invoked directly on the raw
    data obtained from the associated input element. It has to check whether this
    data can be converted to the desired target data type (i.e. whether the
    read transformer can be called successfully). This is the standard value if
    the <code>phase</code> attribute is not provided.</li>
    
<li><i>logic</i> means that the validator is invoked after the read
    transformer. Thus it has access to the converted value. It can perform
    checks on a logic level, e.g. whether the value fulfills certain
    constraints.</li>
    </ul>
    Let's extend the example from the <a href="#transformers">Tranformers</a>
    section to specifiy a validator, too:
  
    
<div class="source">
<pre>
  &lt;!-- Transformer for converting arbitrary data to string --&gt;
  &lt;di:bean name=&quot;stringTransformer&quot;
    beanClass=&quot;net.sf.jguiraffe.transform.ToStringTransformer&quot;&gt;
  &lt;/di:bean&gt;

  &lt;!-- A validator/transformer for date input fields.--&gt;
  &lt;di:bean name=&quot;dateTransformer&quot;
    beanClass=&quot;net.sf.jguiraffe.transform.DateTransformer&quot;&gt;
  &lt;/di:bean&gt;

  ...

    &lt;f:textfield name=&quot;dateField&quot;&gt;
      &lt;f:transformer type=&quot;read&quot; beanName=&quot;dateTransformer&quot;/&gt;
      &lt;f:transformer type=&quot;write&quot; beanName=&quot;stringTransformer&quot;/&gt;
      &lt;f:validator phase=&quot;syntax&quot; beanName=&quot;dateTransformer&quot;/&gt;
    &lt;/f:textfield&gt;
    </pre></div>
  
<p>
    The only change is that a <code>&lt;f:validator&gt;</code> tag was added.
    Note that it references the same bean as the tag for the read transformer.
    This is because many of the standard transformers provided by
    <i>JGUIraffe</i> are also validators. So they can play both roles.
  </p>
  
<p>
    Transformers and validators specified using the corresponding tags can be
    configured using additional properties. One use case is to override some
    properties of the transformer or validator object. As was already pointed
    out, transformers and validators can be shared between multiple input
    components. Now it is possible that many components operate with standard
    settings of the objects, but a single component has some special
    requirements - for instance, a different format for the values should be
    used. Instead of defining two transformer beans for the different
    requirements, a single one can be used. For the input component with
    special requirements properties can be defined which override the settings
    to be adapted. As an example consider a validator for numbers. We might
    have multiple input components that allow the user to enter arbitrary
    numeric values. Then there is a special component in which the number
    must be greater than a given value. This can be achieved with the
    following declarations:
  </p>
    
<div class="source">
<pre>
  &lt;!-- A validator/transformer for numeric input fields.--&gt;
  &lt;di:bean name=&quot;numberTransformer&quot;
    beanClass=&quot;net.sf.jguiraffe.transform.IntegerTransformer&quot;&gt;
  &lt;/di:bean&gt;

  ...

    &lt;f:textfield name=&quot;specialField&quot;&gt;
      &lt;f:validator phase=&quot;syntax&quot; beanName=&quot;dateTransformer&quot;&gt;
        &lt;f:properties&gt;
          &lt;f:property property=&quot;minimum&quot; value=&quot;25&quot;/&gt;
        &lt;/f:properties&gt;
      &lt;/f:validator&gt;
    &lt;/f:textfield&gt;
    </pre></div>
  
<p>
    Here a generic transformer/validator for numeric input is defined as a
    bean. For the special input field this object is referenced, but additional
    properties are provided which define a minimum value. Properties are
    implemented by the
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/components/tags/PropertiesTag.html">
    PropertiesTag</a></code> tag handler class. The single properties are
    defined by nested <code>&lt;f:property&gt;</code> tags implemented by
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/components/tags/PropertyTag.html">
    PropertyTag</a></code>. Sometimes the values of properties are texts to be
    displayed to the user, e.g. special validation error messages. In this case,
    the texts may need to be localized so that they are in the language of the
    current user. This can be achieved by using the <code>&lt;f:localized&gt;</code>
    tag in the body of <code>&lt;f:property&gt;</code>. This tag is implemented by
    the <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/components/tags/LocalizedTag.html">
    LocalizedTag</a></code> class. It can be specified a resource ID which is
    resolved to obtain the property's value. The following example shows how a
    validator can be configured to create a customized error message which is
    obtained from the application's resources:
  </p>
    
<div class="source">
<pre>
&lt;f:textfield name=&quot;specialField&quot;&gt;
  &lt;f:validator phase=&quot;syntax&quot;
    class=&quot;net.sf.jguiraffe.transform.IntegerTransformer&quot;&gt;
    &lt;f:properties&gt;
      &lt;f:property property=&quot;ERR_INVALID_NUMBER&quot;&gt;
        &lt;f:localized resid=&quot;my_error_resource&quot;/&gt;
      &lt;/f:property&gt;
    &lt;/f:properties&gt;
  &lt;/f:validator&gt;
&lt;/f:textfield&gt;
    </pre></div>
  
<p>
    Using these tags it is easy to adapt the error messages produced by
    validators. All validator classes document in their Javadocs the keys of
    the error messages they can produce. By setting a property with a specific
    key the corresponding error message can be customized. The
    <code>&lt;f:localized&gt;</code> tag can be used to select the message text
    in the correct language.
  </p>
  
<p>
    One difference between transformers and validators is that an input element
    can have an arbitrary number of validators while there is only a single
    read or write transformer. This can make sense if there are multiple
    validation rules to be checked. To define multiple validators the
    <code>&lt;f:validators&gt;</code> tag (implemented by the
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/components/tags/ValidatorsTag.html">
    ValidatorsTag</a></code> class) is used. In the body of this tag multiple
    <code>&lt;f:validator&gt;</code> tags can be placed which are collected and
    combined to a single
    <code><a href="../apidocs/net/sf/jguiraffe/transform/ChainValidator.html">
    ChainValidator</a></code> object. This looks as follows:
  </p>
    
<div class="source">
<pre>
  &lt;f:textfield name=&quot;fileName&quot;&gt;
    &lt;f:validators phase=&quot;syntax&quot;&gt;
      &lt;f:validator beanName=&quot;requiredValidator&quot;/&gt;
      &lt;f:validator beanName=&quot;fileNameValidator&quot;/&gt;
      &lt;f:validator
        class=&quot;net.sf.jguiraffe.examples.tutorial.createfile.UniqueFileNameValidator&quot;/&gt;
    &lt;/f:validators&gt;
  &lt;/f:textfield&gt;
    </pre></div>
  
<p>
    <a name="textcomponents"></a><b>Text components</b>
  </p>
  
<p>
    Input fields for texts belong to the most basic components used within forms.
    Of course, they are used to enter arbitrary text input from the user, but by
    assigning appropriate transformers and validators (refer to the corresponding
    sections), other data types - like number or date - are supported, too.
  </p>
  
<p>
    The component builder tag library provides three tags for creating text
    input components for different purposes:
    </p>
<ul>
    
<li><code>&lt;f:textfield&gt;</code> (implemented by the
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/components/tags/TextFieldTag.html">
    TextFieldTag</a></code> class) produces plain single-line text input fields.
    They can be configured by specifying the number of columns to be displayed
    - which gives a hint about the preferred width of the text field - and the
    maximum length of the text to be entered.<br /></li>
    
<li><code>&lt;f:password&gt;</code> (implemented by the
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/components/tags/PasswordFieldTag.html">
    PasswordFieldTag</a></code> class) generates an input field for entering a
    password. A password field is pretty similar to a regular text field and
    allows the same configuration options. The only difference is that the
    characters typed by the user are not directly displayed, but only an echo
    character is printed.<br /></li>
    
<li><code>&lt;f:textarea&gt;</code> (implemented by the
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/components/tags/TextAreaTag.html">
    TextAreaTag</a></code> class) is responsible for the creation of multi-line
    text input fields. These fields can be used to enter larger amounts of text.
    They also have built-in support for scrollbars if the text becomes larger
    than the visible area on the screen. A text area can be configured with the
    number of columns and rows to be displayed which influence the size of the
    component. In addition the maximum length of the text to be entered can be
    specified and a flag whether automatic line wrapping is to be performed.</li>
    </ul>
    The following listing gives some examples of declarations for text components:
  
    
<div class="source">
<pre>
&lt;f:textfield name=&quot;name&quot;/&gt;
&lt;f:textfield name=&quot;firstName&quot; columns=&quot;20&quot;/&gt;
&lt;f:textfield name=&quot;street&quot; maxlength=&quot;30&quot;/&gt;
&lt;f:textfield name=&quot;city&quot; columns=&quot;20&quot; maxlength=&quot;35&quot;/&gt;
&lt;f:password name=&quot;pwd&quot; columns=&quot;8&quot; maxlength=&quot;10&quot;/&gt;
&lt;f:textarea name=&quot;remarks&quot; columns=&quot;40&quot; rows=&quot;5&quot; maxlength=&quot;1000&quot; wrap=&quot;true&quot;/&gt;
    </pre></div>
  
<p>
    One pitfall when working with text components is the sizing of the fields.
    If a percent layout is used, and the cell constraints are set to <i>preferred
    size</i>, the underlying GUI toolkit tries to determine the size of the
    text field. At least for Swing the results are not really satisfying. If no
    specific configuration options are set, Swing assumes very small sizes; you
    often end up with just a narrow white bar on the screen. To avoid this, you
    can specify the number of columns to be displayed. This makes the text field
    wider, but does not allow a precise sizing. With percent layout you can also
    specify a minimum cell size. This is well suited for working with text
    fields. If a text field is placed in a cell with a minimum width of - say -
    4 cm, the sizing problem is solved. An alternative for determinining the size
    of the text component is described in the next section which is about
    <a href="#scrolling">scrolling support</a>.
  </p>
  
<p>
    For text components <i>JGUIraffe</i> provides a specialized component
    handler interface:
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/components/model/TextHandler.html">
    TextHandler</a></code>. Through this interface extended functionality
    available for text components can be accessed. For instance, it is possible
    to query or manipulate the current selection, or to interact with the system
    clipboard. The <code>ComponentHandler</code> returned for a text component
    can be cast to <code>TextHandler</code>.
  </p>
  
<p>
    <a name="scrolling"></a><b>Scrolling support</b>
  </p>
  
<p>
    Some input components allow handling of large amounts of data. For instance,
    a user might want to type a whole play of Shakespeare into a text area. Of
    course, this is more text than fits onto the screen. Therefore such
    components only display a portion of the data they contain and provide
    scroll bars allowing the user to navigate to other parts of their data.
    This is a well-known concept of windowing systems every user should be
    familiar with.
  </p>
  
<p>
    If you have ever worked with Swing, you probably know that Swing controls do
    not support scrolling on their own. Rather, components like text areas or
    tables have to be added to a <code>javax.swing.JScrollPane</code>. The
    scroll pane implements the whole scrolling logic; it queries the total size
    of the wrapped component, determines the preferred size on the screen, and
    displays scroll bars as necessary. The <i>JGUIraffe</i> library uses a
    different approach: It does not provide a scroll pane component. Instead,
    components that may become larger than the screen size are automatically
    added to a scroll pane. This is fully transparent to the developer.
  </p>
  
<p>
    There is, however, one aspect related to scrolling the developer should be
    aware of: the preferred screen size of components that allow scrolling. In
    most cases, because of the scrolling capabilities, the screen size of such
    components does not really matter to make them usable: even if a text area
    is very small, by using the provided scroll bars the user can read the full
    text it contains. Because of that it is hard to determine a preferred screen
    size automatically, and the developer might want to give some hints. Text
    area components for instance can be initialized with the number of columns
    and rows they should display (as shown in the section
    <a href="#textcomponents">Text components</a>). Based on this
    information the preferred screen size can be calculated. For other
    components, e.g. tree views or tables, there are no such obvious ways to
    indicate a preferred size on the screen.
  </p>
  
<p>
    The <i>component builder tag library</i> provides a standard means to set
    the preferred screen size of scrolling-enabled components. All tags which
    define components of this category support the attributes
    <code>scrollWidth</code> and <code>scrollHeight</code>. Here the developer
    can provide a string value compatible with the
    <code><a href="../apidocs/net/sf/jguiraffe/gui/layout/NumberWithUnit.html">
    NumberWithUnit</a></code> class, e.g. <code>10 cm</code> or
    <code>100 px</code>. Both attributes are optional, if one is missing, the
    corresponding size is set to a default value based on the component
    affected. The following example shows how the preferred height is set for a
    list box component (lists are described in the section
    <a href="#lists_combos">Lists and combo boxes</a>):
  </p>
    
<div class="source">
<pre>
&lt;f:list name=&quot;fileTypes&quot; multi=&quot;true&quot; scrollHeight=&quot;3cm&quot;&gt;
  ...
&lt;/f:list&gt;
    </pre></div>
  
<p>
    Here it is specified that the preferred screen height of the list is 3
    centimeters. The layout manager will take this information into account when
    determining the sizes of the components in the hosting window. (Of course,
    the list component can later grow or shrink depending on the layout settings
    and the total space available.) The preferred scroll width has not been
    specified, so here a default value is used - in this case the value is
    calculated based on the widths of the list elements to be displayed.
  </p>
  
<p>
    The <code>scrollWidth</code> and <code>scrollHeight</code> attributes are
    supported by tags for the following UI elements:
    </p>
<ul>
    
<li><a href="#textcomponents">Text areas</a></li>
    
<li><a href="#lists_combos">Lists</a></li>
    
<li><a href="#trees">Trees</a></li>
    
<li><a href="#tables">Tables</a></li>
    </ul>
  
  
<p>
    <a name="checkboxes"></a><b>Checkboxes</b>
  </p>
  
<p>
    Checkboxes are typically used to let the user enter data of type boolean.
    They are also part of the set of standard input components. In
    <i>JGUIraffe</i> checkboxes are created using the
    <code>&lt;f:checkbox&gt;</code> tag which is implemented by the
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/components/tags/CheckboxTag.html">
    CheckboxTag</a></code> class.
  </p>
  
<p>
    Using checkboxes is pretty easy. Actually the attributes supported by the
    <code>&lt;f:checkbox&gt;</code> tag are very similar to the ones available
    for labels. You can
    </p>
<ul>
    
<li>specify a text for the checkbox - either directly or via a resource ID</li>
    
<li>define an icon using a nested <code>&lt;f:icon&gt;</code> tag</li>
    
<li>set an alignment</li>
    
<li>define a mnemonic so that the checkbox can be triggered using keyboard
    short cuts.</li>
    </ul>
    Of course, the standard attributes for input elements and visual components
    are also available. The following fragment shows some examples of checkbox
    declarations:
  
    
<div class="source">
<pre>
&lt;f:checkbox name=&quot;fine&quot; text=&quot;Everything fine?&quot; foreColor=&quot;blue&quot; mnemonic=&quot;f&quot;/&gt;
&lt;f:checkbox name=&quot;checkIcon&quot; backColor=&quot;black&quot; alignment=&quot;center&quot;&gt;
  &lt;f:icon resource=&quot;icon.gif&quot;/&gt;
&lt;/f:checkbox&gt;
&lt;f:checkbox name=&quot;cbx1&quot; textres=&quot;CHECK1&quot; resgrp=&quot;testformbuilderresources&quot;/&gt;
&lt;f:checkbox name=&quot;cbx2&quot; textres=&quot;CHECK2&quot; mnemonicres=&quot;CHECK2&quot;/&gt;
    </pre></div>
  
<p>
    <a name="componentgroups"></a><b>Component groups</b>
  </p>
  
<p>
    Sometimes a number of components logically belongs together. As an example
    consider a dialog box consisting of several areas where each area is
    specific to a use case. Depending on the state of the application or the
    dialog the components in some of the areas may not be available. In this
    scenario it would be convenient to have a means for grouping components
    together: groups could be created for the different areas, and then it would
    be possible to enable or disable all components in a group in a single step.
  </p>
  
<p>
    The component builder tag library supports groups of components. Here groups
    are non-visual components. They are represented by the
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/components/ComponentGroup.html">
    ComponentGroup</a></code> class. A <code>ComponentGroup</code> is a logic
    construct which only stores the names of the elements that are part of the
    group. The class provides some methods to obtain the actual components or
    their component handlers. A few operations for manipulating the elements are
    available, too. To access the components in a group, usually a
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/components/ComponentBuilderData.html">
    ComponentBuilderData</a></code> object must be available; this is required
    for resolving the component names.
  </p>
  
<p>
    In a builder script the <code>&lt;f:group&gt;</code> tag is used to create a
    component group. As a mandatory attribute the (unique) group name must be
    provided. For assigning components to groups there are two options:
    </p>
<ul>
    
<li>Each input element tag supports the <code>group</code> attribute. Here
    a comma-separated list with names of component groups can be specified. The
    component is then added to all of these groups (a single component can belong
    to multiple groups).</li>
    
<li>Tags for input elements can also be placed in the body of a
    <code>&lt;f:group&gt;</code> tag. They are then automatically added to the
    corresponding component group unless they have a different <code>groups</code>
    attribute. This is a very compact and readable way to define a component
    group because it is pretty obvious which elements are part of the group.
    However, depending on layout requirements it may not always be possible to
    place all group members into the tag body. In this case the other option is
    needed.</li>
    </ul>
    Here are some examples for the definition of component groups:
  
    
<div class="source">
<pre>
&lt;f:group name=&quot;group1&quot;/&gt;
&lt;f:group name=&quot;group2&quot;/&gt;

&lt;f:textfield name=&quot;text1&quot; groups=&quot;group1&quot;/&gt;
&lt;f:textfield name=&quot;text2&quot; groups=&quot;group1, group2&quot;/&gt;

&lt;f:group name=&quot;group3&quot;&gt;
  &lt;f:textfield name=&quot;text3&quot;/&gt;
  &lt;f:textfield name=&quot;text4&quot;/&gt;
  &lt;f:textfield name=&quot;text5&quot; groups=&quot;group2&quot;/&gt;
&lt;/f:group&gt;
    </pre></div>
  
<p>
    In the first block two <code>&lt;f:group&gt;</code> tags with empty bodies
    are used. This creates two empty component groups. The groups are populated
    later on with components that have the <code>groups</code> attribute set
    accordingly. Creating the groups first is mandatory because the names passed
    to the <code>groups</code> attribute must reference existing component
    groups. For the component group with the name &quot;group3&quot; the
    alternative option is used: here all of its elements are declared in the body
    of the tag. Note that one element in the body specifies a different group in
    its <code>groups</code> attribute, so it won't be added to this group.
  </p>
  
<p>
    After executing this builder script the component groups can be accessed from
    the bean context created during the builder operation. The
    <code>ComponentGroup</code> class defines the static
    <code>fromBeanContext()</code> method for this purpose. In the subsection
    <a href="#Fundamental_classes_and_interfaces">Fundamental classes and
    interfaces</a> there was an example of how the enabled status of a
    component could be changed based on a clicked checkbox. We can now extend
    this example to manipulate a whole group of components that all depent on
    this checkbox. So there is again a form controller which is registered as
    change listener at the checkbox. Whenever the checkbox is changed the
    event listener method determines the current state of the checkbox and
    enables or disables all elements of the group accordingly. The following
    listing shows this use case:
  </p>
    
<div class="source">
<pre>
/** Constant for the name of the check box component. */
private static final String COMP_CHECKBOX = &quot;testCheckBox&quot;;

/** Constant for the name of the dependent component group. */
private static final String GROUP_NAME = &quot;dependentComponents&quot;;

/**
 * Notifies this object about a change in the data of an element.
 * @param e the change event
 */
public void elementChanged(FormChangeEvent e)
{
    // obtain the handler for the check box (the type-safety warning can be
    // suppressed because we know that it is a check box handler
    @SuppressWarnings(&quot;unchecked&quot;)
    ComponentHandler&lt;Boolean&gt; checkHandler = (ComponentHandler&lt;Boolean&gt;)
        getComponentBuilderData().getComponentHandler(COMP_CHECKBOX);
    enableGroup(GROUP_NAME, handler.getData());
}

/**
 * Helper method for enabling a component group.
 *
 * @param groupName the name of the group
 * @param enabled the enabled flag
 */
private void enableGroup(String groupName, boolean enabled)
{
    ComponentGroup group = ComponentGroup.fromBeanContext(
            getComponentBuilderData().getBeanContext(), groupName);
    try
    {
        group.enableGroup(getComponentBuilderData(), enabled);
    }
    catch (FormBuilderException fex)
    {
        // should normally not happen
        log.warn(&quot;Error when enabling group &quot; + groupName, fex);
    }
}
    </pre></div>
  
<p>
    In this example the helper method <code>enableGroup()</code> enables or
    disables all components that are part of the specified component group. When
    dealing with component groups, in most cases a reference to the
    <code>ComponentBuilderData</code> object is needed. First the
    <code>ComponentGroup</code> object representing the desired group is obtained
    through the static <code>fromBeanContext()</code> method. The bean context
    is queried from the <code>ComponentBuilderData</code> object.
    <code>ComponentGroup</code> provides the <code>enableGroup()</code> method
    which sets the enabled state of all components that belong to the group.
    Again a reference to the <code>ComponentBuilderData</code> object is
    required for this purpose to resolve the components. This method can throw
    an exception if a component cannot be resolved.
  </p>
  
<p>
    <a name="radios"></a><b>Radio buttons</b>
  </p>
  
<p>
    After the excursus about <a href="#componentgroups">Component groups</a> in
    the last subsection we can now describe radio buttons. The understanding of
    component groups is a prerequisite for the understanding of radio buttons.
  </p>
  
<p>
    In <i>JGUIraffe</i> applications radio buttons are created using the
    <code>&lt;f:radio&gt;</code> tag which is implemented by the
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/components/tags/RadioButtonTag.html">
    RadioButtonTag</a></code> class. From its properties and its underlying
    data a radio button is similar to a checkbox. Actually, the
    <code>&lt;f:radio&gt;</code> tag shares many of the attributes supported by
    the <code>&lt;f:checkbox&gt;</code> tag: again a text (either directly or as
    resource ID), an icon, the alignment, and a mnemonic can be specified. Like
    a checkbox a radio button can either be checked or not, therefore it is
    associated with a <code>ComponentHandler</code> of type boolean.
  </p>
  
<p>
    What makes radio buttons special is the fact that they make only sense in
    groups: here the special property that only a single radio button can be
    selected comes into play. This property makes radio buttons surprisingly
    complex and also influences the data applications wish to store for radio
    buttons. Typically an application does not want to model a group of radio
    buttons as a set of boolean flags telling for each radio button whether it
    is selected or not. Rather, a single information is to be stored for the
    whole group indicating which of the radio buttons is selected. This could be
    a numeric index of the selected radio button in the group or maybe a value
    of an enumeration class. So from a logic point of view radio buttons are
    not treated as single, independent input components, but they are combined
    to a <i>radio group</i> which is handled as an input component on its own.
  </p>
  
<p>
    The component builder tag library supports this use case by providing another
    tag for creating radio groups: the <code>&lt;f:radioGroup&gt;</code> tag
    implemented by the
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/components/tags/RadioGroupTag.html">
    RadioGroupTag</a></code> class. <code>&lt;f:radioGroup&gt;</code> can be
    used in the same way as the <code>&lt;f:group&gt;</code> tag: The tag has a
    mandatory <code>name</code> attribute that defines the name of the radio
    group, and the tags for the radio buttons that are part of the group can be
    placed in the body. Alternatively - if layout requirements do not permit
    such a nesting - radio buttons can be added to a radio group by
    specifying the group name in the <code>groups</code> attribute of the
    <code>&lt;f:radio&gt;</code> tag. The following fragment shows an
    example of how to define a radio group (layout-related tags have been
    omitted):
  </p>
    
<div class="source">
<pre>
&lt;f:radioGroup name=&quot;sortColumn&quot;&gt;
  &lt;f:radio name=&quot;sortColumnName&quot; textres=&quot;viewset_rad_sortcolname&quot;/&gt;
  &lt;f:radio name=&quot;sortColumnDate&quot; textres=&quot;viewset_rad_sortcoldate&quot;/&gt;
  &lt;f:radio name=&quot;sortColumnSize&quot; textres=&quot;viewset_rad_sortcolsize&quot;/&gt;
&lt;/f:radioGroup&gt;
    </pre></div>
  
<p>
    The basic idea is now that only for the radio group as a whole a field is
    added to the current <code>Form</code> object, not for the single radio
    buttons. Therefore a <code>ComponentHandler</code> managing the data of the
    radio group is created. Per default, this is an instance of the
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/components/model/DefaultRadioButtonHandler.html">
    DefaultRadioButtonHandler</a></code> class. <code>DefaultRadioButtonHandler</code>
    has the data type <code>java.lang.Integer</code>; it determines the index of
    the selected radio button in the group and returns it as its data. This may
    be appropriate for simple use cases, but has the danger that the meaning of
    the index changes if the radio buttons are rearranged in the group. So you
    might want to provide a different <code>ComponentHandler</code>
    implementation.
  </p>
  
<p>
    This can be achieved by nesting a <code>&lt;f:componentHandler&gt;</code>
    tag (implemented by the
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/components/tags/ComponentHandlerTag.html">
    ComponentHandlerTag</a></code> class) in the body of the
    <code>&lt;f:radioGroup&gt;</code> tag. Here another component handler
    implementation can be specified. Writing a custom component handler for a
    radio group is easy because with
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/components/model/AbstractRadioButtonHandler.html">
    AbstractRadioButtonHandler</a></code> there is already a base class providing
    the major part of the required functionality. Concrete subclasses only have
    to define the mapping between the index of the selected radio button in the
    group and the data value to store for this group.
  </p>
  
<p>
    As a simple example consider a radio group with two radio buttons for the
    options &quot;Yes&quot; and &quot;No&quot;. Because the user has only two
    options this can be modeled using a boolean value. (This radio group is
    equivalent to a single checkbox, but let's assume that due to layouting
    considerations radio buttons should be used.) So for the radio group a
    <code>ComponentHandler</code> implementation is needed that maps the data of
    the group to a <code>java.lang.Boolean</code> value. First we present the
    XML definition of the radio group:
    </p>
<div class="source">
<pre>
&lt;f:radioGroup name=&quot;yesOrNo&quot;&gt;
  &lt;f:componentHandler
    class=&quot;net.sf.jguiraffe.examples.tutorial.viewset.BooleanRadioButtonHandler&quot;/&gt;
  &lt;f:radio name=&quot;radioYes&quot; text=&quot;Yes&quot;/&gt;
  &lt;f:radio name=&quot;radioNo&quot; text=&quot;No&quot;/&gt;
&lt;/f:radioGroup&gt;
    </pre></div>
  
  
<p>
    The group is defined by two <code>&lt;f:radio&gt;</code> tags in the body of
    a <code>&lt;f:radioGroup&gt;</code> tag. New is the
    <code>&lt;f:componentHandler&gt;</code> tag which installs a custom component
    handler for the radio group. The following listing shows the implementation
    of the <code>BooleanRadioButtonHandler</code> class:
  </p>
    
<div class="source">
<pre>
package net.sf.jguiraffe.examples.tutorial.viewset;

import net.sf.jguiraffe.gui.builder.components.model.AbstractRadioButtonHandler;

public class BooleanRadioButtonHandler extends AbstractRadioButtonHandler&lt;Boolean&gt;
{
    /** Constant for the index of the YES button.*/
    private static final int IDX_YES = 0;

    /** Constant for the index of the NO button.*/
    private static final int IDX_NO = 1;

    /**
     * Creates a new instance of {@code BooleanRadioButtonHandler}
     */
    public BooleanRadioButtonHandler()
    {
        super(Boolean.TYPE);
    }

    /**
     * Returns the index of the button with the specified value.
     *
     * @param value the data value of the radio group
     * @return the index of the selected radio button
     */
    @Override
    protected int getButtonIndex(Boolean value)
    {
        return value.booleanValue() ? IDX_YES : IDX_NO;
    }

    /**
     * Returns the value of the radio button with the specified index.
     *
     * @param idx the index of the selected radio button
     * @return the corresponding value for the whole radio group
     */
    @Override
    protected Boolean getDataForButton(int idx)
    {
        return idx == IDX_YES;
    }
}
    </pre></div>
  
<p>
    The two methods <code>getButtonIndex()</code> and <code>getDataForButton()</code>
    perform the mapping between the index of the selected radio button and the
    data to be stored for the group. They are called by the base class when
    this information is needed. Here the index of the &quot;Yes&quot; button is
    mapped to the boolean value <b>true</b> and the index of the &quot;No&quot;
    button is mapped to <b>false</b> (and vice versa). More complex mappings
    can be done analogously. For instance, the index of the selected button
    could be mapped to an enumeration value.
  </p>
  
<p>
    As was stated before, single radio buttons are not added as fields to the
    current form per default. If this is desired, the <code>noField</code>
    attribute must be set to <b>false</b> explicitly.
  </p>
  
<p>
    One final note: So far validators were only mentioned in the context of text
    input fields. However, there is no reason why they cannot be applied to
    other input elements like radio groups as well. One use case would be to add
    a required validator to a radio group. This would ensure that the user has
    to select a button.
  </p>
  
<p>
    <a name="lists_combos"></a><b>Lists and combo boxes</b>
  </p>
  
<p>
    List boxes and combo boxes allow the user to select items from a given
    number of options. They are somewhat similar to a group of radio buttons,
    but typically they are used if there are more options available than would
    be suitable for a group of radio buttons. Apart from their visual
    representation list boxes and combo boxes have many things in common. In
    the <i>JGUIraffe</i> library they both use the same underlying data model:
    an object implementing the
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/components/model/ListModel.html">
    ListModel</a></code> interface.
  </p>
  
<p>
    <code>ListModel</code> plays a similar role
    as the <code>javax.swing.ListModel</code> interface for Swing applications.
    It is not a complicated interface. It provides methods for querying the
    number of elements contained in the model and for querying the elements
    themselves - as value objects and as display objects. When a list or combo
    box is rendered the display objects returned by the model are used. When
    the data of such an input element is queried the data object is returned.
    Thus the items rendered on the screen can differ from the data that is
    actually stored for the input element. Refer to the Javadocs of the
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/components/model/ListModel.html">
    ListModel</a></code> interface for a more detailed explanation.
  </p>
  
<p>
    The component builder tag library defines the tags <code>&lt;f:list&gt;</code>
    and <code>&lt;f:combo&gt;</code> for the definition of list boxes and combo
    boxes. They are implemented by the classes
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/components/tags/ListBoxTag.html">
    ListBoxTag</a></code> and
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/components/tags/ComboBoxTag.html">
    ComboBoxTag</a></code>. Both tags require that the list model with the items
    to be displayed is set. The following options exist:
    </p>
<ul>
    
<li>The <code>modelRef</code> attribute can be set to the name of a bean
    implementing the <code>ListModel</code> interface. This bean is looked up in
    the current <code>BeanContext</code>; so it may have been created for
    instance by a <code>&lt;di:bean&gt;</code> tag in the same builder script or
    passed to the builder in form of a builder property.</li>
    
<li>Alternatively a specialized tag in the body of the
    <code>&lt;f:list&gt;</code> or  <code>&lt;f:combo&gt;</code> tag can define
    the list model. We will see which tags exist for this purpose in a moment.</li>
    </ul>
  
  
<p>
    Let's start with an example of the first option where the model is obtained
    from the current bean context. The example is about a file browser
    application. This application has a combo box that lists the root file
    systems available on the local machine (e.g. the existing drive letters on
    a windows system). The user can select a root file system whose content
    will then be displayed by the application. The fragment of the builder
    script that defines the combo box and its model looks as follows:
  </p>
    
<div class="source">
<pre>
&lt;di:bean name=&quot;fileSystemModel&quot;
  beanClass=&quot;net.sf.jguiraffe.examples.tutorial.mainwnd.FileSystemListModel&quot;&gt;
&lt;/di:bean&gt;

&lt;f:combo name=&quot;comboFS&quot; modelRef=&quot;fileSystemModel&quot; editable=&quot;false&quot;/&gt;
    </pre></div>
  
<p>
    Here first a bean for the model is defined. Later on the model bean is
    referenced by the <code>&lt;f:combo&gt;</code> tag. Because the user can
    only select an existing item and cannot enter arbitrary text into the
    combo box's text field the <code>editable</code> attribute is set to
    <b>false</b>. If a list was to be used rather than a combo box, the
    declaration would be very similar: the <code>&lt;f:combo&gt;</code> tag would be
    replaced by a <code>&lt;f:list&gt;</code> tag. The <code>editable</code>
    attribute would be dropped because lists are per se not editable:
  </p>
    
<div class="source">
<pre>
&lt;f:list name=&quot;listFS&quot; modelRef=&quot;fileSystemModel&quot;/&gt;
    </pre></div>
  
<p>
    The implementation of the <code>FileSystemListModel</code> class
    representing the model of the combo box is shown below:
  </p>
    
<div class="source">
<pre>
package net.sf.jguiraffe.examples.tutorial.mainwnd;

import java.io.File;

import net.sf.jguiraffe.gui.builder.components.model.ListModel;

public class FileSystemListModel implements ListModel
{
    /** Stores the available root objects. */
    private final File[] roots;

    public FileSystemListModel()
    {
        roots = File.listRoots();
    }

    /**
     * Returns the display object at the given index. This implementation
     * returns the name of the {@code java.io.File} representing the file system
     * root at the given index.
     *
     * @param index the index
     * @return the display object for this model element
     */
    @Override
    public Object getDisplayObject(int index)
    {
        return roots[index].getPath();
    }

    /**
     * Returns the data type of the model elements. For this model
     * implementation {@code java.io.File} is the data type.
     *
     * @return the data type of this model
     */
    @Override
    public Class&lt;?&gt; getType()
    {
        return File.class;
    }

    /**
     * Returns the value object at the given index. This implementation returns
     * the {@code java.io.File} object representing the file system root at the
     * given index.
     *
     * @param index the index
     * @return the value object at this index
     */
    @Override
    public Object getValueObject(int index)
    {
        return roots[index];
    }

    /**
     * Returns the size of this model.
     *
     * @return the size of this model
     */
    @Override
    public int size()
    {
        return roots.length;
    }
}
    </pre></div>
  
<p>
    This implementation is not too complicated. The actual data the model
    operates on is already obtained in the constructor by calling
    <code>File.listRoots();</code>. The other methods mainly access the array
    returned by this operation. <code>getDisplayObject()</code> returns a
    string, namely the path of the <code>File</code> object representing a root
    file system. <code>getValueObject()</code> returns the <code>File</code>
    object itself. The <code>ComponentHandler</code> implementation of the
    combo box calls <code>getValueObject()</code> for the selected item and
    stores the result in the form's model. Therefore the data type of this
    model is <code>java.io.File</code>.
  </p>
  
<p>
    The other option to define the list model is to use special tags that are
    able to create a list model and to assign it to an enclosing
    <code>&lt;f:list&gt;</code> or <code>&lt;f:combo&gt;</code> tag. Currently
    the component builder tag library supports the
    <code>&lt;f:textListModel&gt;</code> tag which is implemented by the
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/components/tags/TextListModelTag.html">
    TextListModelTag</a></code> class. As the name implies, this tag creates a
    simple text-based model. The model's content is defined by nested
    <code>&lt;f:listModelItem&gt;</code> tags. Here the implementing tag handler
    class is
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/components/tags/ListModelItemTag.html">
    ListModelItemTag</a></code>. In the body of a <code>&lt;f:textListModel&gt;</code>
    tag an arbitrary number of <code>&lt;f:listModelItem&gt;</code> tags can be
    placed. Each tag defines one item of the list model. Both the display text
    and the value object of the item can be defined. The Javadocs of the
    <code>ListModelItemTag</code> class describe all options available. The
    following fragment shows the definition of such a list model:
  </p>
    
<div class="source">
<pre>
&lt;f:list name=&quot;fileTypes&quot; multi=&quot;true&quot;&gt;
  &lt;f:textListModel type=&quot;java.lang.String&quot;&gt;
    &lt;f:listModelItem text=&quot;*.exe&quot; value=&quot;exe&quot;/&gt;
    &lt;f:listModelItem text=&quot;*.txt&quot; value=&quot;txt&quot;/&gt;
    &lt;f:listModelItem text=&quot;*.java&quot; value=&quot;java&quot;/&gt;
    &lt;f:listModelItem text=&quot;*.scala&quot; value=&quot;scala&quot;/&gt;
    &lt;f:listModelItem text=&quot;*.xml&quot; value=&quot;xml&quot;/&gt;
    &lt;f:listModelItem text=&quot;*.jelly&quot; value=&quot;jelly&quot;/&gt;
    &lt;f:listModelItem text=&quot;*.html&quot; value=&quot;html&quot;/&gt;
  &lt;/f:textListModel&gt;
&lt;/f:list&gt;
    </pre></div>
  
<p>
    In this example a list is defined that allows the user to select multiple
    file types. The <code>&lt;f:listModelItem&gt;</code> tags define the items
    to be displayed in the list using the <code>text</code> attribute. In this
    case the values are strings, too. They could have been other objects as well
    - their data type must correspond to the <code>type</code> attribute of the
    <code>&lt;f:textListModel&gt;</code> tag. This approach - the definition of
    a list model directly in the builder script - can be used if the number of
    list items is fix and known beforehand. Otherwise, it is preferrable to
    create a specialized list model class as demonstrated in the previous
    examples.
  </p>
  
<p>
    The last example also demonstrates the <code>multi</code> attribute of the
    <code>&lt;f:list&gt;</code> tag. A value of <b>true</b> means that the user
    can select multiple list elements; otherwise the list allows only a single
    selection. The <code>multi</code> attribute influences the data stored in
    the form model for the list: if the list supports only single selection,
    the form model stores a single object of the data type of the list's model.
    In multi-selection mode an array of this data type is stored. So for the
    example above with the file types, the form model would have stored an
    array of strings for the list.
  </p>
  
<p>
    <a name="progressbars"></a><b>Progressbars</b>
  </p>
  
<p>
    A progress bar is typically used to give feedback to the user about a longer
    running operation. Usually they are not used in forms for entering data.
    Nevertheless the component builder tag library supports these components
    with the <code>&lt;f:progressbar&gt;</code> tag which is implemented by the
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/components/tags/ProgressBarTag.html">
    ProgressBarTag</a></code> class.
  </p>
  
<p>
    When a progress bar is defined the following properties can be set:
    </p>
<ul>
    
<li>The minimum value of the progress bar (0 per default).</li>
    
<li>The maximum value of the progress bar (100 per default).</li>
    
<li>The current value. This value must be between the minimum and the
    maximum. It determines the progress already made.</li>
    
<li>A text to be displayed for the progress bar. This text is displayed on
    top of the graphical progress bar. It can either be defined directly or via
    a resource ID.</li>
    </ul>
    The following fragment from a builder script shows an example:
  
    
<div class="source">
<pre>
&lt;f:progressbar name=&quot;progress&quot; text=&quot;progress&quot; min=&quot;1&quot; max=&quot;200&quot;
  allowText=&quot;true&quot;/&gt;
    </pre></div>
  
<p>
    A progress bar makes only sense if it can be updated at runtime during a
    long-running operation. To do this in a convenient way there is a specific
    <code>ComponentHandler</code> implementation for progress bars:
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/components/model/ProgressBarHandler.html">
    ProgressBarHandler</a></code>. This handler implementation allows setting
    the progress bar's current value and text directly. From a
    <code>FormController</code> implementation a progress bar could be
    manipulated as follows:
  </p>
    
<div class="source">
<pre>
ProgressBarHandler handler = (ProgressBarHandler)
  getComponentBuilderData().getComponentHandler(&quot;progress&quot;);
handler.setValue(counter++);
    </pre></div>
  
<p>
    Here we assume that this code snippet is executed repeatedly during a
    long-running operation. Each time it is executed another step of the
    operation is completed, so a counter is incremented. The value of the
    progress bar is set to this counter value. When the operation is finished
    the maximum of the progress bar should be reached. Note that for a progress
    bar per default no field is added to the current form. If this is desired,
    the <code>noField</code> attribute of the <code>&lt;f:progressbar&gt;</code>
    tag must be set to <b>false</b> explicitly. In this case the progress bar's
    value is stored in the form's model as an integer number.
  </p>
  
<p>
    <a name="sliders"></a><b>Sliders</b>
  </p>
  
<p>
    A slider allows the user to enter a numeric value in a given range. The user
    just drags the marker of the slider to the position that corresponds to the
    desired value. The value is stored in the model of the form as an integer
    value. There are some similarities between sliders and
    <a href="progressbars">progress bars</a>; both are initialized with a range
    of allowed values and display a current value. In contrast to a progress bar
    a slider allows the user to enter a value; hence it is a full-featured input
    component.
  </p>
  
<p>
    Sliders are defined using the <code>&lt;f:slider&gt;</code> tag which is
    implemented by the
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/components/tags/SliderTag.html">
    SliderTag</a></code> class. The tag supports attributes for setting the
    following properties:
    </p>
<ul>
    
<li>The minimum value of the slider. This is a required attribute.</li>
    
<li>The maximum value of the slider which is also required.</li>
    
<li>The spacing of ticks. A slider component can draw a line chart
    that displays the positions of the values. This makes it easier for the user
    to find the drag position that corresponds to a certain value. The tick
    spacing defines the distance between the lines in the line chart. The
    developer can define a major tick spacing and a minor tick spacing. For
    instance, the major tick spacing could be set to 10, and the minor tick
    spacing could be set to 5. This means that every 10 value units a thick
    line is drawn and every 5 units a thin line.</li>
    
<li>A flag whether ticks should be drawn. If set to <b>true</b>, the tick
    spacing should be defined, too.</li>
    
<li>A flag whether labels corresponding to the values should be drawn. If
    this flag is <b>true</b>, the slider components displays standard labels at
    the positions that correspond to major tick values.</li>
    </ul>
    The following snippet shows how a slider component can be defined:
  
    
<div class="source">
<pre>
&lt;f:slider name=&quot;duration&quot; min=&quot;0&quot; max=&quot;30&quot; minorTicks=&quot;5&quot; majorTicks=&quot;10&quot;
  showTicks=&quot;true&quot; showLabels=&quot;true&quot; tooltipres=&quot;bgtask_duration_tip&quot;&gt;
    </pre></div>
  
<p>
    The following figure shows a dialog with a slider that corresponds to this
    definition:
  </p>
  <img src="../images/userguide/Slider.png" alt="Slider example" />
  
<p>
    <a name="tabs"></a><b>Tabbed panes</b>
  </p>
  
<p>
    Sometimes a single dialog should be used to let the user enter data related
    to several subtopics. An example could be the settings dialog of an
    application: There may be different areas with specific settings, e.g.
    general settings, security settings, directory settings, database settings,
    and so on. Rather than having a single dialog for each settings category,
    it may be more comfortable for the user to have a central settings dialog
    which allows navigating to the settings categories available. One way to
    achieve this is using a tabbed pane: The central settings dialog can define
    tabs for each category of settings. By clicking one of these tabs the
    corresponding page with settings is displayed.
  </p>
  
<p>
    The component builder tag library provides the
    <code>&lt;f:tabbedpane&gt;</code> tag to define a dialog with multiple tabs.
    <code>&lt;f:tabbedpane&gt;</code> is implemented by the
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/components/tags/TabbedPaneTag.html">
    TabbedPaneTag</a></code> class. This tag defines a frame in which single tabs can
    be embedded. Tabs are defined using nested <code>&lt;f:tab&gt;</code> tags.
    Here the implementation class is
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/components/tags/TabTag.html">
    TabTag</a></code>. The following fragment of a builder script shows an
    example:
  </p>
    
<div class="source">
<pre>
&lt;f:tabbedpane name=&quot;tabs&quot; placement=&quot;bottom&quot;&gt;
  &lt;f:tab titleres=&quot;viewset_tab_colors&quot;&gt;
    &lt;f:panel&gt;
      ...
    &lt;/f:panel&gt;
  &lt;/f:tab&gt;

  &lt;f:tab titleres=&quot;viewset_tab_sort&quot;&gt;
    &lt;f:panel&gt;
      ...
    &lt;/f:panel&gt;
   &lt;/f:tab&gt;

  &lt;f:tab titleres=&quot;viewset_tab_filters&quot;&gt;
    &lt;f:panel&gt;
      ...
    &lt;/f:panel&gt;
  &lt;/f:tab&gt;
&lt;/f:tabbedpane&gt;
    </pre></div>
  
<p>
    The whole tabbed pane is defined by the enclosing
    <code>&lt;f:tabbedpane&gt;</code> tag. As an attribute the placement of the
    tabs can be specified - per default they are placed at the top of the pane.
    The tabbed pane can also be assigned a name, but this is optional.
    (Technically a tabbed pane is a regular input component and thus has a name.
    The data of this input component is the integer index of the selected tab.
    However, this information is normally not stored in the model of a form.
    Hence the <code>noField</code> attribute is set to <b>true</b> initially.
    It can be set to <b>false</b> explicitly to alter this behavior.)
  </p>
  
<p>
    In the body of the <code>&lt;f:tabbedpane&gt;</code> tag an arbitrary number
    of <code>&lt;f:tab&gt;</code> tags can occur each defining a page of the
    tabbed pane. <code>&lt;f:tab&gt;</code> supports attributes similar to a
    <a href="#labels">label</a>: It is possible to set the text of the tab
    (either directly or as a resource ID), to define an icon and a mnemonic.
  </p>
  
<p>
    The content of the tab is defined in the body of the
    <code>&lt;f:tab&gt;</code> tag. Here a single component tag can be placed.
    Because a tab represents a whole page of a dialog and is usually more
    complex typically a <code>&lt;f:panel&gt;</code> tag is used here allowing
    the definition of an arbitrary complex UI.
  </p>
  
<p>
    At runtime only a single tab is active, and the content of this active tab
    is displayed. When the user navigates to another tab, the content of the
    old active tag is made invisible, and the content of the new one appears.
  </p>
  
<p>
    <a name="buttons"></a><b>Buttons</b>
  </p>
  
<p>
    Buttons play an important role in graphical user interfaces. Their main use
    case is within dialog boxes where they allow the user to close the window
    - either the data entered by the user is to be saved or editing is canceled.
    Generally speaking, a button represents an action which is executed when the
    user presses the button. Thus buttons also appear in tool bars where they
    provide fast access to central functionality of an application.
  </p>
  
<p>
    In this sub section we focus on the definition of command buttons that can
    appear in dialog or frame windows. Tool bars will be covered when the
    <i>action builder tag library</i> is discussed. This tag library is also
    responsible for the definition of listeners to be invoked when a button is
    clicked. The component builder tag library only provides tags for defining
    buttons, but does not deal with the events generated by button clicks.
  </p>
  
<p>
    Buttons are defined using the <code>&lt;f:button&gt;</code> tag implemented
    by the <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/components/tags/ButtonTag.html">
    ButtonTag</a></code> class. When used within dialogs they are frequently
    arranged by a <i>button layout</i> (see <a href="#layouts">Layouts</a>) as
    demonstrated by the following fragment:
  </p>
    
<div class="source">
<pre>
&lt;!-- The button bar --&gt;
&lt;f:panel&gt;
  &lt;f:borderconstr name=&quot;SOUTH&quot;/&gt;
  &lt;f:buttonlayout/&gt;
  &lt;f:button name=&quot;btnOk&quot; textres=&quot;viewset_btn_save&quot;
    mnemonicres=&quot;viewset_btn_save_mnemo&quot; default=&quot;true&quot;/&gt;
  &lt;f:button name=&quot;btnCancel&quot; textres=&quot;viewset_btn_cancel&quot;
    mnemonicres=&quot;viewset_btn_cancel_mnemo&quot; cancel=&quot;true&quot;/&gt;
&lt;/f:panel&gt;
    </pre></div>
  
<p>
    Here a panel is defined acting as the button bar of a dialog window. The
    panel is placed in the south of the dialog window. It uses a button layout
    with default settings and contains two buttons: an OK and a Cancel button.
  </p>
  
<p>
    The definition of a button is very similar to the definition of a
    <a href="#labels">Label</a>. With the typical attributes the button's text,
    its mnemonic, and its alignment can be specified. With a nested
    <code>&lt;f:icon&gt;</code> tag the button can be assigned an icon. The
    <code>default</code> and <code>cancel</code> attributes are specific to
    buttons: Using these boolean attributes, one button of the window can be
    marked as the default or cancel button respective. This button can then be
    triggered when the user performs a UI-specific action (typically pressing
    <i>Enter</i> in case of the default button or <i>Escape</i> for the
    cancel button) - even if the button does not currently have the keyboard
    focus. Buttons can also be assigned a command. This is optional
    and may be of interest for event listeners registered at the button because
    the events generated by the button contain this command. But this will be
    discussed in more detail later.
  </p>
  
<p>
    Technically, buttons are input components, but they usually do not store
    data in the associated form. The <code>ButtonTag</code> class sets the
    <code>noField</code> attribute to <b>true</b> per default. Actually a button
    maintains a boolean value indicating whether the button is pressed or not.
    This is used by a special button type: a <i>toggle button</i>. Unlike a
    command button a toggle button typically does not trigger an action. Rather,
    if pressed by the user, it stays pressed until it is clicked again. This is
    semantically equivalent to a checkbox. For the definition of toggle buttons
    the component builder tag library provides the
    <code>&lt;f:toggleButton&gt;</code> tag implemented by the
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/components/tags/ToggleButtonTag.html">
    ToggleButtonTag</a></code> class. <code>&lt;f:toggleButton&gt;</code> has
    the same attributes as <code>&lt;f:button&gt;</code> (except for the
    <code>default</code> attribute which is specific to command buttons). For
    the produced toggle button input components fields of type boolean are added
    to the associated form. The following snippet shows the definition of a
    toggle button:
  </p>
    
<div class="source">
<pre>
&lt;f:toggleButton name=&quot;toggle&quot; text=&quot;Toggle&quot; command=&quot;tog&quot;/&gt;
    </pre></div>
  
<p>
    As was already pointed out, the reaction of button clicks is subject of a
    later section. Here we just want to mention that
    <a href="formcontroller.html">Form controllers</a> provide automatic support
    for buttons that save or cancel a form: The <code>FormController</code>
    class has the properties <code>btnOkName</code> and
    <code>btnCancelName</code>. Here the names of the OK and the Cancel button
    can be provided. The controller then registers itself as event listener at
    these buttons and handles their events appropriately. This will be discussed
    in more detail in the section about windows.
  </p>
  
<p>
    <a name="splitters"></a><b>Splitters</b>
  </p>
  
<p>
    Sometimes it is necessary to divide the space available in a window on
    multiple components. Examples include a mail application showing a list of
    received mails in the top and the text of the currently selected mail in the
    bottom, or a directory browser application that displays a directory tree in
    the left and the content of the current directory in the right. Because the
    application does not how much space the user prefers for the single
    components it typically provides a bar which can be dragged to adopt the
    sizing of the components. This is what splitters are for.
  </p>
  
<p>
    In <i>JGUIraffe</i> applications a splitter can be added to a container
    component, e.g. a window (acting as top-level container) or a panel. It
    splits the space available either horizontally or vertically and provides it
    to exactly two subcomponents. The subcomponents can again be containers like
    panels with an arbitrary number of nested elements. It is even possible to
    nest splitter components to an arbitrary depth. While up to three nested
    splitters probably make sense (for instance a tree structure with mail
    folders on the left, a list with the mails received in the top, and the
    content of the selected mail in the bottom), the user should not be confused
    with too many nested splitters. The following code fragment shows a
    declaration of a user interface that works with splitters:
  </p>
    
<div class="source">
<pre>
&lt;f:splitter pos=&quot;50&quot; size=&quot;10&quot; resizeWeight=&quot;0.5&quot;&gt;
  &lt;f:panel&gt;
    &lt;!-- Content of the panel in the left --&gt;
    ...
  &lt;/f:panel&gt;
  &lt;f:splitter pos=&quot;25&quot; orientation=&quot;horizontal&quot; resizeWeight=&quot;1&quot;&gt;
    &lt;f:panel&gt;
      &lt;!-- Content of the panel in the top --&gt;
      ...
    &lt;/f:panel&gt;
    &lt;f:panel&gt;
      &lt;!-- Content of the panel in the bottom --&gt;
      ...
    &lt;/f:panel&gt;
  &lt;/f:splitter&gt;
&lt;/f:splitter&gt;
    </pre></div>
  
<p>
    This examples skips the actual content of the panels comprising the UI, but
    it demonstrates all configuration options for splitter components. As shown
    in the code fragment above, splitters are defined using the
    <code>&lt;f:splitter&gt;</code> tag which is implemented by the
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/components/tags/SplitterTag.html">
    SplitterTag</a></code> class. Because splitters
    are no input components - no data is stored for them in the model of the
    current form - they do not require a <code>name</code> attribute. In
    addition to the standard attributes supported by all graphical components
    the following properties of a splitter can be configured:
    </p>
<ul>
    
<li>The <i>orientation</i> of the splitter. This attribute determines whether
    the splitter splits the available space into an upper and a lower component - if
    the value is <i>VERTICAL</i> (which is the default) - or into a left and a
    right component - if the orientation is <i>HORIZONTAL</i>. (Note: The
    orientation is derived from the arrangement of the components managed by
    the splitter. For instance, in <i>horizontal</i> mode, the components are
    aligned horizontally while the splitter itself is a vertical bar. This may
    be a bit confusing.)</li>
    
<li>The <i>size</i> of the splitter can be specified. The splitter is
    displayed as a line between the components it separates. With this attribute
    the thickness of this line can be defined.</li>
    
<li>For the splitter an initial <i>position</i> (in pixels) can be
    specified. When the UI is initialized, the splitter is moved to this
    position. Using this attribute is a bit fragile due to different font sizes
    and screen resolutions. It is probably better to define the UI in a way that
    the components separated by the splitter can have their preferred sizes - if
    not specified otherwise, the sizes of the components determine the initial
    position of the splitter.</li>
    
<li>The behavior of the splitter when the size of the owning window changes
    can be specified as a so-called <i>resize weight</i>. This is a floating
    point number between 0 and 1 that controls how additional space is to be
    distributed between the two components managed by the splitter. A value of
    0 means that all space is assigned to the first component (the left or the
    top component, depending on the splitter's orientation). A value of 1 causes
    all space to be assigned to the second component. A value of 0.5 will
    distribute the available space homogeneously between both components. Values
    less than 0.5 prefer the first component over the second one and vice versa.
    </li>
    </ul>
    As can be seen, the components to be managed by the splitter are just placed
    in the body of the tag. They are evaluated in the order of their appearance.
    There must be exactly two components, otherwise the processing of the
    <code>&lt;f:splitter&gt;</code> tag will throw an exception.
  
  
<p>
    Splitters use the minimum size of the components they divide to determine
    constraints for their sizing. If a component already has its minimum size,
    the splitter cannot be dragged any further. This is a caveat, especially
    when working with <a href="#layouts">percent layout managers</a>. If not
    specified otherwise, the preferred size of a panel using percent layout is
    also its minimum size. So if two such panels are to be split, after they
    have been initially layouted (and set to their preferred size), the splitter
    cannot be moved! Both components have already reached their minimum.
    Fortunately, the solution is easy: Just make sure that the
    <code>canShrink</code> property of the percent layouts involved is set to
    <b>true</b>. In this case, the minimum size of the panels can be smaller
    than the preferred size. It is then possible to drag the splitter, at least
    until a &quot;hard&quot; limit is reached, e.g. the minimum size of a label.
  </p>
  
<p>
    <a name="trees"></a><b>Trees</b>
  </p>
  
<p>
    Tree views are useful if any kind of hierarchical data is to be presented to
    the user, for instance a file system, a package structure, or the table of
    contents of a book. The model associated with the tree view must be capable
    of storing hierarchical data of these types. Popular UI libraries typically
    implement their own hierarchical data structure serving as a tree component's
    data model. Swing, for instance, uses the <code>javax.swing.tree.TreeModel</code>
    interface to define a hierarchical nodes structure. With the
    <code>javax.swing.tree.DefaultTreeModel</code> class a default implementation
    of this interface is available.
  </p>
  
<p>
    The <i>JGUIraffe</i> library takes a slightly different approach: Rather
    than defining another proprietary hierarchical data structure, the library
    makes use of an already existing one: the <code>HierarchicalConfiguration</code>
    class from the <a class="externalLink" href="http://commons.apache.org/configuration">Apache
    Commons Configuration</a> project. Because <i>Commons Configuration</i> is
    used for the implementation of the configuration support anyway, no
    additional dependency is required. The <code>HierarchicalConfiguration</code>
    class provides a rich API for querying and manipulating its data; all these
    methods can be directly used when working with tree views in a
    <i>JGUIraffe</i> application.
  </p>
  
<p>
    In <i>Commons Configuration</i> the <code>addProperty()</code> method can
    be used to add data to a <code>HierarchicalConfiguration</code> object. This
    method expects a key string pointing out the location of the new property in
    the hierarchical data structure. The string consists of several node names
    separated by the node separator character - which is the dot (&quot;.&quot;)
    per default, but can be changed to another character if needed. That way
    nodes are added to the configuration object. The tree view produced by the
    component builder tag library displays the node structure maintained by the
    <code>HierarchicalConfiguration</code> object. The nodes can also have
    values, but these values are not displayed. They can be easily queried,
    however. This can be used for instance to associate tree nodes with
    application-specific data; an event handler reacting on a change in the
    selection of a tree view could then access this data.
  </p>
  
<p>
    To make this clearer let's have an example. Have a look at the following
    lines of code that create a <code>HierarchicalConfiguration</code> object
    and populate it with nodes representing some classes of the
    <i>JGUIraffe</i> library:
  </p>
    
<div class="source">
<pre>
HierarchicalConfiguration config = new HierarchicalConfiguration();
config.addProperty(&quot;net.sf.jguiraffe.gui.app.Application&quot;, Boolean.TRUE);
config.addProperty(&quot;net.sf.jguiraffe.gui.app.ApplicationContext&quot;, Boolean.TRUE);
config.addProperty(&quot;net.sf.jguiraffe.gui.builder.Builder&quot;, Boolean.TRUE);
config.addProperty(&quot;net.sf.jguiraffe.gui.builder.BeanBuilder&quot;, Boolean.TRUE);
config.addProperty(&quot;net.sf.jguiraffe.transform.Transformer&quot;, Boolean.TRUE);
config.addProperty(&quot;net.sf.jguiraffe.transform.Validator&quot;, Boolean.TRUE);
    </pre></div>
  
<p>
    The fully-qualified class names are used as property names. Because the dot
    is the nodes separator character, the configuration creates corresponding
    node structures. The <code>addProperty()</code> method requires a value to
    be passed for each property to be added. Here we do not care about the
    value, so we just pass <code>Boolean.TRUE</code>. If we had some data to be
    associated with the class names, we would have provided it here. If now the
    configuration object initialized this way becomes the model of a tree view,
    results will look as follows:
  </p>
  <img src="../images/userguide/TreeExample.png" alt="Tree view example" />
  
<p>
    After we have discussed the way the model of a tree view is represented by a
    <code>HierarchicalConfiguration</code> object it is time to explain how such
    components are actually created. The component builder tag library uses the
    <code>&lt;f:tree&gt;</code> tag for this purpose which is implemented by the
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/components/tags/TreeTag.html">
    TreeTag</a></code> class. The tag supports a set of attributes for adjusting
    the resulting tree's appearance and behavior. Also the model of the tree
    must be specified through the <code>model</code> attribute. The following
    fragment from a builder script shows an example:
  </p>
    
<div class="source">
<pre>
&lt;f:tree name=&quot;myTree&quot; model=&quot;treeModel&quot; editable=&quot;false&quot; rootVisible=&quot;true&quot;
  multiSelection=&quot;false&quot;&gt;
&lt;/f:tree&gt;
    </pre></div>
  
<p>
    The <code>model</code> attribute is mandatory. The string provided here is
    passed to the <a href="dibuilder.html">dependency injection framework</a> to
    be resolved; it must refer to a bean of class
    <code>HierarchicalConfiguration</code>. It is up to a concrete application
    how this bean is created. One way would be to use the tags of the dependency
    injection tag library for this purpose. You can also create the
    configuration programmatically and put the object into the properties of a
    <code>BuilderData</code> object before you invoke the builder. This looks as
    follows:
  </p>
    
<div class="source">
<pre>
ApplicationBuilderData builderData = application
        .getApplicationContext().initBuilderData();
HierarchicalConfiguration config = new HierarchicalConfiguration();
// populate the configuration
...
// add the object to the properties for the builder
builderData.addProperty(&quot;treeModel&quot;, config);

// invoke the builder
Window window = builder.buildWindow(locator, builderData);
    </pre></div>
  
<p>
    Because a tree view is a more complex component the simple
    <code>ComponentHandler</code> interface is not sufficient to use all the
    features supported. Therefore, with the
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/components/model/TreeHandler.html">
    TreeHandler</a></code> interface a specialized handler interface exists.
    <code>TreeHandler</code> provides methods for accessing specific properties
    of a tree and for manipulating its state and appearance. Using these methods
    the developer can
    </p>
<ul>
    
<li>collapse or expand specific nodes of the tree</li>
    
<li>query or set the currently selected node(s)</li>
    
<li>obtain the model of the tree</li>
    
<li>register special event handlers for trees.</li>
    </ul>
  
  
<p>
    A specific node in the model of the tree view is represented by the
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/components/model/TreeNodePath.html">
    TreeNodePath</a></code> class. This class collaborates closely with a
    <code>HierarchicalConfiguration</code> object. It stores the configuration
    nodes on a path from the root node to a certain target node. It has methods
    to query the nodes on the path and supports transforming the whole path to a
    corresponding configuration key - this is especially useful if the data
    stored in the configuration for this tree node is required.
  </p>
  
<p>
    In many use cases trees are not used in forms to enter user data. Because of
    this, the data of a tree view component is per default not stored in the
    form's data; i.e. the <code>noField</code> attribute is initialized with
    <b>true</b>. This can be changed by manually setting the attribute to
    <b>false</b>. In this case the data stored for the tree view depends on the
    multi-selection property: If the tree supports only single selection (this
    means that only a single node can be selected at once), its data consists of
    a single <code>TreeNodePath</code> object. Otherwise, an array of
    <code>TreeNodePath</code> is stored.
  </p>
  
<p>
    Often it is required to use special icons for the nodes of a tree view. If
    not specified otherwise, the tree view uses a default icon for leaf nodes
    and another one for non-leaf nodes. <i>JGUIraffe</i> provides the
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/components/tags/TreeIconHandler.html">
    TreeIconHandler</a></code> interface which allows full control over the icons
    to be displayed. The basic idea is that an implementation of
    <code>TreeIconHandler</code> is specified using the <code>iconHandler</code>
    attribute of the <code>&lt;f:tree&gt;</code> tag (a bean with this name is
    looked up in the current bean context). The icon handler is passed the
    information available for the current node and returns the name of an icon
    to be displayed for it. The icons themselves must have been provided to the
    tree view using nested <code>&lt;f:treeIcon&gt;</code> tags (refer to the
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/components/tags/TreeIconTag.html">
    TreeIconTag</a></code> class). An example of using this tag is shown below:
  </p>
    
<div class="source">
<pre>
&lt;f:tree model=&quot;myTreeModel&quot; name=&quot;myTree&quot;&gt;
   &lt;f:treeIcon name=&quot;LEAF&quot;&gt;
     &lt;f:icon resource=&quot;myLeafIcon.gif&quot;/&gt;
   &lt;/f:treeIcon&gt;
   &lt;f:treeIcon name=&quot;BRANCH_EXPANDED&quot;&gt;
     &lt;f:icon resource=&quot;myExpandedIcon.gif&quot;/&gt;
   &lt;/f:treeIcon&gt;
   &lt;f:treeIcon name=&quot;BRANCH_COLLAPSED&quot;&gt;
     &lt;f:icon resource=&quot;myCollapsedIcon.gif&quot;/&gt;
   &lt;/f:treeIcon&gt;
 &lt;/f:tree&gt;
    </pre></div>
  
<p>
    Here the default <code>TreeIconHandler</code> implementation is used. This
    implementation supports three different icons: for leaf nodes, for collapsed
    branch nodes, and for expanded branch nodes. The <code>&lt;f:treeIcon&gt;</code>
    tags define corresponding icons for these node types. The <code>name</code>
    attributes of the tags specifies the type of node for which an icon is to be
    set. Here the default names supported by the default icon handler are used.
    If you set a custom icon handler, you are free to use whatever icon names
    you want. The only caveat is that the names provided by the
    <code>&lt;f:treeIcon&gt;</code> tags correspond to the names supported by
    the handler.
  </p>
  
<p>
    <a name="tables"></a><b>Tables</b>
  </p>
  
<p>
    Tables certainly belong to the more complex components that can be added to
    the UI of an application. They are typically used to display larger amounts
    of structured data. This makes them a bit similar to
    <a href="formbuilder.html#lists_combos">list boxes</a>, but in contrast to
    the more simple list boxes tables can display an arbitrary number of columns.
    Therefore they require a different model.
  </p>
  
<p>
    List boxes obtain the data to be displayed from an object implementing the
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/components/model/ListModel.html">
    ListModel</a></code> interface. This interface allows access to a value and
    a display object for each element of the list. This information is
    sufficient for a list box control to render itself and to maintain its data.
    For a table situation is more complex because the data to be displayed in
    the single columns is needed. This is the reason why interfaces representing
    models for tables typically have a bunch of methods. For instance, Swing's
    <code>javax.swing.table.TableModel</code> interface defines methods for
    querying data of the different cells of the table.
  </p>
  
<p>
    <i>JGUIraffe</i> takes a different approach. In fact, the table models
    used here are even simpler than list models: they are simple collections
    with Java beans. The <i>JGUIraffe</i> table implementation borrows some
    features from the implementation of <a href="forms.html">Forms</a>,
    especially the mechanism for accessing properties of the form's model- which
    typically is a Java bean - and binding their values to UI components. In
    the case of tables the properties of the Java objects stored in the model
    collection are mapped to the columns of the table. This makes it very easy
    to display the data an application is processing because in most cases no
    conversion to specialized model objects is necessary: Typically application
    data is available in collections of data objects anyway, e.g. as a list
    with entity objects representing the result of a database query. Such a list
    can directly be used as the model of a table.
  </p>
  
<p>
    For the definition of tables the component builder tag library provides the
    <code>&lt;f:table&gt;</code> tag which is implemented by the
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/components/tags/table/TableTag.html">
    TableTag</a></code> class. The columns of the table are defined by nested
    <code>&lt;f:column&gt;</code> tags (here the implementation class is
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/components/tags/table/TableColumnTag.html">
    TableColumnTag</a></code>). The following example fragment from a builder
    script shows how a simple (read-only) table can be declared:
  </p>
    
<div class="source">
<pre>
&lt;f:table model=&quot;tabModel&quot; selectionBackground=&quot;blue&quot;
  selectionForeground=&quot;white&quot; name=&quot;testTable&quot;&gt;
  &lt;f:column name=&quot;icon&quot; width=&quot;20px&quot; columnClass=&quot;Icon&quot;/&gt;
  &lt;f:column name=&quot;firstName&quot; percentWidth=&quot;35&quot; headerres=&quot;TABLE_COL_FIRSTNAME&quot;/&gt;
  &lt;f:column name=&quot;lastName&quot; columnClass=&quot;String&quot; percentWidth=&quot;40&quot;
    headerres=&quot;TABLE_COL_LASTNAME&quot;/&gt;
  &lt;f:column name=&quot;birthDate&quot; columnClass=&quot;DATE&quot; percentWidth=&quot;25&quot;
    headerres=&quot;TABLE_COL_BIRTHDATE&quot;/&gt;
&lt;/f:table&gt;
    </pre></div>
  
<p>
    This script generates a table with four columns: an icon, first name, last
    name, and birth date. While the reference of all attributes supported by
    the tags is available in the Javadocs, we want to highlight some points:
    </p>
<ul>
    
<li>Probably the most important attribute of the <code>&lt;f:table&gt;</code>
    tag is the reference to the table's model. A bean with the name specified
    here is looked up in the current bean context. It must be a collection.</li>
    
<li>In addition to the standard attributes supported by all input
    components the <code>&lt;f:table&gt;</code> tag provides some specific
    attributes for setting further properties of the table, e.g. the colors of
    the selection.</li>
    
<li>Each <code>&lt;f:column&gt;</code> tag defines a column of the table.
    The <code>name</code> attribute of the tag corresponds to the property of
    the beans in the table's model that is read for rendering this column. In
    the example above we deal with beans representing persons. Because there is
    a column named <i>firstName</i> the objects in the table's model must have
    a property named <i>firstName</i>, too - which means there has to be a
    public method with the name <code>getFirstName()</code> and no arguments
    that returns the data to be displayed in this column. Note that the actual
    class of the objects in the model does not matter; access to the data is
    done purely through the names of the properties.</li>
    
<li>Every column can have a header text (which is independent from the
    column's name). For defining the header text there are similar options as
    for <a href="#labels">Labels</a>: the text can be set directly or by
    specifying a resource ID.</li>
    
<li>With the <code>columnClass</code> attribute information about the type of data to
    be displayed in that column can be provided. This gives a hint to the
    underlying table implementation how to render the data in that column. For
    instance, the <i>icon</i> column has set its type to <code>ICON</code> to
    ensure that an image is painted. Defining the column class is optional,
    but it is recommended to make sure that the table actually displays the data
    as expected. The following options are available:
      
<ul>
      
<li>The component builder tag library provides the
      <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/components/tags/table/ColumnClass.html">
      ColumnClass</a></code> enumeration class which defines a number of logic
      column types. Using the constants defined by this class is the most
      portable way of specifying a column class because <i>JGUIraffe</i> maps
      these types to the renderes supported by the underlying UI toolkit.</li>
      
<li>It is also possible to use a Java class as column class. In this case,
      the class is just passed to the underlying UI toolkit which must be able
      to handle it. For instance, Swing has built-in support for rendering a
      set of data classes.</li>
      </ul>
    If no <code>columnClass</code> attribute is provided, a generic renderer is
    used for this column.</li>
    
<li>An important point for a good-looking table are well-defined column
    widths. The <code>&lt;f:column&gt;</code> tag supports both fixed and
    relative column widths. A fixed width is specified using the
    <code>width</code> attribute. Here a string compatible with the
    <code><a href="../apidocs/net/sf/jguiraffe/gui/layout/NumberWithUnit.html">
    NumberWithUnit</a></code> class can be provided. Such columns keep their
    width when the table is resized. Of course, the user can manually drag the
    columns' margins to change their size. With the <code>percentWidth</code>
    attribute a relative width can be set. When calculating the widths for the
    columns the total width of the table is determined, then the sizes of
    columns with a fixed width are subtracted. The remaining size is distributed
    to the columns with a relative width according to their percental ratio.
    Note that a table with at least one column with relative width always
    adjusts the size of its columns to fit into the available space. This is
    not the case for tables with only fixed-width columns: here the table can
    become wider or smaller than the space available. Columns with no width
    specification are assigned a relative width. The example script demonstrates
    a typical pattern for setting the column widths: Most data columns are
    assigned a relative width according to the size of the information they have
    to display. A fixed width is used only for special columns like the icon
    column.</li>
    </ul>
  
  
<p>
    Typically tables are used to display - and optionally edit - the data stored
    in its model. They do not store data themselves in the model of the current
    form. This can be changed by setting the <code>noField</code> attribute of
    the <code>&lt;f:table&gt;</code> tag explicitly to <b>false</b>. In this
    case the data stored by the table in the form's model depends on its
    selection model: If single selection is set, the index of the selected row
    is stored as an integer. Tables with multiple selection mode enabled (this
    can be achieved by setting the <code>multiSelection</code> attribute to
    <b>true</b>) store an array of integers for the indices of all selected
    rows.
  </p>
  
<p>
    Tables provide some specific functionality which cannot be accessed through
    the <code>ComponentHandler</code> interface. Therefore with
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/components/model/TableHandler.html">
    TableHandler</a></code> a specialized handler interface exists. This
    interface provides methods for querying and setting the table's selection,
    for accessing additional properties, and to notify the table about changes
    in its data model. This is important for making changes in the data model
    visable. Because the model of a table is a plain collection the table cannot
    figure out if an external component manipulates this data. It lies in the
    responsibility of the developer to pass notifications to the table by
    calling any of the corresponding methods (<code>rowsInserted(),
    rowsUpdated(), rowsDeleted(), tableDataChanged()</code>) provided by the
    handler interface. Among those methods <code>tableDataChanged()</code> is
    the most generic one. It causes an update of the whole table. The other
    methods are more specific - if you know exactly what has changed, it is more
    efficient to use them because then only the relevant parts of the table need
    to be updated.
  </p>
  
<p>
    If not specified otherwise, tables are read-only. This can be changed by
    setting the <code>editable</code> attribute of the <code>&lt;f:table&gt;</code>
    tag to <b>true</b>. In this case default editors are enabled for all
    columns of the table; the editors used depend on the data type of the
    associated columns. It is also possible to override the <i>editable</i>
    flag for specific columns. The <code>&lt;f:column&gt;</code> tag also
    supports an <code>editable</code> attribute. The default value of this
    attribute is the value of the <code>editable</code> attribute of the
    enclosing <code>&lt;f:table&gt;</code> tag. By setting this attribute for
    single columns, it is easy to turn on editing functionality on a per column
    base.
  </p>
  
<p>
    It was already discussed how the <code>columnClass</code> attribute can be
    used to influence the renderer or editor used for a column. However,
    sometimes the default renderers available do not fulfill all the requirements
    of an application. In this case there are multiple options.
  </p>
  
<p>
    In the introduction for tables we mentioned that the columns of a table
    behave in a similar way as the
    fields of a form: they can be bound to properties of the form's model. In
    fact this similarity goes a bit further because it is also possible to
    assign <a href="validators.html">transformers or validators</a> to a
    column. These objects work exactly the same for columns as for regular
    input components in a form. When a column is rendered the corresponding
    data value is obtained from the table model, and then the write transformer
    is applied to it. When a cell is edited the read transformers and the
    validator associated with the current column are invoked. So all the
    validation logic provided for <code>Form</code> objects is available to
    tables, too. In the listing below transformers are defined for some
    columns of a table:
  </p>
    
<div class="source">
<pre>
&lt;f:table name=&quot;table&quot; model=&quot;tableModel&quot; multiSelection=&quot;true&quot;&gt;
  &lt;f:column name=&quot;icon&quot; width=&quot;20px&quot; columnClass=&quot;Icon&quot;/&gt;
  &lt;f:column name=&quot;name&quot; percentWidth=&quot;50&quot; headerres=&quot;main_tcol_name&quot;
    columnClass=&quot;String&quot;/&gt;
  &lt;f:column name=&quot;lastModified&quot; percentWidth=&quot;30&quot;
    headerres=&quot;main_tcol_modified&quot;&gt;
    &lt;f:transformer class=&quot;net.sf.jguiraffe.transform.DateTimeTransformer&quot;
      type=&quot;write&quot;/&gt;
  &lt;/f:column&gt;
  &lt;f:column name=&quot;size&quot; percentWidth=&quot;20&quot; headerres=&quot;main_tcol_size&quot;&gt;
    &lt;f:transformer type=&quot;write&quot;
      class=&quot;net.sf.jguiraffe.examples.tutorial.mainwnd.FileSizeTransformer&quot;/&gt;
  &lt;/f:column&gt;
&lt;/f:table&gt;
    </pre></div>
  
<p>
    In this example a table is defined that displays information about the files
    in a directory. The columns for the icon and the file name use default
    renderers. For the date column the default <code>DateTimeTransformer</code>
    provided by <i>JGUIraffe</i> is used. The column for the file size is
    assigned a custom transformer.
  </p>
  
<p>
    The component builder tag library provides some more tags that allow an even
    more powerful customization of the renderers and editors used for the cells
    of a table. These tags basically associate a column with an arbitrary
    graphical component. This component can also be a panel with multiple nested
    input components, so that actually multiple properties of the table's model
    objects can be displayed in a single column. Have a look at the following
    example:
  </p>
    
<div class="source">
<pre>
&lt;f:column name=&quot;name&quot; headerres=&quot;TABLE_COL_NAME&quot;&gt;
  &lt;f:colrenderer&gt;
    &lt;f:panel&gt;
      &lt;f:label text=&quot;First name:&quot;/&gt;
      &lt;f:statictext name=&quot;firstName&quot;/&gt;
      &lt;f:label text=&quot;Last name:&quot;/&gt;
      &lt;f:statictext name=&quot;lastName&quot;/&gt;
    &lt;/f:panel&gt;
  &lt;/f:colrenderer&gt;
  &lt;f:coleditor&gt;
    &lt;f:panel&gt;
      &lt;f:label text=&quot;First name:&quot;/&gt;
      &lt;f:textfield name=&quot;firstName&quot; maxlength=&quot;25&quot;/&gt;
      &lt;f:label text=&quot;Last name:&quot;/&gt;
      &lt;f:textfield name=&quot;lastName&quot; maxlength=&quot;25&quot;/&gt;
    &lt;/f:panel&gt;
  &lt;/f:coleditor&gt;
&lt;/f:column&gt;
    </pre></div>
  
<p>
    Here a column for the name of a person is defined which actually contains
    two sub fields: the first name and the last name. Two new tags,
    <code>&lt;f:colrenderer&gt;</code> (implemented by the
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/components/tags/table/ColumnRendererTag.html">
    ColumnRendererTag</a></code> class) and <code>&lt;f:coleditor&gt;</code>
    (implemented by the
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/components/tags/table/ColumnEditorTag.html">
    ColumnEditorTag</a></code> class) are used to define the content of the
    column. In the body of these tags an input component tag can be placed, here
    a <code>&lt;f:panel&gt;</code> tag is used which is in turn a container for
    other input component tags. The panels have labels and text fields for the
    data to be maintained. In the case of the column renderer
    <a href="#static_texts">static text components</a> are used because they are
    read-only per se. (Note that layout-related stuff was removed from the
    example to focus on the essentials; in practice a layout definition would be
    required.)
  </p>
  
<p>
    The component defined by the <code>&lt;f:colrenderer&gt;</code> tag is
    displayed per default when the table is just shown. When the user clicks
    into a cell it is replaced by the component defined by the
    <code>&lt;f:coleditor&gt;</code> tag. Sizing and layout of these components
    should be in sync to avoid disturbing effects when switching between these
    components.
  </p>
  
<p>
    <a name="converters"></a><b>Custom data type converters</b>
  </p>
  
<p>
    The tag handler class we discuss in this sub section is a bit special
    because it does not create a graphical user interface element. Rather, it
    allows the registration of custom <a href="dibuilder.html#type_converters">
    data type converters</a> which can then be used by the <i>dependency
    injection framework</i>. The reason why it is part of the component builder
    tag library and not of the dependency injection builder tag library is
    because the latter is designed to require only a
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/BeanBuilder.html">
    BeanBuilder</a></code> for the execution of scripts. However, extended
    functionality for registering converters at the execution time of scripts is
    available for
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/Builder.html">Builder
    </a></code> implementations only. <i>Note:</i> It is possible to use
    custom data type converters with a <code>BeanBuilder</code> by passing in an
    <code><a href="../apidocs/net/sf/jguiraffe/di/InvocationHelper.html">
    InvocationHelper</a></code> object which is configured accordingly. But this
    requires code to register converters at the corresponding
    <code><a href="../apidocs/net/sf/jguiraffe/di/ConversionHelper.html">
    ConversionHelper</a></code> instance. With a <code>Builder</code> object
    converters can be defined in a script in a declarative way.
  </p>
  
<p>
    As is described in the <a href="dibuilder.html#type_converters">data type
    converters</a> sub section, converters are called by the dependency injection
    framework when an object defined in a builder script (e.g. a property or
    parameter value) has to be converted to a specific target data type. For
    basic Java types standard converters are available, but when an application
    operates on beans with special data types, registering custom converters
    can simplify bean declarations and help to make builder scripts less
    verbose.
  </p>
  
<p>
    In order to use a custom data type converter, the converter class has to be
    implemented first. This means that the <code>Converter</code> interface of
    <i>Commons Beanutils</i> has to be implemented. With the converter class
    in place, registering an instance is simply a matter of placing the
    <code>&lt;f:converter&gt;</code> tag (implemented by the
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/components/tags/ConverterTag.html">
    ConverterTag</a></code> class) at the beginning of a builder script.
  </p>
  
<p>
    <code>ConverterTag</code> is derived from the
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/components/tags/UseBeanBaseTag.html">
    UseBeanBaseTag</a></code> class. Thus it provides multiple ways of defining
    the converter object. For instance, if the converter class has a default
    constructor, it can be directly created by the tag as shown in the following
    example:
  </p>
    
<div class="source">
<pre>
&lt;f:converter class=&quot;com.mypackage.convert.MyCustomConverter&quot;
  converterTargetClass=&quot;com.mypackage.model.MyBeanClass&quot;/&gt;
    </pre></div>
  
<p>
    Here a converter instance of the class
    <code>com.mypackage.convert.MyCustomConverter</code> is created and
    registered for the target class <code>com.mypackage.model.MyBeanClass</code>.
    Alternatively the dependency injection framework can be used to create the
    converter instance as a bean which is then referenced from the
    <code>&lt;f:converter&gt;</code> tag. This approach is more powerful. If the
    converter has to be created using a different constructor or if properties
    have to be set, it is the way to go. The code fragment below demonstrates
    this scenario:
  </p>
    
<div class="source">
<pre>
&lt;!-- Definition of the converter bean --&gt;
&lt;di:bean name=&quot;customConverter&quot;
  beanClass=&quot;com.mypackage.convert.MyCustomConverter&quot;&gt;
  &lt;!-- Further initialization, e.g. constructor calls or properties set --&gt;
  ...
&lt;/di:bean&gt;

&lt;f:converter beanName=&quot;customConverter&quot;
  converterTargetClassName=&quot;com.mypackage.model.MyBeanClass&quot;
  converterTargetClassLoader=&quot;specialClassLoader&quot;
  isBaseClassConverter=&quot;true&quot;/&gt;
    </pre></div>
  
<p>
    This example shows some more options of <code>&lt;f:converter&gt;</code>
    tag. No matter which mechanism is used for creating the converter object, a
    target class must be specified. This is the class produced by the converter
    when converting objects. As can be seen here, the target class can either be
    specified directly or by providing its name and the name of the class loader
    to load the class (refer to the section
    <a href="dibuilder.html#Class_loader_issues">Class loader issues</a> for
    more details).
  </p>
  
<p>
    Further, the <code>isBaseClassConverter</code> attribute can be specified.
    If the attribute is missing, the converter will only be called
    if the target class of a conversion matches exactly the target class
    specified at the tag. If the attribute is present (the exact value does not
    matter), the converter will also be called for subclasses of the specified
    target class.
  </p>
  
<p>
    The converter is active directly after the execution of the
    <code>&lt;f:converter&gt;</code> tag. So bean declarations succeeding the
    tag can already make use of data conversions supported by the converter.
    When using the builder in the default way there is also a kind of
    inheritance mechanism for data type converters: The
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/BuilderData.html">
    BuilderData</a></code> object passed to the builder can contain a reference
    to the parent <code>BeanContext</code>. If this reference is set (which is
    the case per default), all data type converters active for the parent
    context are also available for the current builder operation. So
    depending on the builder script in which a converter is defined, its scope
    is determined. If an application uses some special data types for which
    custom converters are required, it can register the corresponding converters
    in its main builder script (this is the script defining the main window of
    the application, i.e. the script executed at application startup). They are
    then available to all builder scripts invoked later (provided that the
    default parent bean context is passed). On the other hand, converters that
    are very specific and are only required in a single builder script can be
    defined in this script only.
  </p>
  </section>

  <section>
<h3><a name="Components_and_the_form_model"></a>Components and the form model</h3>
  
<p>
    In the sections about the single components supported by the component
    builder tag library it was also mentioned, which kind of data is stored in
    the form's model for this type of component. In this chapter we focus on
    this topic and show how to create a Java class that can serve as a model
    bean for a form.
  </p>
  
<p>
    Per default the model of a form is a plain Java bean. It is also possible to
    use other types of model objects as discussed in the section
    <a href="forms.html#The_binding_strategy">The binding strategy</a>, but for
    many applications Java beans will be sufficient. The rules how the input
    components are bound to a Java bean are pretty simple: For a component with
    the name <i>foo</i> there must be a property in the bean with a
    corresponding data type that is also named <i>foo</i> (i.e. there must be
    public methods <code>DataType getFoo()</code> and
    <code>void setFoo(DataType obj)</code>). Instead of the name of the
    component the <code>propertyName</code> attribute of the tag defining the
    component can be used to specify the name of the model property. So if a
    builder script contains the following declaration:
  </p>
    
<div class="source">
<pre>
&lt;f:textfield name=&quot;fileName&quot; displayNameres=&quot;newfile_disp_name&quot;
  maxlength=&quot;200&quot; propertyName=&quot;path&quot;&gt;
&lt;/f:textfield&gt;
    </pre></div>
  
<p>
    the name of the property in the model bean would have to be <i>Path</i>.
    It is important that the data type of the property matches the type of data
    that is expected by the associated component - otherwise there will be
    exceptions when the data is accessed. The following table shows the mapping
    between components and data types in the model:
  </p>
  
<p>
    </p>
<table class="bodyTable" border="1">
    
<tr class="a">
      
<th>Component</th>
<th>Remark</th>
<th>Data type</th>
    </tr>
    
<tr class="b">
      
<td valign="top">
      <a href="#textcomponents">Text components</a></td>
      
<td>Without transformers</td>
      
<td><code>java.lang.String</code></td>
    </tr>
    
<tr class="a">
      
<td valign="top">
      <a href="#checkboxes">Checkboxes</a></td>
      
<td></td>
      
<td><b>boolean</b> or <code>java.lang.Boolean</code></td>
    </tr>
    
<tr class="b">
      
<td valign="top">
      <a href="#radios">Radio buttons</a></td>
      
<td>Depends on the <code>ComponentHandler</code></td>
      
<td><b>int</b> or <code>java.lang.Integer</code>
      for the default handler</td>
    </tr>
    
<tr class="a">
      
<td valign="top">
      <a href="#lists_combos">Lists/Combo boxes</a></td>
      
<td>Single selection mode</td>
      
<td>
      An object of the type declared by the list model.
      </td>
    </tr>
    
<tr class="b">
      
<td></td>
      
<td>Multi selection mode</td>
      
<td>
      An array of the type declared by the list model.
      </td>
    </tr>
    
<tr class="a">
      
<td valign="top">
      <a href="#progressbars">Progress bars</a></td>
      
<td>Per default not stored in the model</td>
      
<td><b>int</b> or <code>java.lang.Integer</code></td>
    </tr>
    
<tr class="b">
      
<td valign="top">
      <a href="#sliders">Sliders</a></td>
      
<td></td>
      
<td><b>int</b> or <code>java.lang.Integer</code></td>
    </tr>
    
<tr class="a">
      
<td valign="top">
      <a href="#buttons">Buttons</a></td>
      
<td>Toggle buttons or command buttons (the latter are not stored in the
      model per default)</td>
      
<td><b>boolean</b> or <code>java.lang.Boolean</code></td>
    </tr>
    
<tr class="b">
      
<td valign="top">
      <a href="#trees">Trees</a></td>
      
<td>Single selection mode (per default not added to the model)</td>
      
<td>
      An object of type
      <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/components/model/TreeNodePath.html">
      TreeNodePath</a></code>
      </td>
    </tr>
    
<tr class="a">
      
<td></td>
      
<td>Multi selection mode (per default not added to the model)</td>
      
<td>
      An array of type
      <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/components/model/TreeNodePath.html">
      TreeNodePath</a></code>
      </td>
    </tr>
    
<tr class="b">
      
<td valign="top">
      <a href="#tables">Tables</a></td>
      
<td>Single selection mode (per default not added to the model)</td>
      
<td><b>int</b> or <code>java.lang.Integer</code></td>
    </tr>
    
<tr class="a">
      
<td></td>
      
<td>Multi selection mode (per default not added to the model)</td>
      
<td>
      an array of int for the selected indices
      </td>
    </tr>
    </table>
  
  
<p>
    Some remarks about this table:
    </p>
<ul>
    
<li>Some components are typically not used directly to gather user input,
    but support editing by displaying further information. The table contains a
    remark for these components that they are not added to the model per default.
    If data for such a component is to be stored, the <code>noField</code>
    attribute of the declaring tag has to be set to <b>false</b> explicitly.</li>
    
<li>Properties are set or read through reflection. So in most cases it does
    not matter whether primitive types or wrapper types are used.</li>
    
<li>If <a href="#transformers">Transformers</a> are used, the actual data
    type can be different. In this case it has to be compatible with the type
    produced by the transformer.</li>
    </ul>
  
  
<p>
    What was not covered so far is the question how the model is associated with
    the form. When a builder script is processed a <a href="forms.html">Form</a>
    object is created and initialized automatically based on the components
    defined in the script. But the form does not manage its model on its own.
    This task lies in the responsibility of the
    <a href="formcontroller.html">Form controller</a>. So in order to pass the
    bean acting as data model to the form the following steps must be performed:
    </p>
<ul>
    
<li>A bean class with properties according to the table above must be
    created.</li>
    
<li>A bean declaration for this bean class has to be added to the
    builder script.</li>
    
<li>The builder script must contain the declaration of a form controller.
    Here the default implementation provided by <i>JGUIraffe</i> can be
    used.</li>
    
<li>A tag of the window builder tag library is used to connect the form
    controller with the window and to specify the model bean.</li>
    </ul>
  
  
<p>
    Form controllers and their declaration will be discussed in later chapters
    in more detail. For now we just provide a simple example that shows the
    minimum required steps for associating the form with its model.
  </p>
  
<p>
    In the section <a href="#A_simple_example">A simple example</a> a simple
    form was generated with two text fields for creating new text files. A
    compatible model class could look as follows:
  </p>
    
<div class="source">
<pre>
public class CreateFileData
{
    /** The file name. */
    private String fileName;

    /** The file content. */
    private String fileContent;

    public String getFileName()
    {
        return fileName;
    }

    public void setFileName(String fileName)
    {
        this.fileName = fileName;
    }

    public String getFileContent()
    {
        return fileContent;
    }

    public void setFileContent(String fileContent)
    {
        this.fileContent = fileContent;
    }
}
    </pre></div>
  
<p>
    This is pretty easy because we have only two properties of type String, but
    you should be able to get the concept behind it. Now in the builder script
    we use tags of the dependency injection framework to create a bean of this
    model class:
  </p>
    
<div class="source">
<pre>
&lt;di:bean name=&quot;createFileModel&quot;
  beanClass=&quot;net.sf.jguiraffe.examples.tutorial.createfile.CreateFileData&quot;/&gt;
    </pre></div>
  
<p>
    Next the form controller is declared. It is associated with the buttons for
    saving or canceling the form.
  </p>
    
<div class="source">
<pre>
&lt;di:bean name=&quot;controller&quot;
  beanClass=&quot;net.sf.jguiraffe.gui.builder.window.ctrl.FormController&quot;&gt;
  &lt;di:setProperty property=&quot;btnOkName&quot; value=&quot;btnOk&quot;/&gt;
  &lt;di:setProperty property=&quot;btnCancelName&quot; value=&quot;btnCancel&quot;/&gt;
  &lt;di:setProperty property=&quot;okCommand&quot; refName=&quot;okCommand&quot;/&gt;
&lt;/di:bean&gt;
    </pre></div>
  
<p>
    The final step is the <code>&lt;w:formcontroller&gt;</code> tag which has to
    be placed inside the enclosing window. It establishes the connection between
    the form controller bean and the window to be controlled. It is also assigned
    the bean acting as the form's model:
  </p>
    
<div class="source">
<pre>
&lt;w:dialog ...&gt;
  ...
  &lt;w:formController beanName=&quot;controller&quot; formBeanName=&quot;createFileModel&quot;&gt;
  &lt;/w:formController&gt;

  ...
&lt;/w:dialog&gt;
    </pre></div>
  
<p>
    Note that except for the creation of the model class all other steps are
    declarative. No further coding is required. <i>JGUIraffe</i> now handles
    the complete life-cycle of the form and ensures that the model is correctly
    filled.
  </p>
  
<p>
    This should be enough for now. Later chapters will provide more details
    about the associations between forms, form controllers, dialog windows, and
    form models. Also information about event handling is provided.
  </p>
  </section>
  </section>



      </div>
    </div>
    <div class="clear">
      <hr/>
    </div>
    <div id="footer">
      <div class="xright">
        Copyright &#169;      2021The JGUIraffe Team.
.      </div>
      <div class="clear">
        <hr/>
      </div>
    </div>
  </body>
</html>