<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- Generated by Apache Maven Doxia Site Renderer 1.7.1 at 2018-11-15 -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>JGUIraffe &#x2013; Forms</title>
    <style type="text/css" media="all">
      @import url("../css/maven-base.css");
      @import url("../css/maven-theme.css");
      @import url("../css/site.css");
    </style>
    <link rel="stylesheet" href="../css/print.css" type="text/css" media="print" />
      <meta name="author" content="Oliver Heger" />
    <meta http-equiv="Content-Language" content="en" />
        
        </head>
  <body class="composite">
    <div id="banner">
                        <a href="http://jguiraffe.sourceforge.net/" id="bannerLeft">
                                                <img src="../images/giraffe.jpg" alt="JGUIraffe" />
                </a>
                              <a href="http://www.sourceforge.net" id="bannerRight">
                                        <img src="http://sflogo.sourceforge.net/sflogo.php?group_id=162864&type=7" alt="Sourceforge.net" />
                </a>
            <div class="clear">
        <hr/>
      </div>
    </div>
    <div id="breadcrumbs">
          
                <div class="xleft">
        <span id="publishDate">Last Published: 2018-11-15</span>
                  &nbsp;| <span id="projectVersion">Version: 1.4-SNAPSHOT</span>
                      </div>
            <div class="xright">                    <a href="http://sourceforge.net/projects/jguiraffe/" class="externalLink" title="SourceForge">SourceForge</a>
            
      </div>
      <div class="clear">
        <hr/>
      </div>
    </div>
    <div id="leftColumn">
      <div id="navcolumn">
           
                                <h5>JGuiraffe</h5>
                  <ul>
                  <li class="none">
                          <a href="../index.html" title="Home">Home</a>
            </li>
                  <li class="none">
                          <a href="../introduction.html" title="Introduction">Introduction</a>
            </li>
                  <li class="none">
                          <a href="../overview.html" title="Overview">Overview</a>
            </li>
                  <li class="none">
                          <a href="../userguide/user_guide.html" title="User's Guide">User's Guide</a>
            </li>
                  <li class="none">
                          <a href="../apidocs/index.html" title="Javadoc (latest)">Javadoc (latest)</a>
            </li>
                  <li class="none">
                          <a href="../jguiraffe-parent/jguiraffe-examples/index.html" title="JGUIraffe Examples">JGUIraffe Examples</a>
            </li>
                  <li class="none">
                          <a href="http://sourceforge.net/p/jguiraffe/git/ci/master/tree/" class="externalLink" title="GIT">GIT</a>
            </li>
                  <li class="none">
                          <a href="../building.html" title="Building from Source">Building from Source</a>
            </li>
                  <li class="none">
                          <a href="../jguiraffe-parent/jguiraffe/changes-report.html" title="Changes Report">Changes Report</a>
            </li>
          </ul>
                       <h5>Modules</h5>
                  <ul>
                  <li class="none">
                          <a href="../jguiraffe-parent/jguiraffe/index.html" title="JGUIraffe Core">JGUIraffe Core</a>
            </li>
                  <li class="none">
                          <a href="../jguiraffe-parent/jguiraffe-swing/index.html" title="JGUIraffe Swing integration">JGUIraffe Swing integration</a>
            </li>
                  <li class="none">
                          <a href="../jguiraffe-parent/jguiraffe-java-fx/index.html" title="JGUIraffe JavaFX integration">JGUIraffe JavaFX integration</a>
            </li>
          </ul>
                             <a href="http://maven.apache.org/" title="Built by Maven" class="poweredBy">
        <img class="poweredBy" alt="Built by Maven" src="../images/logos/maven-feather.png" />
      </a>
                 
            </div>
    </div>
    <div id="bodyColumn">
      <div id="contentBox">
        

 
  <div class="section">
<h2><a name="Working_with_forms"></a>Working with forms</h2>
  
<p>
    One of the main features of the <i>JGUIraffe</i> library is its support
    for forms. Typically, the creation and management of a form is a task most
    developers are not crazy about. Though not really complicated, there is a
    lot of boiler-plate code that has to be written in order to
    </p>
<ul>
    
<li>populate the input fields with their initial values,</li>
    
<li>react on the OK and Cancel buttons in an appropriate way,</li>
    
<li>perform validation of user input (which can happen when the user presses
    OK or already during editing, so that invalid input can be reported
    immediately,</li>
    
<li>and finally collect the data entered by the user and store it in the
    data model used by the application.</li>
    </ul>
  
  
<p>
    The <tt><a href="../apidocs/net/sf/jguiraffe/gui/forms/Form.html">Form</a></tt>
    class and other helper classes located in the
    <tt>net.sf.jguiraffe.gui.forms</tt> package are designed to simplify the
    work with forms to a great extent. In the following sections the usage of
    the <tt>Form</tt> class is described. This knowledge is required if a
    <tt>Form</tt> instance is to be used directly (which already should be
    of great help compared with standard programming of user interface
    components). When used together with the builder framework most of the
    interaction with forms is done under the hood by the framework. In fact, it
    is then hardly necessary to access a <tt>Form</tt> object at all!
  </p>

  
<div class="section">
<h3><a name="Constructing_a_form"></a>Constructing a form</h3>
  
<p>
    A <tt><a href="../apidocs/net/sf/jguiraffe/gui/forms/Form.html">Form</a></tt>
    object stores an internal model of all its input fields. It is not a visible
    object, but only provides access to user input. Each input field is
    represented by an object implementing the
    <tt><a href="../apidocs/net/sf/jguiraffe/gui/forms/FieldHandler.html">FieldHandler</a></tt>
    interface. The <tt>FieldHandler</tt> acts as a kind of adaptor between
    a logic input field and its data and the physical input component that
    is visible to the user. It provides the following functionality:
    </p>
<ul>
    
<li>Read and write access to the physical input component. This is actually
    done by another helper object: a
    <tt><a href="../apidocs/net/sf/jguiraffe/gui/forms/ComponentHandler.html">
    ComponentHandler</a></tt>. The <tt>ComponentHandler</tt> knows how to
    interact with an input component of a specific type. For instance, there
    are special <tt>ComponentHandler</tt> implementations for text fields,
    checkboxes, radio buttons, list fields, etc.</li>
    
<li>Transformation of data. For instance, a text input field might actually
    be used for entering a numeric value. So, when populating the input fields
    when the form is opened the number obtained from the application's data
    model must be converted to a string. When the form is closed and its data is
    to be written back into the model the inverse transformation has to be
    performed.</li>
    
<li>Validation of data. In order to perform the transformations necessary,
    it has to be ensured that the data typed in by the user is syntactically
    correct (e.g. a text entered by the user is indeed a valid number). In most
    cases a semantic validation is required, too (e.g. the number must be
    between 0 and 100).</li>
    </ul>
    With <tt><a href="../apidocs/net/sf/jguiraffe/gui/forms/DefaultFieldHandler.html">
    DefaultFieldHandler</a></tt> there is a fully functional implementation
    of the <tt>FieldHandler</tt> interface. A <tt>DefaultFieldHandler</tt>
    can be initialized with all the helper objects like transformers, validators, and a
    <tt>ComponentHandler</tt> it needs for fulfilling its tasks.
  
  
<p>
    To construct a <tt>Form</tt> object the form constructor has to be called;
    then the <tt>FieldHandler</tt> objects representing the input fields
    have to be added by calling the <tt>addField()</tt> method. The
    constructor of the <tt>Form</tt> class expects two helper objects:
    </p>
<ul>
    
<li>A <tt><a href="../apidocs/net/sf/jguiraffe/transform/TransformerContext.html">
    TransformerContext</a></tt> object: This object is needed by the transformers
    and validators used by the form, e.g. to resolve resources, determine the
    current <tt>Locale</tt>, and get current properties.
    <tt>TransformerContext</tt> is a super interface of
    <tt><a href="../apidocs/net/sf/jguiraffe/gui/app/ApplicationContext.html">
    ApplicationContext</a></tt>. So the current implementation of this
    interface can be directly obtained from the central
    <tt><a href="../apidocs/net/sf/jguiraffe/gui/app/Application.html">
    Application</a></tt> object.</li>
    
<li>A <tt><a href="../apidocs/net/sf/jguiraffe/gui/forms/BindingStrategy.html">
    BindingStrategy</a></tt> object: A <i>binding strategy</i> is responsible
    for the communication between the <tt>Form</tt> object and the data
    model used by the application. This is discussed in detail a little later.</li>
    </ul>
  
  
<p>
    For each input field to be managed by the form the <tt>addField()</tt>
    method has to be called. <tt>addFields()</tt> expects the (logic) name
    of the input field and its corresponding <tt>FieldHandler</tt> as
    arguments. Constructing the <tt>FieldHandler</tt> objects with all their
    dependent helper objects is not a trivial task. Doing this manually can be
    cumbersome. In this area the <i>form builder framework</i> is a great
    help.
  </p>
  </div>

  
<div class="section">
<h3><a name="The_binding_strategy"></a>The binding strategy</h3>
  
<p>
    Every <tt>Form</tt> object is associated with a
    <tt><a href="../apidocs/net/sf/jguiraffe/gui/forms/BindingStrategy.html">
    BindingStrategy</a></tt>. As was already pointed out, the
    <tt>BindingStrategy</tt> is responsible for the interaction with the
    data model used by the application.
  </p>
  
<p>
    The idea behind a <tt>BindingStrategy</tt> is that applications may use
    different ways for storing the data to be managed by forms: Some applications
    may use standard Java beans (e.g. Hibernate objects or JPA entities fall
    into this category). If beans are used as data model for a form, the input
    fields typically have to be mapped to bean properties. Other applications
    may operate on special <i>data transfer objects</i>, e.g. <i>Service
    Data Objects (SDO)</i> or map-based objects. A <tt>Form</tt> does not
    have to know about the underlying model objects; this lies in the
    responsibility of the <tt>BindingStrategy</tt>.
  </p>
  
<p>
    The <tt>BindingStrategy</tt> interface is pretty lean: it defines one
    method for reading a property from a model object, and another one for
    writing a property. It should not be too complicated to implement this
    interface to support a custom type of model objects. The default binding
    strategy is
    <tt><a href="../apidocs/net/sf/jguiraffe/gui/forms/bind/BeanBindingStrategy.html">
    BeanBindingStrategy</a></tt>, which operates on standard Java beans. It
    uses reflection for reading and writing properties from and to model objects,
    which must conform to the Java beans standard.
  </p>
  </div>

  
<div class="section">
<h3><a name="Initializing_input_fields"></a>Initializing input fields</h3>
  
<p>
    When a form is opened its input fields typically have to be initialized with
    data from the model. As an example consider a form that allows editing an
    existing entity; of course, the data of this entity has to be displayed.
  </p>
  
<p>
    The <tt>Form</tt> defines the <tt>initFields()</tt> method for this
    purpose. The method is passed a model object, which contains the data to be
    displayed. This model object must be compatible with the
    <tt>BindingStrategy</tt> used by the form (see above)! It iterates over
    all input fields contained in the form and asks the <tt>BindingStrategy</tt>
    to read the corresponding properties from the model object. The values of
    these properties are then transformed - according to the transformers
    defined for the <tt>FieldHandler</tt> objects - and written into the
    visual input components of the form.
  </p>
  
<p>
    There is also an overloaded version of <tt>initFields()</tt> that
    additionally accepts a set with the names of the fields to be initialized.
    That way only a subset of the form's fields can be initialized, which may
    be useful in some situations. Many of the methods provided by the
    <tt>Form</tt> class allow restricting their operation on a subset of
    fields.
  </p>
  </div>

  
<div class="section">
<h3><a name="Validation"></a>Validation</h3>
  
<p>
    Validation of a form means checking that all input entered by the user in
    the form's input fields conforms to certain criteria enforced by so-called
    <i>validator</i> objects associated with the input fields or the form as
    a whole. Typical validation criteria are rules like &quot;Field X must not be
    empty&quot;, &quot;Field Y must contain a valid number between 0 and 100&quot;, or &quot;Field
    Z must contain a date that lies in the future&quot;. In most cases the logic of
    an application dictates the validation rules that must be checked.
  </p>
  
<p>
    However, ensuring that all input fields contain valid data is only one half
    of the game. In most cases it is also desired that the data of the input
    fields is extracted, converted into the correct data type (for instance, an
    input field that accepts only numeric data should produce an
    <tt>Integer</tt> or <tt>Double</tt> object rather than a string),
    and passed to the data model of the application. The
    <tt><a href="../apidocs/net/sf/jguiraffe/gui/forms/Form.html">Form</a></tt>
    class supports this with the help of <tt>Transformer</tt> and
    <tt>Validator</tt> objects.
  </p>
  
<p>
    A <tt>Transformer</tt> is responsible for data conversion. When a form is
    opened and the input fields are populated from the data model one
    <tt>Transformer</tt> - the so-called <i>write transformer</i> has to
    covert the type of a model property to the expected data type for the input
    component used. For instance, text fields only operate on strings, even if
    they should accept only numeric data. So a number object obtained from the
    data model has to be converted into a string. When the user clicks the OK
    button and the form needs to be read the opposite transformation has to be
    performed (in the example with the numeric input field the string obtained
    from the input field has to be converted to a number, which is then stored
    in the data model). This second transformation is done by another
    <tt>Transformer</tt> - the <i>read transformer</i>. Both types of
    transformers are associated with the <tt>FieldHandler</tt> representing
    the corresponding input field. The
    <tt><a href="../apidocs/net/sf/jguiraffe/gui/forms/DefaultFieldHandler.html">
    DefaultFieldHandler</a></tt> class provides get and set methods for these
    two <tt>Transformer</tt> objects.
  </p>
  
<p>
    Transformations can only be successful if the data entered by the user is
    valid. If the user has entered the text &quot;ABC&quot; in the numeric input field
    <i>Age</i>, no <tt>Integer</tt> can be created for that input. So
    <tt>Validator</tt> objects have to work together closely with
    <tt>Transformer</tt> objects to ensure correctness. The <tt>Form</tt>
    class supports three levels of validation:
    </p>
<ol style="list-style-type: decimal">
    
<li>Syntactic validation at the field level. This validation checks whether
    the data entered by the user actually conforms to the target data type.</li>
    
<li>Logic validation at the field level. Here logic conditions can be
    checked after the data has been converted to the target data type.</li>
    
<li>Logic validation at the form level. At this layer conditions referring
    to multiple fields can be checked.</li>
    </ol>
    We describe these validation levels in more detail and discuss how they are
    related to the validators that can be specified for a
    <tt><a href="../apidocs/net/sf/jguiraffe/gui/forms/DefaultFieldHandler.html">
    DefaultFieldHandler</a></tt> instance.
  
  
<p>
    The lowest level of validation is the syntax check of the form's input fields. It
    is performed by the validator set by the <tt>setSyntaxValidator()</tt> method of
    <tt>DefaultFieldHandler</tt>. Its purpose is to ensure that data
    entered by the user can be successfully converted to the desired target
    data type. For instance, if an input field accepts a numeric value, this
    validation has to ensure that the string entered by the user is indeed a
    valid number. Providing a correct <i>syntax validator</i> is important
    because otherwise transformation to the target data type is impossible. The
    <i>syntax validator</i> must be compatible with the <i>read transformer</i>
    of the <tt>DefaultFieldHandler</tt>, i.e. if it indicates a valid input,
    transformation must be guaranteed to be successful.
  </p>
  
<p>
    The next validation level is the logic check of the form's input fields. This
    phase is initiated after the <i>read transformer</i> has been invoked, and
    it is executed by the validator set through the <tt>setLogicValidator()</tt>
    method of <tt>DefaultFieldHandler</tt>. The main difference to the
    syntactic validation is that the object passed to the <i>logic validator</i>
    is not the plain string entered by the user, but the result of the
    <i>read transformer</i>, i.e. the data converted to the target data type.
    In the example of the numeric input field, the <i>logic validator</i>
    would be passed an <tt>Integer</tt> object. This simplifies logic
    checks. The purpose of the logic validation is to check for conditions on
    the target data type, e.g. &quot;Is the number between 0 and 100&quot; or &quot;Is the
    date in the future&quot;.
  </p>
  
<p>
    The syntax and the logic validation operate on single input fields and are
    therefore initiated by the <tt>FieldHandler</tt> objects. (By the way,
    there is an enumeration class
    <tt><a href="../apidocs/net/sf/jguiraffe/gui/forms/ValidationPhase.html">
    ValidationPhase</a></tt> that assigns names to the single phases of
    field validation.) In many use cases more complex conditions have to be
    checked that involve multiple input fields. As an example consider a dialog
    for entering payment options: here a validation rule could be defined that
    the <tt>creditCardNo</tt> field must contain a valid credit card number,
    but only if the <tt>payment</tt> radio button is enabled. In practice
    arbitrarily complex validation rules are possible which include all input
    fields of the form. So the whole data of the form must be available at this
    stage. Responsible for this kind of validation are objects implementing the
    <tt><a href="../apidocs/net/sf/jguiraffe/gui/forms/FormValidator.html">
    FormValidator</a></tt> interface. A <tt>Form</tt> object can be
    associated with a <tt>FormValidator</tt> using its
    <tt>setFormValidator()</tt> method. The <tt>FormValidator</tt> is
    invoked after validation at the field level (both syntax and logic validation)
    have been successful. We describe form validators in the next section.
  </p>
  
<p>
    After all that theory, how is validation triggered in practice? The good
    news is that this is a matter of a single method call: just call the
    <tt>Form.validate()</tt> method and pass in a data model object.
    <tt>validate()</tt> first performs syntactic and logic validation at
    the field level. If this is successful, the <tt>FormValidator</tt> is
    invoked if it is defined. If all validation steps have been successful, the
    data is written into the passed in model object (which must conform to the
    <tt>BindingStrategy</tt> set for the form). Otherwise, if there is at
    least one validation failure, the model object is not checked. In any case
    <tt>validate()</tt> returns an object of the class
    <tt><a href="../apidocs/net/sf/jguiraffe/gui/forms/FormValidationResults.html">
    FormValidationResults</a></tt>. Using this object the result of the
    validation (success or failure) can be checked. If there are validation
    errors, the input fields affected and the corresponding error messages can
    be retrieved. Basically, a <tt>FormValidationResults</tt> object
    contains all information required for giving the user feedback about a
    failed validation.
  </p>
  </div>

  
<div class="section">
<h3><a name="Form_validators"></a>Form validators</h3>
  
<p>
    The <tt><a href="../apidocs/net/sf/jguiraffe/gui/forms/FormValidator.html">
    FormValidator</a></tt> interface has already been mentioned in the last
    section. In this section we discuss how to implement a concrete form
    validator and how to associate it with a <tt>Form</tt> object.
  </p>
  
<p>
    The <tt>FormValidator</tt> interface contains only a single method:
    <tt>isValid()</tt>. This method expects a <tt>Form</tt> object as
    parameter and returns a
    <tt><a href="../apidocs/net/sf/jguiraffe/gui/forms/FormValidationResults.html">
    FormValidationResults</a></tt> with the results of the validation.
    Typically form validators do very specific things that strongly depend on
    application logic. Because of that the framework cannot provide any
    meaningful base classes to extend from when writing custom form validators.
  </p>
  
<p>
    In any case the form validator will have to access the values of the form's
    input fields for checking their current values. At the time the
    <tt>isValid()</tt> is triggered, validation at the field level was
    already successful. This means the validator can assume that all fields
    contain syntactically correct data, which has already been converted to the
    appropriate target data type. There are two ways for accessing the data of
    the single input fields:
    </p>
<ul>
    
<li>The <tt>FieldHandler</tt> objects of specific fields can be obtained
    by calling the <tt>getField()</tt> method of <tt>Form</tt>. The name
    of the field has to be passed in. The <tt>FieldHandler</tt> interface
    defines a <tt>getMethod()</tt>, which returns the current value of
    this field (in the target data type).</li>
    
<li>In order to get the content of the form as a whole the validator can
    create a new model object and call the form's <tt>readFields()</tt>
    method. <tt>readFields()</tt> can be called after a successful
    validation at the field level. It copies the current data of the input
    fields into the passed in model data object (which must be compatible with
    the <tt>BindingStrategy</tt> used by the form).</li>
    </ul>
  
  
<p>
    The results of the validation are returned in form of a
    <tt><a href="../apidocs/net/sf/jguiraffe/gui/forms/FormValidationResults.html">
    FormValidationResults</a></tt> object. This object not only has a boolean
    <i>valid</i> flag, but - in case of a failed validation - also contains
    information about the invalid fields and the validation errors. A default
    implementation of <tt>FormValidationResults</tt> is provided by the
    <tt><a href="../apidocs/net/sf/jguiraffe/gui/forms/DefaultFormValidationResults.html">
    DefaultFormValidationResults</a></tt> class. An instance of this class
    is constructed with a map of validation results for the single fields of
    the form. The map uses the names of the input fields as keys and associates
    them with
    <tt><a href="../apidocs/net/sf/jguiraffe/transform/ValidationResult.html">
    ValidationResult</a></tt> objects (refer to the section about transformers
    and validators for more information about <tt>ValidationResult</tt>).
  </p>
  
<p>
    We will now present a small example of an implementation of the
    <tt>FormValidator</tt> interface. We assume that the validator checks
    a form with shipment information of an online shop. It enforces the
    validation rule: &quot;If the user checked the field <i>different delivery
    address</i>, the field <i>delivery address</i> must be filled&quot;. An
    implementation could look as follows:
    </p>
<div class="source">
<pre>
public class ShipmentFormValidator implements FormValidator
{
    // Constants for the names of input fields
    private static final String FLD_DIFFERENT_ADDRESS = &quot;differentDeliveryAdr&quot;;
    private static final String FLD_DELIVERY_ADDRESS = &quot;deliveryAdr&quot;;

    public FormValidationResults isValid(Form form)
    {
        // Set up the default map with valid results
        Map&lt;String, ValidationResult&gt; results =
          DefaultFormValidationResults.validResultMapForForm(form);

        // Now implement validation checks
        Boolean differentAddress =
          (Boolean) form.getField(FLD_DIFFENT_ADDRESS).getData();
        if (differentAddress.booleanValue())
        {
            String s = (String) form.getField(FLD_DELIVERY_ADDRESS).getData();
            if (s == null || s.length() &lt; 1)
            {
                results.put(FLD_DELIVERY_ADDRESS,
                    DefaultFormValidationResults.createValidationErrorResult(form,
                        ValidationMessageConstants.ERR_FIELD_REQUIRED));
            }
        }

        // further checks ommitted

        // Construct the result object
        return new DefaultFormValidationResults(results);
    }
}
    </pre></div>
  
  
<p>
    The actual validation check should be pretty clear. The remaining code for
    setting up the results object deserves some explainations: The validator
    must return a <tt>FormValidationResults</tt> object and uses the
    default implementation <tt>DefaultFormValidationResults</tt> for this
    purpose. The constructor of this class expects a map with
    <tt>ValidationResult</tt> objects for all form fields. With the static
    method <tt>validResultMapForForm()</tt> such a map is created that contains
    only valid <tt>ValidationResult</tt> objects. This is a good starting
    point; during validation some of these objects may be replaced by
    <tt>ValidationResult</tt> objects with error messages.
    <tt>DefaultFormValidationResults</tt> defines a convenience method for
    creating a <tt>ValidationResult</tt> object for a failed validation:
    <tt>createValidationErrorResult()</tt>. This method is passed the key
    of the error and otional parameters. Our example validator calls this
    method if the validation rule for the delivery address is violated.
  </p>
  
<p>
    The implementation of <tt>FormValidator</tt> in this example used direct
    access to the form's imput fields. By using a model object the code could be
    simplified a bit. We assume that a Java bean class named
    <tt>ShipmentBean</tt> exists with properties that correspond to the
    form's fields. In this case the implementation could look like:
    </p>
<div class="source">
<pre>
public class ShipmentFormValidator implements FormValidator
{
    // Constants for the names of input fields
    private static final String FLD_DELIVERY_ADDRESS = &quot;deliveryAdr&quot;;

    public FormValidationResults isValid(Form form)
    {
        // Set up the default map with valid results
        Map&lt;String, ValidationResult&gt; results =
          DefaultFormValidationResults.validResultMapForForm(form);

        // Obtain the data from the form
        ShipmentBean data = new ShipmentBean();
        form.readFields(data);

        // Now implement validation checks
        if (data.isDifferentAddress())
        {
            String s = data.getDeliveryAddress();
            if (s == null || s.length() &lt; 1)
            {
                results.put(FLD_DELIVERY_ADDRESS,
                    DefaultFormValidationResults.createValidationErrorResult(form,
                        ValidationMessageConstants.ERR_FIELD_REQUIRED));
            }
        }

        // further checks ommitted

        // Construct the result object
        return new DefaultFormValidationResults(results);
    }
}
    </pre></div>
  
  </div>
  </div>



      </div>
    </div>
    <div class="clear">
      <hr/>
    </div>
    <div id="footer">
      <div class="xright">
              Copyright &#169;                    2018
                      The JGUIraffe Team.
            All rights reserved.    
                  </div>
      <div class="clear">
        <hr/>
      </div>
    </div>
  </body>
</html>
