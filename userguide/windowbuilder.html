<!DOCTYPE html>
<!--
 | Generated by Apache Maven Doxia Site Renderer 1.9.2 from src/site/xdoc/userguide/windowbuilder.xml at 2021-07-28

 | Rendered using Apache Maven Default Skin
-->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="generator" content="Apache Maven Doxia Site Renderer 1.9.2" />
    <meta name="author" content="Oliver Heger" />
    <title>JGUIraffe &#x2013; Building windows</title>
    <link rel="stylesheet" href="../css/maven-base.css" />
    <link rel="stylesheet" href="../css/maven-theme.css" />
    <link rel="stylesheet" href="../css/site.css" />
    <link rel="stylesheet" href="../css/print.css" media="print" />
  </head>
  <body class="composite">
    <div id="banner">
<a href=".././" id="bannerLeft"><img src="../images/giraffe.jpg"  alt="JGUIraffe"/></a>      <div class="clear">
        <hr/>
      </div>
    </div>
    <div id="breadcrumbs">
      <div class="xleft">
        <span id="publishDate">Last Published: 2021-07-28</span>
          &#xA0;| <span id="projectVersion">Version: 1.4-SNAPSHOT</span>
      </div>
      <div class="xright"><a href=".././" title="GitHub project">GitHub project</a>      </div>
      <div class="clear">
        <hr/>
      </div>
    </div>
    <div id="leftColumn">
      <div id="navcolumn">
       <h5>JGuiraffe</h5>
    <ul>
     <li class="none"><a href="../index.html" title="Home">Home</a></li>
     <li class="none"><a href="../introduction.html" title="Introduction">Introduction</a></li>
     <li class="none"><a href="../overview.html" title="Overview">Overview</a></li>
     <li class="none"><a href="../userguide/user_guide.html" title="User's Guide">User's Guide</a></li>
     <li class="none"><a href="../apidocs/index.html" title="Javadoc (latest)">Javadoc (latest)</a></li>
     <li class="none"><a href="../jguiraffe-parent/jguiraffe-examples/index.html" title="JGUIraffe Examples">JGUIraffe Examples</a></li>
     <li class="none"><a href="../building.html" title="Building from Source">Building from Source</a></li>
     <li class="none"><a href="../jguiraffe-parent/jguiraffe/changes-report.html" title="Changes Report">Changes Report</a></li>
    </ul>
       <h5>Modules</h5>
    <ul>
     <li class="none"><a href="../jguiraffe-parent/jguiraffe/index.html" title="JGUIraffe Core">JGUIraffe Core</a></li>
     <li class="none"><a href="../jguiraffe-parent/jguiraffe-swing/index.html" title="JGUIraffe Swing integration">JGUIraffe Swing integration</a></li>
     <li class="none"><a href="../jguiraffe-parent/jguiraffe-java-fx/index.html" title="JGUIraffe JavaFX integration">JGUIraffe JavaFX integration</a></li>
    </ul>
      <a href="http://maven.apache.org/" title="Built by Maven" class="poweredBy">
        <img class="poweredBy" alt="Built by Maven" src="../images/logos/maven-feather.png" />
      </a>
      </div>
    </div>
    <div id="bodyColumn">
      <div id="contentBox">


 
  <section>
<h2><a name="Building_windows"></a>Building windows</h2>
  
<p>
    So far we have discussed how UI elements can be created and positioned using
    layout managers. We also described methods for interacting with such
    elements, so that the UI can be manipulated when certain events are received
    or the user triggered specific actions. Now, the UI of an application does
    not live on its own, but is embedded inside a window. Windows are natural
    elements of modern graphical-oriented operating systems. Nevertheless they
    have to be defined somehow.
  </p>
  
<p>
    <i>JGUIraffe</i> contains another tag library that deals with windows: the
    so-called <i>window builder tag library</i>. The tags provided by this
    library can be used to define multiple types of windows:
    </p>
<ul>
      
<li>Frame windows which usually represent main windows of an application.
      In many cases an application only has a single frame window which is the
      parent of all other windows created by this application. Frame windows are
      top-level windows of the operating system; for instance, they appear in
      the task bar.</li>
      
<li>Dialog windows are used to gather input from the user. They are
      typically child windows of the application's main frame window. They are
      rather local to the application and are not considered top-level windows of
      the operating system.</li>
      
<li>With internal frame windows there is another type of windows supported
      by the <i>window builder tag library</i>. These windows correspond to
      the Swing class <code>javax.swing.JInternalFrame</code>. They allow an
      application to open multiple child windows inside a main frame window, e.g.
      one child window for each document currently open. Such child windows were
      popular for instance in early versions of the Windows operating system;
      the approach was called <i>Multiple Document Interface</i> (MDI).
      Meanwhile state of the art applications do not use this concept any more.
      So it is recommended to avoid the use of internal frames. Also, they may
      not be supported by all platforms.</li>
    </ul>
  
  
<p>
    We will discuss the different window types and their creation in more detail
    in the following sub sections. But first we describe some of the basic
    interfaces used by the <i>window builder tag library</i> for the
    interaction with windows.
  </p>

  <section>
<h3><a name="Fundamental_concepts_and_classes"></a>Fundamental concepts and classes</h3>
  
<p>
    The creation of windows works similar to the creation of the other elements
    which have already been discussed in the previous chapters: They are
    defined using specialized tags in builder scripts. To use these tags it must
    be ensured that the <i>window builder tag library</i> has been added to
    the script. So the root element of the builder script must look as follows:
  </p>
    
<div class="source">
<pre>
&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;
&lt;j:jelly xmlns:j=&quot;jelly:core&quot; xmlns:di=&quot;diBuilder&quot; xmlns:f=&quot;formBuilder&quot;
  xmlns:a=&quot;actionBuilder&quot; xmlns:w=&quot;windowBuilder&quot;&gt;

&lt;/j:jelly&gt;
    </pre></div>
  
<p>
    Here - and in all following examples - we assign the prefix &quot;w&quot; to
    tags of the <i>window builder tag library</i>. Now tags like
    <code>&lt;w:frame&gt;</code> or <code>&lt;w:dialog&gt;</code> can be used to
    define the corresponding windows. We will come to these tags in more detail
    shortly. For now it is important to know that they act like container tags,
    e.g. the tag for creating <a href="formbuilder.html#panels">Panels</a>. This
    means that they can be assigned a layout by simply placing a corresponding
    <a href="formbuilder.html#layouts">layout tag</a> in their body. Also, the
    tags for defining the actual UI - i.e. graphical elements like labels, text
    components, tables, etc. - can be nested inside such window tags. This is a
    pretty natural approach to defining windows which seamlessly continues the
    declaration of other parts of the UI.
  </p>
  
<p>
    The <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/Builder.html">
    Builder</a></code> interface defines a specialized method for processing a
    builder script that defines a window: <code>buildWindow()</code>. Like the
    other build methods it expects the locator to the builder script and the
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/BuilderData.html">
    BuilderData</a></code> object as arguments. It returns the main window
    defined by the builder script.
  </p>
  
<p>
    In theory, a builder script is free to define an arbitrary number of windows.
    In most cases however, only a single window - e.g. a dialog box - will be
    defined. This corresponds to a &quot;unit&quot; in a graphical application.
    In this case this single window is returned by the <code>buildWindow()</code>
    method. If a window is pretty simple and only used in the context of another
    window, it may make sense to define it together with the window it depends
    on in the same builder script. An example would be a simple message window
    that is displayed by a dialog box if the user enters invalid data.
  </p>
  
<p>
    In order to access multiple windows they must have been given unique names.
    This is achieved by specifying the <code>name</code> attribute at the tags
    that create the windows. (In contrast to tags for input elements, the
    <code>name</code> attribute is optional here.) During the builder operation
    there is an instance of the
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/window/WindowBuilderData.html">
    WindowBuilderData</a></code> class which keeps track of the windows that are
    defined by the script. This instance also takes care that all windows can
    be queried from the current <code>BeanContext</code> using the reserved
    prefix <i>window:</i> followed by their name. Hence a code example
    obtaining a specific window could look as follows:
  </p>
    
<div class="source">
<pre>
// Input for the build method
Locator scriptLocator = new ClassPathLocator(&quot;mydialog.jelly&quot;);
ApplicationBuilderData builderData =
  application.getApplicationContext().initBuilderData();
Builder builder = application.getApplicationContext().newBuilder();

// Process the builder script
builder.build(scriptLocator, builderData);

// Obtain the desired window
Window wnd = (Window) builderData.getBuilderContext().getBean(&quot;window:msgbox&quot;);
    </pre></div>
  
<p>
    This example invokes the generic <code>build()</code> method on a newly
    created <code>Builder</code> instance. From the bean context created during
    this operation it retrieves the window with the name <i>msgbox</i>.
    Alternatively, the <code>WindowBuilderData</code> instance itself can be
    fetched from the bean context. It provides methods for querying windows
    created during the builder operation, too. If this approach is used, the
    last part of the example becomes:
  </p>
    
<div class="source">
<pre>
...
// Obtain the desired window
WindowBuilderData wbd = (WindowBuilderData) builderData.getBuilderContext()
    .getBean(WindowBuilderData.KEY_WINDOW_BUILDER_DATA);
Window = wbd.getWindow(&quot;msgbox&quot;);
    </pre></div>
  
<p>
    In most cases, if the builder script defines only a single window, the
    <code>buildWindow()</code> convenience method of the <code>Builder</code>
    interface should be used. It returns this window directly.
  </p>
  
<p>
    In <i>JGUIraffe</i> windows are represented by the generic
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/window/Window.html">
    Window</a></code> interface. Compared with the APIs of other UI libraries
    this interface is very simple. It provides about a dozen methods for
    querying and setting properties of the underlying window. Typical
    <i>JGUIraffe</i> applications do not need more because the major part of
    the window's properties has already been set by the builder script. The
    methods defined by the <code>Window</code> interface are mainly intended to
    interact with the window at runtime. The following features are accessible
    through the <code>Window</code> interface:
    </p>
<ul>
      
<li>The window can be opened. This is important for new windows created
      during a builder operation as they are not opened automatically. Calling
      this method performs necessary initializations and makes the window
      visible for the first time.</li>
      
<li>The counter part of <code>open()</code> is the <code>close()</code>
      method. It hides the window and frees all its resources.</li>
      
<li>The window's title can be queried and set.</li>
      
<li>The window's position on the screen and its width and height can be
      queried and set.</li>
      
<li>Event listeners can be added to and removed from the window. Event
      listeners are covered later in this document.</li>
      
<li>A window can be associated with a
      <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/window/WindowClosingStrategy.html">
      WindowClosingStrategy</a></code>. Before the window is actually closed it
      asks its closing strategy for permission. Only if the closing strategy
      allows this operation, the window is closed. A typical use case could be
      a component that monitors whether the user has made unsaved changes on the
      data managed by the application. When the application's main window is to
      be closed and there is unsaved data, the closing strategy could display a
      message box asking the user whether the modifications should be stored. If
      the user now clicks on <i>Cancel</i>, the strategy would forbid the
      close operation so that the window stays alive.</li>
      
<li>Windows also can have a controller which can be queried using the
      <code>getWindowController()</code> method. Controllers are discussed in
      more detail later.</li>
    </ul>
  
  
<p>
    For many applications it is just sufficient to open and close a window.
    What happens in between is controlled by view and business logic which does
    not have to access the window object itself. Typically, interaction with
    UI controls is needed, but the window stays as it is after it has been
    created. Opening a window can also be automated by using the
    <code><a href="../apidocs/net/sf/jguiraffe/gui/app/OpenWindowCommand.html">
    OpenWindowCommand</a></code> class described in the section
    <a href="actionbuilder.html#Actions_and_commands">Actions and commands</a>.
  </p>
  
<p>
    So far for the fundamental concepts of the <i>Window builder tag library</i>.
    We will now describe the tags for creating windows.
  </p>
  </section>

  <section>
<h3><a name="Tags_for_creating_windows"></a>Tags for creating windows</h3>
  
<p>
    As has already been pointed out, the <i>Window builder tag library</i>
    supports multiple types of windows. For each window type there exists a
    corresponding tag responsible for the creation of that window. The table
    below gives an overview over the tags and their associated window types.
  </p>
  
<p>
    </p>
<table class="bodyTable" border="1">
    
<tr class="a">
      
<th>Tag</th>
      
<th>Implementation class</th>
      
<th>Window type</th>
    </tr>
    
<tr class="b">
      
<td><code>&lt;w:frame&gt;</code></td>
      
<td><code><a href="../apidocs/net/sf/jguiraffe/gui/builder/window/tags/FrameTag.html">
      FrameTag</a></code></td>
      
<td>Frame windows</td>
    </tr>
    
<tr class="a">
      
<td><code>&lt;w:dialog&gt;</code></td>
      
<td><code><a href="../apidocs/net/sf/jguiraffe/gui/builder/window/tags/DialogTag.html">
      DialogTag</a></code></td>
      
<td>Dialog windows</td>
    </tr>
    
<tr class="b">
      
<td><code>&lt;w:iframe&gt;</code></td>
      
<td><code><a href="../apidocs/net/sf/jguiraffe/gui/builder/window/tags/InternalFrameTag.html">
      InternalFrameTag</a></code></td>
      
<td>Internal frame windows</td>
    </tr>
    </table>
  
  
<p>
    The good news is that all these tags are used in a very similar way. They
    are all derived from the abstract
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/window/tags/WindowBaseTag.html">
    WindowBaseTag</a></code> base tag handler class which already defines a set
    of attributes common to all types of windows. These attributes include
    </p>
<ul>
      
<li>the position of the new window on the screen.</li>
      
<li>width and height of the new window.</li>
      
<li>the title of the window. It can be defined either directly as plain
      text or by a resource ID (in the usual way as is supported by many other
      tags of the <i>JGUIraffe</i> tag libraries).</li>
      
<li>some flags controlling UI-related features of the window, e.g. whether
      it can be resized, minimized, maximized, etc.</li>
      
<li>a flag whether the window should be centered on the screen.</li>
      
<li>the <i>autoClose</i> flag. This flag controls the behavior of the
      close button in the title bar of the window. If set to <b>true</b> - which
      is the default -, the window will automatically close itself (after it has
      asked its closing strategy). If set to <b>false</b>, the close button just
      causes an event to be thrown. The developer is then responsible for
      catching this event and reacting accordingly.</li>
      
<li>the <i>closeOnEsc</i> flag. This flag controls whether the window
      can be closed by pressing the escape key. This is usually desired behavior
      of dialog windows. Here pressing escape means the equivalent of pressing
      the dialog's cancel button: that the user wants to cancel editing and
      dismiss all changes. Therefore the flag is <b>true</b> per default for
      dialog windows and <b>false</b> for windows of other types. Note that a
      value of <b>true</b> for this flag assumes that a cancel button
      is present in the window (refer to
      <a href="formbuilder.html#buttons">Buttons</a> for further information);
      actually, the escape key is handled by simulating a click event on this
      cancel button.</li>
      
<li>a reference to the menu bar of the window. Menus are defined using
      tags of the <i>Action builder tag library</i> as described in the
      section <a href="actionbuilder.html#Main_menus_and_tool_bars">Main menus
      and tool bars</a>. They are stored in the current context and can be
      referenced by windows.</li>
    </ul>
  
  
<p>
    In many cases the default values for these attributes are appropriate. For
    instance, the window's size is determined by its layout manager which
    calculates it based on the preferred sizes of the components contained. The
    position does not matter if the <i>centered</i> flag is set; this makes
    sense for dialog windows. So typical window definitions are indeed pretty
    simple. The following example fragment shows the definition of an
    application main frame window:
  </p>
    
<div class="source">
<pre>
&lt;w:frame titleres=&quot;main_title&quot; menu=&quot;mainMenu&quot; autoClose=&quot;false&quot;&gt;
  ...
&lt;/w:frame&gt;
    </pre></div>
  
<p>
    Here we just define a title for the window (from a resource) and specify the
    menu bar. The menu has been defined using other tags in the same builder
    script. Examples for menu declarations and also for toolbars in windows can
    be found in the section <a href="actionbuilder.html#Main_menus_and_tool_bars">
    Main menus and tool bars</a>.
  </p>
  
<p>
    In this example the <code>autoClose</code> attribute is set to
    <b>false</b>. This can make sense in some special cases, e.g. if special
    cleanup is needed when the window is shut down. For this main window the
    reason for this attribute is a special event mapping: As was discussed in
    the section <a href="actionbuilder.html#Mapping_events_to_actions">Mapping
    events to actions</a> it is possible for actions to be triggered when
    specific events are fired. For the main frame of the application we have
    used this mechanism to map the window's closing event to the action that
    exits the application. If such a mapping is active, the auto close
    mechanism must be disabled because the close operation is already handled by
    the action. More details about this topic will be provided when we talk
    about window event listeners later in this document.
  </p>
  
<p>
    In order to define the window's content, tags from the
    <a href="formbuilder.html#The_tags_of_the_component_builder_tag_library">component
    builder tag library</a> can be placed inside the body of window tags. Each
    window defines an implicit panel acting as a container for arbitrary
    components. Make sure that the correct layout is set, so that the
    components are correctly arranged. For instance, a typical application main
    frame window might use a <a href="layouts.html#BorderLayout">BorderLayout</a>
    with a tool bar in the north and a panel with the actual content in center.
    A skeleton declaration for such a window could look like this:
  </p>
    
<div class="source">
<pre>
&lt;w:frame titleres=&quot;main_title&quot; menu=&quot;mainMenu&quot; autoClose=&quot;false&quot;&gt;
  &lt;f:borderlayout/&gt;
  &lt;!-- A tool bar at the top of the window's content --&gt;
  &lt;a:toolbar&gt;
    &lt;f:borderconstr name=&quot;NORTH&quot;/&gt;
    &lt;!-- Content of tool bar omitted --&gt;
  &lt;/a:toolbar&gt;

  &lt;!-- The main panel --&gt;
  &lt;f:tabbedpane name=&quot;tabs&quot;&gt;
    &lt;f:borderconstr name=&quot;CENTER&quot;/&gt;
    &lt;!-- Content of main panel omitted --&gt;
  &lt;/f:tabbedpane&gt;
&lt;/w:frame&gt;
    </pre></div>
  
<p>
    The definition of a dialog window looks very similar. Here is an example:
  </p>
    
<div class="source">
<pre>
&lt;w:dialog titleres=&quot;newfile_title&quot; center=&quot;true&quot; resizable=&quot;true&quot; modal=&quot;true&quot;&gt;
  ...
&lt;/w:dialog&gt;
    </pre></div>
  
<p>
    Instead of the <code>&lt;w:frame&gt;</code> tag the
    <code>&lt;w:dialog&gt;</code> tag is used. Again, only a small sub set of
    the possible attributes is used. This time we specify a title, set the
    <code>center</code> flag which causes the window to be centered on the
    screen, and make it resizable. Whether a dialog window should be resizable
    or not depends on the controls it contains. If the controls do not profit
    from additional space (e.g. only small text fields or checkboxes are used),
    there is no point in allowing the user to change the size. In this case the
    default size calculated by the layout manager should be appropriate. If on
    the other hand the dialog contains text areas, lists, or other components
    that can grow with additional space becoming available, a value of
    <b>true</b> for the <code>resizable</code> attribute is suitable.
  </p>
  
<p>
    An attribute specific to the <code>&lt;w:dialog&gt;</code> tag is the
    <code>modal</code> attribute. As its name implies, it determines whether the
    resulting dialog should be modal. A modal dialog blocks all other windows of
    the application; they cannot be used before the dialog is closed. Usually
    dialogs for entering data are modal: they need to be filled before the
    application can continue with its normal execution. Non-modal dialogs in
    contrast are used when it makes sense to work with the application in
    parallel. A typical example is a search and replace dialog. While it is open
    it should still be possible to edit a text field in another window.
  </p>
  
<p>
    The tags for creating windows support icons. It is possible to place an
    <code>&lt;f:icon&gt;</code> tag in their body as described in the section
    <a href="formbuilder.html#labels">Labels and icons</a>.
  </p>
  
<p>
    That's it. This has been pretty much all important information about the
    definition of windows using the <i>Window builder tag library</i>. In the
    next sections we deal with some specialities related to the interaction with
    windows.
  </p>
  </section>

  <section>
<h3><a name="Window_events_and_listeners"></a>Window events and listeners</h3>
  
<p>
    As is true for most UI libraries, <i>JGUIraffe</i> supports events related
    to windows and listeners that can receive those events. The event listener
    interface to be implemented by objects that want to be notified about
    state changes of a window is
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/window/WindowListener.html">
    WindowListener</a></code>. This interface defines a bunch of methods
    corresponding to changes in the life-cycle of a window:
    </p>
<ul>
      
<li>the window was opened. This is the first event fired for a window. It
      is sent immediately after it has been opened.</li>
      
<li>the window was activated. An event of this type is fired each time the
      window gains the keyboard focus.</li>
      
<li>the window was deactivated. This is the counterpart of the window
      activated event. It is fired each time the window looses the keyboard
      focus.</li>
      
<li>the window was minimized to an icon. Racting on this event can make
      sense for instance if some of the window's resources can be freed that
      are not needed while it is in icon state.</li>
      
<li>the window has been restored from icon state. This is the counter part
      of the minimized event.</li>
      
<li>the window is about to be closed. This event is fired when the user
      clicks on the close icon in the window's title bar before the window is
      actually closed. If the window has been created with the
      <code>autoClose</code> attribute set to <b>true</b>, it will be closed
      automatically. Otherwise, this event can be caught by a listener which can
      then decide whether to close the window manually.</li>
      
<li>the window was closed. This is the final event sent for a window. It
      indicates that the window has been disposed.</li>
    </ul>
  
  
<p>
    All methods of the <code>WindowListener</code> interface are passed an object
    of the <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/window/WindowEvent.html">
    WindowEvent</a></code> class. This object provides access to the source
    <code>Window</code> object affected by the event, the type of the event
    (this is an enumeration corresponding to the single methods of the
    <code>WindowListener</code> interface), and the original, platform-specific
    event object.
  </p>
  
<p>
    Listeners for window events can be registered at a window programmatically.
    For this purpose the
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/window/Window.html">
    Window</a></code> interface defines the methods
    <code>addWindowListener()</code> and <code>removeWindowListener()</code>.
    (Note that in contrast to events related to form elements the
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/event/FormEventManager.html">
    FormEventManager</a></code> class is not used for the registration of event
    listeners. <code>FormEventManager</code> only knows about elements contained
    in the current form. Also its specialized multiplexing features - e.g.
    registering an action listener for all elements providing this event - are
    not supported for windows.) The following example code fragment shows how
    a listener can be registered at a window created by a builder operation:
  </p>
    
<div class="source">
<pre>
// Execute the builder script and obtain the main window
Window window = builder.buildWindow(scriptLocator, builderData);

// Create and register the window listener
WindowListener listener = new MyWindowListener();
window.addWindowListener(listener);
    </pre></div>
  
<p>
    Here it is assumed that the <code>MyWindowListener</code> class implements
    the <code>WindowListener</code> interface. In addition to the manual
    registration of event listeners in program code, it is also possible to use
    a declarative approach: by defining window listeners in a builder script.
    This works similar to declarative registration of listeners at form elements
    as described in the section
    <a href="actionbuilder.html#Declarative_event_listener_registration">
    Declarative event listener registration</a>: Basically, the bean representing
    the window listener is defined in the builder script. Then the
    <code>&lt;a:eventListener&gt;</code> tag is used to add the listener bean to
    the desired window. The window is referenced using the
    <code>targetBean</code> attribute:
  </p>
    
<div class="source">
<pre>
&lt;!-- Declaration of the window --&gt;
&lt;w:dialog name=&quot;myDialog&quot; title=&quot;Test dialog&quot;&gt;
  ...
&lt;/w:dialog&gt;

&lt;!-- The bean for the window listener --&gt;
&lt;di:bean name=&quot;windowListener&quot; beanClass=&quot;com.mypackage.MyWindowListener&quot;/&gt;

&lt;!-- Register the listener bean --&gt;
&lt;a:eventListener beanName=&quot;windowListener&quot; targetBean=&quot;myDialog&quot;
  eventType=&quot;Window&quot;/&gt;
    </pre></div>
  
<p>
    As usual, the full power of the dependency injection framework can be used
    to initialize the window listener bean. For instance, references to
    required UI components or helper objects can be injected.
  </p>
  
<p>
    In the section <a href="actionbuilder.html#Mapping_events_to_actions">Mapping
    events to actions</a> a set of tags was described which are able to
    connect actions to events fired by form elements. With
    <code>&lt;w:windowEvent&gt;</code> (implemented by the
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/window/tags/WindowListenerTag.html">
    WindowListenerTag</a></code> class) a corresponding tag handler
    implementation exists for windows. Usage is analogous to the other tags for
    form elements: The tag is placed in the body of the tag defining the window.
    The name of the action to be associated with the window events has to be
    provided as an attribute. Optionally, an event filter can be specified, e.g.
    to map the action to a specific window event type. The following example
    fragment shows how the <i>closing</i> event of a window is mapped to an
    action. This is indeed an interesting use case. It allows the developer to
    specify that the application's exit action should be invoked when the user
    closes the main window by clicking on the close icon. That way code
    duplication can be reduced:
  </p>
    
<div class="source">
<pre>
&lt;!-- The main window --&gt;
&lt;w:frame titleres=&quot;main_title&quot; menu=&quot;mainMenu&quot; autoClose=&quot;false&quot;&gt;
  ...
  &lt;!-- An event listener that delegates the window closing event to the
       application exit action.
  --&gt;
  &lt;w:windowEvent actionName=&quot;exitAction&quot;&gt;
    &lt;a:eventFilter eventType=&quot;WINDOW_CLOSING&quot;
      class=&quot;net.sf.jguiraffe.gui.builder.event.filter.TypeEventFilter&quot;/&gt;
  &lt;/w:windowEvent&gt;
&lt;/w:frame&gt;
    </pre></div>
  
<p>
    Note that in this case the <code>autoClose</code> attribute of the
    <code>&lt;w:frame&gt;</code> tag was set to <b>false</b>. The window must
    not be closed automatically because the event listener may decide to veto
    the close operation - e.g. because there is still unsaved data. If everything
    is okay, the exit action will terminate the application. This also causes
    the main window to be shut down.
  </p>
  </section>

  <section>
<h3><a name="Controllers"></a>Controllers</h3>
  
<p>
    In a classical <i>Model View Controller</i> (MVC) architecture, the
    controller plays an important role. It connects the model and the view and
    processes user input accordingly. In the chapter about
    <a href="formcontroller.html">Form controllers</a> we have already discussed
    that <i>JGUIraffe</i> provides a fully functional controller
    implementation with the class
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/window/ctrl/FormController.html">
    FormController</a></code>. This class can be used out of the box to control
    the life-cycle of a form: it populates the form's input fields with their
    initial values, performs validation of user input, and eventually updates
    the model with the data entered by the user. Only if more interaction is
    needed between the graphical elements of the form (e.g. if some input fields
    have to be disabled based on the values entered in other ones), a custom
    controller implementation (which should extend <code>FormController</code>)
    is required.
  </p>
  
<p>
    In the <a href="formcontroller.html">Form controllers</a> chapter there was
    not much information about the creation and initialization of form
    controllers and how they can be associated with window objects. This is
    because a developer typically does not have to perform these steps manually.
    Rather, the complete initialization of a form controller is done by tags
    provided by the <i>Window builder tag library</i>.
  </p>
  
<p>
    In order to setup a controller for a window, a builder script has to contain
    the following declarations:
    </p>
<ul>
      
<li>A bean declaration for the bean acting as the controller. The class of
      this bean must be
      <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/window/ctrl/FormController.html">
      FormController</a></code> or a derived class. The full power of the
      dependency injection framework can be used to initialize all properties of
      the controller bean.</li>
      
<li>Of course, the window itself must be declared. This is done using one
      of the tags introduced in the <a href="#Tags_for_creating_windows">Tags
      for creating windows</a> sub section.</li>
      
<li>In the body of the tag defining the window the
      <code>&lt;w:formController&gt;</code> tag has to be placed. It must
      reference the controller bean. It is this tag which establishes the
      connection between the window and its controller.</li>
      
<li>Optionally, event listener registrations can be performed. This may be
      necessary for custom controller classes which need to track the status of
      some form elements.</li>
    </ul>
    We describe these steps in more detail in the remaining part of this
    sub section.
  
  
<p>
    The first step is to define a bean for the controller. Here all features
    provided by the dependency injection framework as described in the chapter
    <a href="dibuilder.html">The dependency injection builder</a> can be used.
    Because the base class for form controllers,
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/window/ctrl/FormController.html">
    FormController</a></code> is fully functional, it can often be used directly
    instead of implementing a custom controller class. A typical bean definition
    for a controller might look as follows:
  </p>
    
<div class="source">
<pre>
&lt;di:bean name=&quot;controller&quot;
  beanClass=&quot;net.sf.jguiraffe.gui.builder.window.ctrl.FormController&quot;&gt;
  &lt;di:setProperty property=&quot;btnOkName&quot; value=&quot;btnOk&quot;/&gt;
  &lt;di:setProperty property=&quot;btnCancelName&quot; value=&quot;btnCancel&quot;/&gt;
  &lt;di:setProperty property=&quot;okCommand&quot; refName=&quot;okCommand&quot;/&gt;
&lt;/di:bean&gt;
    </pre></div>
  
<p>
    This declaration creates an instance of the base <code>FormController</code>
    class. (<code>FormController</code> has a default constructor, so it is
    sufficient to just specify the bean class.) On the new instance some
    properties are set:
    </p>
<ul>
      
<li>The names of the buttons representing the OK and the Cancel button in
      the form. The controller instance will register itself as action listener
      at these buttons, so it is notified when the user wants to close the form.
      </li>
      
<li>As sdescribed in the sub section <a href="formcontroller.html#Processing_of_form_data">
      Processing of form data</a> a command object is specified that is to be
      executed when the form is closed because the user has clicked the OK
      button (or performed a corresponding action). The command is a bean that
      must be available in the current bean context. Here we assume that a bean
      named <i>okCommand</i> is defined elsewhere in the script.</li>
    </ul>
  
  
<p>
    The properties set in this example declaration are probably the most
    important ones available for <code>FormController</code> beans. Especially
    the button names have to be defined in most cases so that the controller can
    react on button clicks appropriately. Command objects for the OK and Cancel
    actions are optional. They provide a convenient means for initiating complex
    processing of the data entered into the form. If no complex processing
    steps are required, you might prefer event listeners over command objects.
    Event listeners are directly executed by the event dispatch thread. So they
    should only perform short-running operations, otherwise the UI of the
    application will block. Advantages of event listeners are that they are
    easier to implement than a command object and that they are allowed to
    access the UI directly. (Access to the UI is only safe from within the event
    dispatch thread which executes the event listener objects.) The
    <code>FormController</code> class supports the event listener type
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/window/ctrl/FormControllerFormListener.html">
    FormControllerFormListener</a></code>. Listeners of this type are notified
    when the form is closed. They can then react accordingly, e.g. save the
    data when the OK button was clicked. With the event listener tags introduced
    in the subsection <a href="actionbuilder.html#Declarative_event_listener_registration">
    Declarative event listener registration</a> it is possible to create suitable
    event listener objects in a builder script and register them at a form
    controller. Given the form controller declaration above, an event listener
    of the class <code>com.mypackage.MyFormControllerListener</code> can be
    registered as shown in the following fragment:
  </p>
    
<div class="source">
<pre>
&lt;a:eventListener targetBean=&quot;controller&quot; eventType=&quot;Form&quot;
  class=&quot;com.mypackage.MyFormControllerListener&quot;/&gt;
    </pre></div>
  
<p>
    This means that an instance of the class
    <code>com.mypackage.MyFormControllerListener</code> is created. This
    instance is passed to the <code>addFormListener()</code> method of the
    form controller bean referenced by the <code>targetBean</code> attribute.
  </p>
  
<p>
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/window/ctrl/FormControllerFormListener.html">
    FormControllerFormListener</a></code> objects are always invoked when the
    form associated with the controller is closed. Often, an operation should
    only be performed when the OK button was clicked. One way to achieve this is
    to manually inspect the
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/window/ctrl/FormControllerFormEvent.html">
    FormControllerFormEvent</a></code> object passed to the listener: the
    <code>type</code> property of this event can be queried to find out whether
    the form was committed or canceled. An alternative approach is to map
    <code>FormControllerFormEvent</code>s to an action and add a filter for the
    event type <i>FORM_COMMITTED</i>. (Refer to the sub section
    <a href="actionbuilder.html#Mapping_events_to_actions">Mapping events to
    actions</a> for more information about invoking actions through event
    listeners.) To do so, first an action - say <i>okAction</i> - must be
    defined in the builder script. Then the <code>&lt;a:customEvent&gt;</code>
    tag can be used to connect the action to the event listener. This is
    demonstrated in the code fragment below:
  </p>
    
<div class="source">
<pre>
&lt;!-- Definition of an action to be called when the form is committed --&gt;
&lt;a:action name=&quot;okAction&quot; .../&gt;

&lt;!-- Register the action as listener at the controller --&gt;
&lt;a:customEvent actionName=&quot;okAction&quot; targetBean=&quot;controller&quot;&gt;
  &lt;a:listenerType type=&quot;Form&quot;
    listenerClass=&quot;net.sf.jguiraffe.gui.builder.window.ctrl.FormControllerFormListener&quot;/&gt;
  &lt;a:eventFilter eventType=&quot;FORM_COMMITTED&quot;
    class=&quot;net.sf.jguiraffe.gui.builder.event.filter.TypeEventFilter&quot;/&gt;
&lt;/a:customEvent&gt;
    </pre></div>
  
<p>
    After these declarations the form controller is in place and fully
    initialized - even with commands or event listeners for processing the data
    entered into the form. The next step is to associate the controller bean
    with the window it has to control. For this purpose the
    <code>&lt;w:formController&gt;</code> tag exists which is implemented by the
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/window/tags/FormControllerTag.html">
    FormControllerTag</a></code> class. Typically, the tag is placed in the body
    of the tag declaring the window. This might look as follows:
  </p>
    
<div class="source">
<pre>
&lt;!-- The form bean. This object acts as the model of the dialog.--&gt;
&lt;di:bean name=&quot;createFileModel&quot;
  beanClass=&quot;net.sf.jguiraffe.examples.tutorial.createfile.CreateFileData&quot;/&gt;

&lt;!-- The dialog window --&gt;
&lt;w:dialog titleres=&quot;newfile_title&quot; center=&quot;true&quot; resizable=&quot;true&quot;&gt;
  ...

  &lt;!-- Connect the form controller --&gt;
  &lt;w:formController beanName=&quot;controller&quot; formBeanName=&quot;createFileModel&quot;&gt;
  &lt;/w:formController&gt;
&lt;/w:dialog&gt;
    </pre></div>
  
<p>
    In this short fragment some interesting things happen. First a bean acting
    as the model of the form is declared. Per default, forms store their data in
    plain Java beans whose properties match the names of the form's input fields
    (refer to the sub section <a href="formbuilder.html#Components_and_the_form_model">
    Components and the form model</a> for more information). A typical pattern
    to obtain such a model bean is to simply declare it in the builder script.
    It can then be injected into all objects that need access to it, e.g. into
    the command object which is set as <code>okCommand</code> at the controller.
    This is a straightforward way to pass the form's data to the command which
    has to process it.
  </p>
  
<p>
    Then the declaration of a dialog window starts. The major part is omitted.
    We are only interested in the <code>&lt;w:formController&gt;</code> tag
    appearing in the body of the <code>&lt;w:dialog&gt;</code> tag. This tag
    looks pretty simple, but it plays an important role in the initialization of
    the controller. It performs the following steps:
    </p>
<ul>
      
<li>A <code>FormController</code> instance needs access to some internal
      objects storing results of the builder process, e.g. the current
      <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/components/ComponentBuilderData.html">
      ComponentBuilderData</a></code> object. The tag initializes these objects,
      so the developer does not have to care about it.</li>
      
<li>The model of the form is passed to the controller. It is identified by
      the <code>formBeanName</code> attribute. The controller ensures that the
      data entered by the user is stored in this model object.</li>
      
<li>The controller object is stored in the window object so that it can be
      queried using its <code>getWindowController()</code> method.</li>
      
<li>The tag checks whether the form controller bean implements certain
      interfaces. If this is the case, corresponding registrations are performed
      automatically. The following interfaces are evaluated:
      
<ul>
        
<li><code><a href="../apidocs/net/sf/jguiraffe/gui/builder/window/WindowListener.html">
        WindowListener</a></code>. If the controller implements this interface,
        it is automatically registered as listener at the window.</li>
        
<li><code><a href="../apidocs/net/sf/jguiraffe/gui/builder/window/WindowClosingStrategy.html">
        WindowClosingStrategy</a></code>. If the controller implements this
        interface, it is automatically set as the window's closing strategy.</li>
      </ul></li>
    </ul>
  
  
<p>
    After the execution of the <code>&lt;w:formController&gt;</code> tag the
    window and its controller are fully associated. The controller can then
    interact with the form autonomously without intervention of the developer.
  </p>
  
<p>
    There is still a small thing missing: In the section
    <a href="formcontroller.html#Additional_validation_support">Additional
    validation support</a> some classes have been introduced which provide
    feedback about validation errors to the user so invalid input can be
    detected immediately. These classes are called <i>field markers</i>
    because they are able to highlight an input field if it contains invalid
    data. In a <i>JGUIraffe</i> application there is a pre-defined default
    field marker which can be accessed from a bean context using the reserved
    name <i>jguiraffe.fieldMarker</i>. (Of course, an application can define a
    bean with this same name overriding the default marker.) For a field marker
    to work it typically has to listen for some events triggered by the
    controller, e.g. validation events or events reporting field status changes.
    It would be possible to use the standard event registration tags we have
    already discussed to register the field marker at the controller. However,
    this would be pretty inconvenient, especially as it is not per se known
    which concrete field marker implementation is active and which events it
    requires. Therefore a special tag exists which handles the registration of
    event listeners at a form controller. With this tag the form controller
    declaration from the last example can be rewritten:
  </p>
    
<div class="source">
<pre>
  &lt;!-- Connect the form controller --&gt;
  &lt;w:formController beanName=&quot;controller&quot; formBeanName=&quot;createFileModel&quot;&gt;
    &lt;w:formControllerListener beanName=&quot;jguiraffe.fieldMarker&quot;/&gt;
  &lt;/w:formController&gt;
    </pre></div>
  
<p>
    Here the <code>&lt;w:formControllerListener&gt;</code> tag (implemented by the
    <code><a href="../apidocs/net/sf/jguiraffe/gui/builder/window/tags/FormControllerListenerTag.html">
    FormControllerListenerTag</a></code> class) has been added. This tag must
    be placed in the body of a <code>&lt;w:formController&gt;</code> tag. It
    obtains the bean specified by the <code>beanName</code> attribute from the
    current <code>BeanContext</code> - in this case this is the default field
    marker implementation. Then it checks which controller-related interfaces
    are implemented by the bean. For each interface found the bean is registered
    as a corresponding listener at the controller. In our example the tag causes
    the default field marker to be registered for all required events fired by
    the form controller. This effectively enables highlighting of input fields
    containing invalid data.
  </p>
  
<p>
    This is all that has to be said about standard form controllers. Sometimes a
    controller has to interact with the UI in a special way to make it more
    dynamic. For instance, some input fields may only be enabled if certain
    conditions are fulfilled, e.g. if a checkbox is checked. In such cases the
    typical pattern is to implement a custom form controller class derived from
    the base <code>FormController</code> class. This class implements
    corresponding event listener interfaces in order to react on changes at the
    UI. For instance, to listen for the status of a checkbox, the
    <code>FormChangeListener</code> interface would have to be implemented. In
    the builder script tags would be placed for registering the controller as
    event listener at all required input components. The following example
    shows how a controller is registered as change listener at three checkboxes:
  </p>
    
<div class="source">
<pre>
  &lt;!-- Event listener declarations:
       The form controller is registered at some components to be notified for
       status changes.
  --&gt;
  &lt;a:eventListener component=&quot;filterTypes&quot; eventType=&quot;CHANGE&quot;
    beanName=&quot;controller&quot;/&gt;
  &lt;a:eventListener component=&quot;filterSize&quot; eventType=&quot;CHANGE&quot;
    beanName=&quot;controller&quot;/&gt;
  &lt;a:eventListener component=&quot;filterDate&quot; eventType=&quot;CHANGE&quot;
    beanName=&quot;controller&quot;/&gt;
    </pre></div>
  
<p>
    In this example the referenced components are all checkboxes. Of course,
    the controller bean must implement the <code>FormChangeListener</code>
    interface. It is then invoked whenever one of these checkboxes changes its
    value and can update the UI correspondingly.
  </p>
  
<p>
    This concludes our description of windows and their handling in the
    <i>JGUIraffe</i> library. You should now be able to define windows,
    associate them with controller objects and gather and process user input.
  </p>
  </section>
  </section>



      </div>
    </div>
    <div class="clear">
      <hr/>
    </div>
    <div id="footer">
      <div class="xright">
        Copyright &#169;      2021The JGUIraffe Team.
.      </div>
      <div class="clear">
        <hr/>
      </div>
    </div>
  </body>
</html>